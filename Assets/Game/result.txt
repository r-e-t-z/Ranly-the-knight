--- Путь к файлу: .\Scripts\GoToScene.cs ---

﻿using UnityEngine;
using UnityEngine.SceneManagement;

public class GoToScene : MonoBehaviour
{
	public string sceneName;

	void OnTriggerEnter2D(Collider2D other)
	{
		if (other.CompareTag("Player"))
		{
			SceneManager.LoadScene(sceneName);
		}
	}
}

--- Путь к файлу: .\Scripts\PlayerMovement.cs ---

using UnityEngine;

public class PlayerMovement : MonoBehaviour
{
    [Header("")]
    public Sprite frontsprite;
    public Sprite backsprite;
    public Sprite rightsprite;
    public Sprite leftsprite;
    public SpriteRenderer spriterenderer;

    public float runSpeed = 10f;
    public float moveSpeed = 5f;

    private Rigidbody2D rb;
    private Vector2 movement;

    void Start()
    {
        rb = GetComponent<Rigidbody2D>();
    }

    void Update()
    {
        movement.x = Input.GetKey(KeyCode.D) ? 1 : Input.GetKey(KeyCode.A) ? -1 : 0;

        movement.y = Input.GetKey(KeyCode.W) ? 1 : Input.GetKey(KeyCode.S) ? -1 : 0;

        if (Input.GetKey(KeyCode.D))
        {
            spriterenderer.sprite = rightsprite;

        }
        else
        {
            if (Input.GetKey(KeyCode.A))
            {
                spriterenderer.sprite = leftsprite;
            }
            else
            {
                if (Input.GetKey(KeyCode.W))
                {
                    spriterenderer.sprite = backsprite;

                }
                else
                {
                    if (Input.GetKey(KeyCode.S))
                    {
                        spriterenderer.sprite = frontsprite;
                    }
                }
            }
        }

        movement = movement.normalized;
    }

    void FixedUpdate()
    {
        if (Input.GetKey(KeyCode.LeftShift))
        {
            rb.MovePosition(rb.position + movement * runSpeed * Time.fixedDeltaTime);
            return;
        }
        else
        {
            rb.MovePosition(rb.position + movement * moveSpeed * Time.fixedDeltaTime);
        }

            
        
            
    }
}


--- Путь к файлу: .\Scripts\QuestsManager.cs ---

using UnityEngine;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;
using TMPro;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class QuestsManager : MonoBehaviour
{
    public static QuestsManager Instance;
    [Header("Ui")]

    public GameObject questPanel;
    public GameObject questTextButtonPrefab;
    public Transform choicesPanel;

    public List<string> questsTexts = new List<string>();

    void Awake()
    {
        Instance = this;
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.J))
        {
            OpenQuestsList();
            
        }
    }

    public void OpenQuestsList()
    {
        bool newState = !questPanel.activeInHierarchy;
        if (newState == false)
        {
            DeleteQuestsList();
            questPanel.SetActive(false);
        }
        else
        {
            ShowQuestsText();
            questPanel.SetActive(true);
        }
    }

    public void ShowQuestsText()
    {
        foreach(string questText in questsTexts)
        {
            GameObject button = Instantiate(questTextButtonPrefab, choicesPanel);
            TMP_Text buttonText = button.GetComponentInChildren<TMP_Text>();
            buttonText.text = questText;
            Debug.Log("ShowQuestsText -  ");
        }
    }

    public void DeleteQuestsList()
    {
        foreach (Transform child in choicesPanel)
        {
            Destroy(child.gameObject);
        }

    }

    public void AddQuestsTexts(string questText)
    {    
        questsTexts.Add(questText);
        Debug.Log("AddQuestsTexts -  ");
    }
}


--- Путь к файлу: .\Scripts\SceneTransition.cs ---

﻿using UnityEngine;
using UnityEngine.SceneManagement;

public class SceneTransition : MonoBehaviour
{
    [Header("����� �����")]
    public int sceneNumber;
    public void Transition()
    {
        SceneManager.LoadScene(sceneNumber);
    }
}


--- Путь к файлу: .\Scripts\Teleport.cs ---

﻿using UnityEngine;

public class Teleport : MonoBehaviour
{
	public Transform targetPosition;

	void OnTriggerEnter2D(Collider2D other)
	{
		if (other.CompareTag("Player"))
		{
			other.transform.position = targetPosition.position;
		}
	}
}


--- Путь к файлу: .\Scripts\Dialogues\DialogueManager.cs ---

﻿using Ink.Runtime;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;
using TMPro;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class DialogueManager : MonoBehaviour
{
    [Header("UI")]
    public GameObject dialoguePanel;
    public TMP_Text dialogueText;

    [Header("Speaker UI")]
    public Image portraitLeft;
    public TMP_Text nameLeft;
    public Image portraitRight;
    public TMP_Text nameRight;

    [Header("Choices")]
    public Transform choicesContainer;
    public GameObject choiceButtonPrefab;

    private Story story;
    private bool isPlaying = false;
    private NPCData currentNPC;
    private MonoBehaviour playerController;

    private Dictionary<string, object> globalVariables = new Dictionary<string, object>();

    public static DialogueManager Instance;

    void Awake()
    {
        Instance = this;
        choicesContainer.gameObject.SetActive(false);
        dialoguePanel.SetActive(false);
        playerController = FindObjectOfType<PlayerMovement>();
    }

    void Update()
    {
        if (!isPlaying) return;

        if (Input.GetMouseButtonDown(0))
        {
            if (EventSystem.current.IsPointerOverGameObject()) return;
            ContinueDialogue();
        }

        if (Input.GetKeyDown(KeyCode.E))
        {
            ContinueDialogue();
        }
    }

    public void StartDialogue(TextAsset inkJSON, string startKnot = null, NPCData npcData = null)
    {
        if (DialogueManager.Instance.IsPlaying()) return;

        if (playerController != null)
            playerController.enabled = false;

        story = new Story(inkJSON.text);
        currentNPC = npcData;

        RestoreGlobalVariables();

        UpdatePlayerStateVariables();

        if (!string.IsNullOrEmpty(startKnot))
        {
            story.ChoosePathString(startKnot);
        }

        if (npcData != null)
        {
            SetDefaultSpeaker(npcData);
        }

        dialoguePanel.SetActive(true);
        isPlaying = true;

        ContinueDialogue();
    }

    private void UpdatePlayerStateVariables()
    {
        if (story == null) return;

        CheckAllItemVariables();
    }

    private void CheckAllItemVariables()
    {
        if (story == null) return;

        List<string> variableNames = new List<string>();
        foreach (string varName in story.variablesState)
        {
            variableNames.Add(varName);
        }

        foreach (string varName in variableNames)
        {
            if (varName.StartsWith("has_item_"))
            {
                string[] parts = varName.Split('_');
                if (parts.Length >= 4)
                {
                    string itemId = parts[2];
                    if (int.TryParse(parts[3], out int requiredAmount))
                    {
                        try
                        {
                            bool hasItem = CheckActiveSlotForItem(itemId, requiredAmount);
                            story.variablesState[varName] = hasItem;
                        }
                        catch (System.Exception e)
                        {
                            Debug.LogWarning($"Ошибка при обновлении {varName}: {e.Message}");
                        }
                    }
                }
            }
        }
    }

    private bool CheckActiveSlotForItem(string itemId, int requiredAmount)
    {
        if (InventoryManager.Instance == null) return false;

        var activeSlot = InventoryManager.Instance.activeItemSlot;

        if (activeSlot.HasItem() && activeSlot.Item.data.itemID == itemId)
        {
            return activeSlot.Item.stackSize >= requiredAmount;
        }

        return false;
    }

    private void RestoreGlobalVariables()
    {
        foreach (var variable in globalVariables)
        {
            try
            {
                story.variablesState[variable.Key] = variable.Value;
            }
            catch (System.Exception e)
            {
                Debug.LogWarning($"Не удалось восстановить переменную {variable.Key}: {e.Message}");
            }
        }
    }

    private void SaveGlobalVariables()
    {
        if (story == null) return;

        List<string> variableNames = new List<string>();
        foreach (string variableName in story.variablesState)
        {
            variableNames.Add(variableName);
        }

        foreach (string variableName in variableNames)
        {
            try
            {
                globalVariables[variableName] = story.variablesState[variableName];
            }
            catch (System.Exception e)
            {
                Debug.LogWarning($"Не удалось сохранить переменную {variableName}: {e.Message}");
            }
        }
    }

    private void SetDefaultSpeaker(NPCData npcData)
    {
        if (npcData == null) return;

        portraitLeft.gameObject.SetActive(true);
        nameLeft.gameObject.SetActive(true);
        nameLeft.text = npcData.npcName;

        if (npcData.portrait != null)
        {
            portraitLeft.sprite = npcData.portrait;
        }
    }

    public void ContinueDialogue()
    {
        foreach (Transform child in choicesContainer)
            Destroy(child.gameObject);

        if (story.canContinue)
        {
            string text = story.Continue();
            dialogueText.text = text.Trim();

            ProcessAllTags();

            ApplyVisualTags();
        }
        else if (story.currentChoices.Count > 0)
        {
            ShowChoices();
        }
        else
        {
            EndDialogue();
        }
    }

    private void ProcessAllTags()
    {
        List<string> currentTags = story.currentTags;

        Dictionary<string, List<string>> actions = new Dictionary<string, List<string>>();
        string currentAction = "";

        foreach (string tag in currentTags)
        {
            if (tag.StartsWith("action:"))
            {
                currentAction = tag.Substring(7); 
                actions[currentAction] = new List<string>();
            }
            else if (!string.IsNullOrEmpty(currentAction))
            {
                actions[currentAction].Add(tag);
            }
            else if (tag.StartsWith("set_"))
            {
                ProcessSetTag(tag);
            }
        }

        foreach (var action in actions)
        {
            ExecuteAction(action.Key, action.Value);
        }
    }

    private void ExecuteAction(string actionType, List<string> parameters)
    {

        switch (actionType)
        {
            case "give_item":
                GiveItemAction(parameters);
                break;
            case "take_item":
                TakeItemAction(parameters);
                break;
            case "activate_trigger":
                ActivateTriggerAction(parameters);
                break;
            case "deactivate_object":
                DeactivateObjectAction(parameters);
                break;
            case "start_animation":
                StartAnimationAction(parameters);
                break;
            case "quest_text":
                QuestTextAction(parameters);
                break;
            case "change_scene":
                ChangeSceneAction(parameters);
                break;
            case "teleport_player":
                TeleportPlayerAction(parameters);
                break;
            case "unlock_ability":
                UnlockAbilityAction(parameters);
                break;
            default:
                Debug.LogWarning($"Неизвестное действие: {actionType}");
                break;
        }
    }

    private void GiveItemAction(List<string> parameters)
    {
        string itemId = GetParameterValue(parameters, "item_id");
        int amount = GetIntParameterValue(parameters, "amount", 1);

        if (!string.IsNullOrEmpty(itemId))
        {
            InventoryManager.Instance.AddItem(itemId, amount);
        }
    }

    private void TakeItemAction(List<string> parameters)
    {
        string itemId = GetParameterValue(parameters, "item_id");
        int amount = GetIntParameterValue(parameters, "amount", 1);

        if (!string.IsNullOrEmpty(itemId))
        {
            bool success = InventoryManager.Instance.RemoveItemFromActiveSlot(itemId, amount);
        }
    }


    private void ActivateTriggerAction(List<string> parameters)
    {
        string triggerName = GetParameterValue(parameters, "trigger_name");
        if (!string.IsNullOrEmpty(triggerName))
        {
            GameObject trigger = GameObject.Find(triggerName);
            if (trigger != null)
            {
                Collider2D collider = trigger.GetComponent<Collider2D>();
                if (collider != null) collider.enabled = true;
            }
        }
    }

    private void DeactivateObjectAction(List<string> parameters)
    {
        string objectName = GetParameterValue(parameters, "object_name");
        if (!string.IsNullOrEmpty(objectName))
        {
            GameObject obj = GameObject.Find(objectName);
            if (obj != null)
            {
                obj.SetActive(false);
            }
        }
    }

    private void StartAnimationAction(List<string> parameters)
    {
        string animationName = GetParameterValue(parameters, "animation_name");
        string animationNames = GetParameterValue(parameters, "animation_names");

        if (!string.IsNullOrEmpty(animationNames))
        {
            string[] names = animationNames.Split(',');
            AnimationManager.Instance.PlayMultipleAnimations(names);
        }
        else if (!string.IsNullOrEmpty(animationName))
        {
            AnimationManager.Instance.PlayAnimation(animationName);
        }
    }

    private void QuestTextAction(List<string> parameters)
    {
        Debug.Log($"3 - Это делается ");
        string questText = GetParameterValue(parameters, "quest_text");
        QuestsManager.Instance.AddQuestsTexts(questText);
        Debug.Log($"12 - Это делается {questText}");
    }

    private void ChangeSceneAction(List<string> parameters)
    {
        string sceneName = GetParameterValue(parameters, "scene_name");
    }

    private void TeleportPlayerAction(List<string> parameters)
    {
        string location = GetParameterValue(parameters, "location");
    }

    private void UnlockAbilityAction(List<string> parameters)
    {
        string ability = GetParameterValue(parameters, "ability");
    }

    private string GetParameterValue(List<string> parameters, string key)
    {
        foreach (string param in parameters)
        {
            if (param.StartsWith(key + ":"))
            {
                return param.Substring(key.Length + 1);
            }
        }
        return "";
    }

    private int GetIntParameterValue(List<string> parameters, string key, int defaultValue)
    {
        string value = GetParameterValue(parameters, key);
        return int.TryParse(value, out int result) ? result : defaultValue;
    }

    private void ProcessSetTag(string tag)
    {
        string[] parts = tag.Split(' ');
        if (parts.Length == 2)
        {
            string varName = parts[0].Substring(4); 
            string value = parts[1].ToLower();

            if (value == "true" || value == "false")
            {
                story.variablesState[varName] = value == "true";
            }
            else
            {
                story.variablesState[varName] = value;
            }
        }
    }

    private void ApplyVisualTags()
    {
        portraitLeft.gameObject.SetActive(false);
        portraitRight.gameObject.SetActive(false);
        nameLeft.gameObject.SetActive(false);
        nameRight.gameObject.SetActive(false);

        foreach (string tag in story.currentTags)
        {
            if (tag == "side:left")
            {
                portraitLeft.gameObject.SetActive(true);
                nameLeft.gameObject.SetActive(true);
            }
            else if (tag == "side:right")
            {
                portraitRight.gameObject.SetActive(true);
                nameRight.gameObject.SetActive(true);
            }
            else if (tag.StartsWith("speaker: "))
            {
                string speakerName = tag.Substring("speaker: ".Length);
                if (portraitLeft.gameObject.activeSelf)
                    nameLeft.text = speakerName;
                if (portraitRight.gameObject.activeSelf)
                    nameRight.text = speakerName;
            }
            else if (tag.StartsWith("portrait: "))
            {
                string portraitName = tag.Substring("portrait: ".Length);
                Sprite sprite = Resources.Load<Sprite>("Portraits/" + portraitName);
                if (sprite != null)
                {
                    if (portraitLeft.gameObject.activeSelf)
                        portraitLeft.sprite = sprite;
                    if (portraitRight.gameObject.activeSelf)
                        portraitRight.sprite = sprite;
                }
            }
        }
    }

    private void ShowChoices()
    {
        choicesContainer.gameObject.SetActive(true);
        for (int i = 0; i < story.currentChoices.Count; i++)
        {
            Choice choice = story.currentChoices[i];
            GameObject button = Instantiate(choiceButtonPrefab, choicesContainer);
            TMP_Text buttonText = button.GetComponentInChildren<TMP_Text>();
            buttonText.text = choice.text;

            Button btn = button.GetComponent<Button>();
            int choiceIndex = i;
            btn.onClick.AddListener(() => {
                story.ChooseChoiceIndex(choiceIndex);
                ContinueDialogue();
            });
        }
    }

    private void EndDialogue()
    {
        SaveGlobalVariables();

        isPlaying = false;
        dialoguePanel.SetActive(false);

        if (playerController != null)
            playerController.enabled = true;

        currentNPC = null;
        choicesContainer.gameObject.SetActive(false);
    }

    public bool IsPlaying() => isPlaying;
}

--- Путь к файлу: .\Scripts\Dialogues\DialogueTrigger.cs ---

﻿using Ink.Runtime;
using System.Xml.Linq;
using UnityEngine;

public class DialogueTrigger : MonoBehaviour
{
    [Header("NPC Settings")]
    public NPCData npcData;

    [Header("Trigger Settings")]
    public bool workOnlyOnce = false;
    public bool startOnEnter = false;
    public bool requirePressE = true;

    private bool inRange = false;
    private bool alreadyUsed = false;

    void OnTriggerEnter2D(Collider2D other)
    {
        if (alreadyUsed && workOnlyOnce) return;
        if (other.CompareTag("Player"))
        {
            inRange = true;
            if (startOnEnter && !requirePressE)
                StartDialogue();
            else if (requirePressE)
                UIInteractPrompt.Instance.Show("Нажми E");
        }
    }

    void OnTriggerExit2D(Collider2D other)
    {
        if (other.CompareTag("Player"))
        {
            inRange = false;
            UIInteractPrompt.Instance.Hide();
        }
    }

    void Update()
    {
        if (inRange && requirePressE && Input.GetKeyDown(KeyCode.E))
        {
            if (DialogueManager.Instance != null && DialogueManager.Instance.IsPlaying())
            {
                return;
            }

            UIInteractPrompt.Instance.Hide();
            StartDialogue();
        }
    }

    void StartDialogue()
    {
        if (workOnlyOnce)
        {
            alreadyUsed = true;
            inRange = false;
        }

        DialogueManager.Instance.StartDialogue(npcData.inkFile, "start", npcData);
    }

    public void ResetMeeting()
    {
        alreadyUsed = false;
    }
}

--- Путь к файлу: .\Scripts\Dialogues\ForestExitTrigger.cs ---

using UnityEngine;
using System.Collections;
using TMPro;

public class ForestExitTrigger : MonoBehaviour
{
    [Header(" ")]
    public Transform returnPoint;

    [Header("")]
    public TextAsset[] dialogues;

    [Header(" ")]
    public float moveSpeed = 3f;
    public int maxAttempts = 3;
    public bool enableQuickTimeEvent = true;

    [Header("  ")]
    public float requiredPresses = 10f;
    public float moveDistancePerPress = 0.2f;
    public float timeLimit = 3f;

    [Header("UI ")]
    public TextMeshProUGUI quickTimeText;

    private int exitAttempts = 0;
    private PlayerMovement playerController;
    private SpriteRenderer playerSprite;
    private bool isReturning = false;
    private bool quickTimeActive = false;
    private float currentPresses = 0f;
    private float quickTimeTimer = 0f;
    private Vector3 quickTimeStartPosition;
    private Vector3 quickTimeTargetPosition;

    void Start()
    {
        playerController = FindObjectOfType<PlayerMovement>();
        GameObject player = GameObject.FindGameObjectWithTag("Player");
        playerSprite = player.GetComponent<SpriteRenderer>();

        if (quickTimeText != null)
            quickTimeText.gameObject.SetActive(false);
    }

    private void OnTriggerEnter2D(Collider2D other)
    {
        if (other.CompareTag("Player") && exitAttempts < maxAttempts && !isReturning && !quickTimeActive)
        {
            exitAttempts++;

            if (exitAttempts == maxAttempts && enableQuickTimeEvent)
            {
                StartQuickTimeEvent(other.gameObject);
            }
            else
            {
                StartCoroutine(ReturnPlayer(other.gameObject));
            }
        }
    }

    void StartQuickTimeEvent(GameObject player)
    {
        quickTimeActive = true;
        currentPresses = 0f;
        quickTimeTimer = timeLimit;

        quickTimeStartPosition = player.transform.position;
        quickTimeTargetPosition = returnPoint.position;

        if (quickTimeText != null)
        {
            quickTimeText.text = $"  A! {currentPresses}/{requiredPresses}";
            quickTimeText.gameObject.SetActive(true);
        }

        if (playerController != null)
            playerController.enabled = false;
    }

    void Update()
    {
        if (quickTimeActive)
        {
            quickTimeTimer -= Time.deltaTime;

            if (Input.GetKeyDown(KeyCode.A))
            {
                OnQuickTimePress();
            }

            UpdateQuickTimeUI();

            if (currentPresses >= requiredPresses)
            {
                QuickTimeSuccess();
            }
            else if (quickTimeTimer <= 0f)
            {
                QuickTimeFail();
            }
        }
    }

    void OnQuickTimePress()
    {
        currentPresses++;

        GameObject player = GameObject.FindGameObjectWithTag("Player");
        if (player != null)
        {
            player.transform.position += Vector3.left * moveDistancePerPress;

            playerSprite.sprite = playerController.leftsprite;
        }
    }

    void UpdateQuickTimeUI()
    {
        if (quickTimeText != null)
        {
            quickTimeText.text = $"  A! {currentPresses}/{requiredPresses}\n: {quickTimeTimer:F1}";
        }
    }

    void QuickTimeSuccess()
    {
        quickTimeActive = false;

        if (quickTimeText != null)
            quickTimeText.gameObject.SetActive(false);

        if (playerController != null)
            playerController.enabled = true;

        StartAnDialogue();
    }

    void QuickTimeFail()
    {
        quickTimeActive = false;

        if (quickTimeText != null)
            quickTimeText.gameObject.SetActive(false);

        GameObject player = GameObject.FindGameObjectWithTag("Player");
        if (player != null)
        {
            player.transform.position = quickTimeStartPosition;
        }


        if (playerController != null)
            playerController.enabled = true;

        StartAnDialogue();
    }

    IEnumerator ReturnPlayer(GameObject player)
    {
        isReturning = true;

        if (playerController != null)
        {
            playerController.enabled = false;
        }

        yield return new WaitForSeconds(0.3f);

        while (Vector3.Distance(player.transform.position, returnPoint.position) > 0.1f)
        {
            Vector3 direction = (returnPoint.position - player.transform.position).normalized;
            player.transform.position += direction * moveSpeed * Time.deltaTime;
            UpdatePlayerSprite(direction);
            yield return null;
        }

        if (playerController != null)
        {
            playerController.enabled = true;
        }

        isReturning = false;
        StartAnDialogue();
    }

    void UpdatePlayerSprite(Vector3 direction)
    {
        if (playerSprite == null || playerController == null) return;

        if (Mathf.Abs(direction.x) > Mathf.Abs(direction.y))
        {
            if (direction.x > 0)
            {
                playerSprite.sprite = playerController.rightsprite;
            }
            else
            {
                playerSprite.sprite = playerController.leftsprite;
            }
        }
        else
        {
            if (direction.y > 0)
            {
                playerSprite.sprite = playerController.backsprite;
            }
            else
            {
                playerSprite.sprite = playerController.frontsprite;
            }
        }
    }

    void StartAnDialogue()
    {
        TextAsset dialogueToPlay = GetDialogue();

        DialogueManager dialogueManager = FindObjectOfType<DialogueManager>();
        if (dialogueManager != null && dialogueToPlay != null)
        {
            dialogueManager.StartDialogue(dialogueToPlay);
        }
    }


    TextAsset GetDialogue()
    {
        if (exitAttempts <= dialogues.Length)
        {
            return dialogues[exitAttempts - 1];
        }
        else
        {
            return dialogues[dialogues.Length - 1];
        }
    }

    public void ResetAttempts()
    {
        exitAttempts = 0;
        quickTimeActive = false;
        currentPresses = 0f;

        if (quickTimeText != null)
            quickTimeText.gameObject.SetActive(false);
    }
}

--- Путь к файлу: .\Scripts\Dialogues\NPCData.cs ---

using UnityEngine;

[CreateAssetMenu(fileName = "New NPC", menuName = "Dialogue/NPC Data")]
public class NPCData : ScriptableObject
{
    [Header("Basic Info")]
    public string npcName;
    public Sprite portrait;

    [Header("Ink File")]
    public TextAsset inkFile;
}

--- Путь к файлу: .\Scripts\Dialogues\UIInteractPrompt.cs ---

using UnityEngine;
using TMPro;

public class UIInteractPrompt : MonoBehaviour
{
    public static UIInteractPrompt Instance;

    public TMP_Text promptText;

    void Awake()
    {
        Instance = this;
        promptText.gameObject.SetActive(false);
    }

    public void Show(string text)
    {
        promptText.text = text;
        promptText.gameObject.SetActive(true);
    }

    public void Hide()
    {
        promptText.gameObject.SetActive(false);
    }
}


--- Путь к файлу: .\Scripts\GameSave\Checkpoint.cs ---

using UnityEngine;

public class Checkpoint : MonoBehaviour
{
    [Header("  ")]
    public bool isActive = true;
    public string playerTag = "Player";


    private Renderer checkpointRenderer;

    void Start()
    {
        checkpointRenderer = GetComponent<Renderer>();
    }

    private void OnTriggerEnter(Collider other)
    {
        if (!isActive) return;

        if (other.CompareTag(playerTag))
        {
            SaveAtCheckpoint();
        }
    }

    private void OnTriggerEnter2D(Collider2D other)
    {
        if (!isActive) return;

        if (other.CompareTag(playerTag))
        {
            SaveAtCheckpoint();
        }
    }

    private void SaveAtCheckpoint()
    {
        GameObject player = GameObject.FindGameObjectWithTag(playerTag);
        if (player != null)
        {
            SaveSystem.SaveGame(player.transform.position);
            isActive = false;
            Debug.Log("   !");
        }
    }
}

--- Путь к файлу: .\Scripts\GameSave\GameLoader.cs ---

using UnityEngine;

public class GameLoader : MonoBehaviour
{
    [Header(" ")]
    public Transform defaultSpawnPoint;

    void Start()
    {
        LoadGameState();
    }

    void LoadGameState()
    {
        SaveData saveData = SaveSystem.LoadGame();

        GameObject player = GameObject.FindGameObjectWithTag("Player");
        if (player == null)
        {
            Debug.LogWarning("    !");
            return;
        }

        Vector3 spawnPosition;

        if (saveData != null && saveData.hasSaveData)
        {
            spawnPosition = saveData.GetPlayerPosition();
            Debug.Log("  : " + spawnPosition);
        }
        else
        {
            spawnPosition = defaultSpawnPoint != null ? defaultSpawnPoint.position : Vector3.zero;
            Debug.Log("   ");
        }

        player.transform.position = spawnPosition;
    }
}

--- Путь к файлу: .\Scripts\GameSave\GameSaveManager.cs ---

using UnityEngine;

public class GameSaveManager : MonoBehaviour
{
    [Header(" ")]
    public bool enableQuickSaveKey = true;

    [Header("UI  ")]
    public bool enableSaveButton = true;

    [Header(" ")]
    public bool enableCheckpoints = true;

    public void SaveFromButton()
    {
        if (enableSaveButton)
        {
            SaveGame();
        }
    }

    public void QuickSave()
    {
        SaveGame();
        Debug.Log("  !");
    }

    private void SaveGame()
    {
        GameObject player = GameObject.FindGameObjectWithTag("Player");
        if (player != null)
        {
            SaveSystem.SaveGame(player.transform.position);
        }
    }
}

--- Путь к файлу: .\Scripts\GameSave\SaveSystem.cs ---

using UnityEngine;
using System.IO;
using System;

[Serializable]
public class SaveData
{
    public float playerX;
    public float playerY;
    public float playerZ;
    public bool hasSaveData;

    public SaveData(Vector3 playerPosition)
    {
        playerX = playerPosition.x;
        playerY = playerPosition.y;
        playerZ = playerPosition.z;
        hasSaveData = true;
    }

    public Vector3 GetPlayerPosition()
    {
        return new Vector3(playerX, playerY, playerZ);
    }
}

public static class SaveSystem
{
    private static string savePath;
    private const string SAVE_FILE_NAME = "gamesave.json";

    static SaveSystem()
    {
        savePath = Path.Combine(Application.persistentDataPath, SAVE_FILE_NAME);
    }

    public static void SaveGame(Vector3 playerPosition)
    {
        SaveData saveData = new SaveData(playerPosition);
        string json = JsonUtility.ToJson(saveData);

        try
        {
            File.WriteAllText(savePath, json);
            Debug.Log(" : " + savePath);
        }
        catch (System.Exception e)
        {
            Debug.LogError(" : " + e.Message);
        }
    }

    public static SaveData LoadGame()
    {
        if (!File.Exists(savePath))
        {
            Debug.Log("  ");
            return null;
        }

        try
        {
            string json = File.ReadAllText(savePath);
            SaveData saveData = JsonUtility.FromJson<SaveData>(json);
            Debug.Log(" ");
            return saveData;
        }
        catch (System.Exception e)
        {
            Debug.LogError(" : " + e.Message);
            return null;
        }
    }

    public static bool HasSaveData()
    {
        if (!File.Exists(savePath)) return false;

        try
        {
            string json = File.ReadAllText(savePath);
            SaveData saveData = JsonUtility.FromJson<SaveData>(json);
            return saveData != null && saveData.hasSaveData;
        }
        catch
        {
            return false;
        }
    }

    public static void DeleteSave()
    {
        if (File.Exists(savePath))
        {
            File.Delete(savePath);
        }
    }
}

--- Путь к файлу: .\Scripts\Inventory\InventoryItem.cs ---

using UnityEngine;

//         .
//   ScriptableObject,   C# .
[System.Serializable]
public class InventoryItem
{
    public ItemData data;
    public int stackSize;

    //       .
    public InventoryItem(ItemData itemData, int amount = 1)
    {
        data = itemData;
        stackSize = amount;
    }

    //     .  true,  .
    public bool AddToStack(int amount = 1)
    {
        if (stackSize + amount <= data.maxStackSize)
        {
            stackSize += amount;
            return true;
        }
        return false;
    }

    //   .  true,       .
    public bool RemoveFromStack(int amount = 1)
    {
        stackSize -= amount;
        return stackSize <= 0;
    }
}

--- Путь к файлу: .\Scripts\Inventory\InventoryManager.cs ---

using UnityEngine;
using System;

public class InventoryManager : MonoBehaviour
{
    public static InventoryManager Instance;

    //    UI    .
    public static event Action<InventorySlot[]> OnInventoryChanged;
    public static event Action<InventoryItem> OnActiveItemChanged;

    //   .
    [SerializeField] private int inventorySize = 9;
    public InventorySlot[] inventorySlots;
    public InventorySlot activeItemSlot;

    //     .
    [SerializeField] private ItemDBSO itemDatabase;

    [Header("UI Settings")]
    public GameObject inventoryPanel;
    public GameObject activeSlotUI; //      !

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
            return;
        }

        InitializeInventory();
    }

    private void Update()
    {
        // /   Tab
        if (Input.GetKeyDown(KeyCode.Tab))
        {
            ToggleInventory();
        }
    }

    private void InitializeInventory()
    {
        inventorySlots = new InventorySlot[inventorySize];
        activeItemSlot = new InventorySlot();

        for (int i = 0; i < inventorySlots.Length; i++)
        {
            inventorySlots[i] = new InventorySlot();
        }
    }

    //   / 
    public void ToggleInventory()
    {
        if (inventoryPanel != null)
        {
            bool newState = !inventoryPanel.activeInHierarchy;
            inventoryPanel.SetActive(newState);
        }
    }

    //        
    public void MoveToActiveSlot(int fromSlotIndex)
    {
        if (fromSlotIndex < 0 || fromSlotIndex >= inventorySlots.Length) return;
        if (!inventorySlots[fromSlotIndex].HasItem()) return;

        //        -    
        if (activeItemSlot.HasItem())
        {
            int emptySlot = FindEmptySlot();
            if (emptySlot != -1)
            {
                inventorySlots[emptySlot].SetItem(activeItemSlot.Item);
                activeItemSlot.ClearSlot();
            }
            else
            {
                Debug.Log("       !");
                return;
            }
        }

        //      
        activeItemSlot.SetItem(inventorySlots[fromSlotIndex].Item);
        inventorySlots[fromSlotIndex].ClearSlot();

        //  UI
        OnInventoryChanged?.Invoke(inventorySlots);
        OnActiveItemChanged?.Invoke(activeItemSlot.Item);
    }

    public void MoveToInventoryFromActive()
    {
        if (!activeItemSlot.HasItem()) return;

        int emptySlot = FindEmptySlot();
        if (emptySlot != -1)
        {
            inventorySlots[emptySlot].SetItem(activeItemSlot.Item);
            activeItemSlot.ClearSlot();

            OnInventoryChanged?.Invoke(inventorySlots);
            OnActiveItemChanged?.Invoke(null);
        }
        else
        {
            Debug.Log("    !");
        }
    }

    //      
    private int FindEmptySlot()
    {
        for (int i = 0; i < inventorySlots.Length; i++)
        {
            if (!inventorySlots[i].HasItem())
            {
                return i;
            }
        }
        return -1;
    }

    //         ID.
    public bool AddItem(string itemID, int amount = 1)
    {
        ItemData itemToAdd = itemDatabase.GetItemByID(itemID);
        if (itemToAdd == null) return false;

        //      (  )
        if (itemToAdd.isStackable)
        {
            for (int i = 0; i < inventorySlots.Length; i++)
            {
                if (inventorySlots[i].HasItem() && inventorySlots[i].Item.data == itemToAdd)
                {
                    if (inventorySlots[i].Item.AddToStack(amount))
                    {
                        OnInventoryChanged?.Invoke(inventorySlots);
                        return true;
                    }
                }
            }
        }

        //       
        for (int i = 0; i < inventorySlots.Length; i++)
        {
            if (!inventorySlots[i].HasItem())
            {
                inventorySlots[i].SetItem(new InventoryItem(itemToAdd, amount));
                OnInventoryChanged?.Invoke(inventorySlots);
                return true;
            }
        }

        Debug.Log("Inventory is full!");
        return false;
    }

    //      .
    public void TryCraftItems(int fromSlotIndex, int toSlotIndex)
    {
        InventoryItem itemA = inventorySlots[fromSlotIndex].Item;
        InventoryItem itemB = inventorySlots[toSlotIndex].Item;

        if (itemA == null || itemB == null) return;

        Debug.Log($" : {itemA.data.itemName} + {itemB.data.itemName}");

        ItemData resultItem = FindCraftingResult(itemA.data, itemB.data);

        if (resultItem != null)
        {
            Debug.Log($" ! : {resultItem.itemName}");

            RemoveItemFromSlot(fromSlotIndex);
            RemoveItemFromSlot(toSlotIndex);

            AddItem(resultItem.itemID);
        }
        else
        {
            Debug.Log($" : {itemA.data.itemName} + {itemB.data.itemName}");
        }
    }

    //      .
    private ItemData FindCraftingResult(ItemData ingredient1, ItemData ingredient2)
    {
        foreach (ItemData potentialResult in itemDatabase.allItems)
        {
            if (potentialResult.craftingRecipes != null)
            {
                foreach (CraftingRecipe recipe in potentialResult.craftingRecipes)
                {
                    if ((recipe.item1 == ingredient1 && recipe.item2 == ingredient2) ||
                        (recipe.item1 == ingredient2 && recipe.item2 == ingredient1))
                    {
                        Debug.Log($" : {ingredient1.itemName} + {ingredient2.itemName} = {potentialResult.itemName}");
                        return potentialResult;
                    }
                }
            }
        }

        Debug.Log($"   : {ingredient1.itemName} + {ingredient2.itemName}");
        return null;
    }

    public bool RemoveItemFromActiveSlot(string itemID, int amount)
    {
        var activeSlot = activeItemSlot;

        if (activeSlot.HasItem() && activeSlot.Item.data.itemID == itemID)
        {
            if (activeSlot.Item.stackSize >= amount)
            {
                if (activeSlot.Item.stackSize == amount)
                {
                    activeSlot.ClearSlot();
                    ForceInventoryUpdate();
                    Debug.Log($"??      : {itemID} x{amount}");
                    return true;
                }
                else
                {
                    activeSlot.Item.stackSize -= amount;
                    ForceInventoryUpdate();
                    Debug.Log($"??      : {itemID} x{amount}. : {activeSlot.Item.stackSize}");
                    return true;
                }
            }
        }

        Debug.LogWarning($"?     {itemID} x{amount}   ");
        return false;
    }

    //   
    public void SetActiveItem(InventoryItem item)
    {
        activeItemSlot.SetItem(item);
        OnActiveItemChanged?.Invoke(item);
    }

    //   
    public void ClearActiveItem()
    {
        activeItemSlot.ClearSlot();
        OnActiveItemChanged?.Invoke(null);
    }

    //     
    public void RemoveItemFromSlot(int slotIndex)
    {
        if (slotIndex >= 0 && slotIndex < inventorySlots.Length)
        {
            inventorySlots[slotIndex].ClearSlot();
            OnInventoryChanged?.Invoke(inventorySlots);
        }
    }

    //      InventoryManager
    public int GetItemCount(string itemID)
    {
        int totalCount = 0;

        //   
        if (activeItemSlot.HasItem() && activeItemSlot.Item.data.itemID == itemID)
        {
            totalCount += activeItemSlot.Item.stackSize;
        }

        //    
        foreach (var slot in inventorySlots)
        {
            if (slot.HasItem() && slot.Item.data.itemID == itemID)
            {
                totalCount += slot.Item.stackSize;
            }
        }

        return totalCount;
    }

    public void ForceInventoryUpdate()
    {
        //      UI
        OnInventoryChanged?.Invoke(inventorySlots);

        if (activeItemSlot.HasItem())
        {
            OnActiveItemChanged?.Invoke(activeItemSlot.Item);
        }
        else
        {
            OnActiveItemChanged?.Invoke(null);
        }
    }


    public void UpdateInventoryUI()
    {
        //     UI
        OnInventoryChanged?.Invoke(inventorySlots);
        if (activeItemSlot.HasItem())
        {
            OnActiveItemChanged?.Invoke(activeItemSlot.Item);
        }
        else
        {
            OnActiveItemChanged?.Invoke(null);
        }
    }
}

// ,     .
[System.Serializable]
public class InventorySlot
{
    public InventoryItem Item;

    public bool HasItem()
    {
        return Item != null;
    }

    public void SetItem(InventoryItem newItem)
    {
        Item = newItem;
    }

    public void ClearSlot()
    {
        Item = null;
    }
}

--- Путь к файлу: .\Scripts\Inventory\InventorySlotUI.cs ---

using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class InventorySlotUI : MonoBehaviour, IPointerClickHandler, IBeginDragHandler, IEndDragHandler, IDropHandler, IDragHandler
{
    [SerializeField] private Image itemIcon;
    [SerializeField] private TMPro.TextMeshProUGUI stackCountText;

    public int SlotIndex;
    public bool isActiveItemSlot = false;

    private InventorySlot assignedSlot;
    private GameObject dragObject;
    private float lastClickTime;
    private const float doubleClickThreshold = 0.3f;

    private void Start()
    {
        InventoryManager.OnInventoryChanged += UpdateSlotUI;
        InventoryManager.OnActiveItemChanged += UpdateActiveSlotUI;

        if (!isActiveItemSlot)
        {
            assignedSlot = InventoryManager.Instance.inventorySlots[SlotIndex];
        }
        else
        {
            assignedSlot = InventoryManager.Instance.activeItemSlot;
            UpdateActiveSlotVisibility();
        }
        UpdateSlotDisplay();
    }

    private void OnDestroy()
    {
        InventoryManager.OnInventoryChanged -= UpdateSlotUI;
        InventoryManager.OnActiveItemChanged -= UpdateActiveSlotUI;
    }

    private void UpdateSlotUI(InventorySlot[] inventory)
    {
        if (!isActiveItemSlot)
        {
            UpdateSlotDisplay();
        }
    }

    private void UpdateActiveSlotUI(InventoryItem activeItem)
    {
        if (isActiveItemSlot)
        {
            UpdateSlotDisplay();
            UpdateActiveSlotVisibility();
        }
    }

    private void UpdateSlotDisplay()
    {
        if (assignedSlot.HasItem())
        {
            itemIcon.sprite = assignedSlot.Item.data.icon;
            itemIcon.color = Color.white;
            stackCountText.text = assignedSlot.Item.stackSize > 1 ? assignedSlot.Item.stackSize.ToString() : "";
        }
        else
        {
            itemIcon.sprite = null;
            itemIcon.color = Color.clear;
            stackCountText.text = "";
        }
    }

    private void UpdateActiveSlotVisibility()
    {
        if (isActiveItemSlot)
        {
            gameObject.SetActive(assignedSlot.HasItem());
        }
    }

    public void OnPointerClick(PointerEventData eventData)
    {
        if (eventData.button == PointerEventData.InputButton.Left)
        {
            float timeSinceLastClick = Time.time - lastClickTime;

            if (timeSinceLastClick <= doubleClickThreshold)
            {
                if (!isActiveItemSlot && assignedSlot.HasItem())
                {
                    InventoryManager.Instance.MoveToActiveSlot(SlotIndex);
                }
                else if (isActiveItemSlot && assignedSlot.HasItem())
                {
                    InventoryManager.Instance.MoveToInventoryFromActive();
                }
            }

            lastClickTime = Time.time;
        }
    }

    public void OnBeginDrag(PointerEventData eventData)
    {
        if (!assignedSlot.HasItem() || isActiveItemSlot) return;

        dragObject = new GameObject("DragIcon");
        dragObject.transform.SetParent(transform.root, false);
        dragObject.transform.SetAsLastSibling();

        Image dragImage = dragObject.AddComponent<Image>();
        dragImage.sprite = itemIcon.sprite;
        dragImage.raycastTarget = false;

        CanvasGroup canvasGroup = dragObject.AddComponent<CanvasGroup>();
        canvasGroup.alpha = 0.7f;
        canvasGroup.blocksRaycasts = false;

        itemIcon.color = new Color(1, 1, 1, 0.3f);
    }

    public void OnDrag(PointerEventData eventData)
    {
        if (dragObject != null)
        {
            dragObject.transform.position = eventData.position;
        }
    }

    public void OnEndDrag(PointerEventData eventData)
    {
        if (dragObject != null)
        {
            Destroy(dragObject);
            dragObject = null;
        }

        if (assignedSlot.HasItem())
        {
            itemIcon.color = Color.white;
        }
    }

    public void OnDrop(PointerEventData eventData)
    {
        GameObject droppedObject = eventData.pointerDrag;
        if (droppedObject == null) return;

        InventorySlotUI fromSlotUI = droppedObject.GetComponent<InventorySlotUI>();
        if (fromSlotUI == null || fromSlotUI.isActiveItemSlot) return;

        int fromIndex = fromSlotUI.SlotIndex;
        int toIndex = SlotIndex;

        if (fromIndex != toIndex)
        {
            InventoryManager.Instance.TryCraftItems(fromIndex, toIndex);
        }
    }
}

--- Путь к файлу: .\Scripts\Inventory\ItemData.cs ---

using UnityEngine;

public enum ItemType
{
    Default,
    Consumable,
    Weapon,
    QuestItem
}

[CreateAssetMenu(fileName = "New Item", menuName = "Inventory/Item Data")]
public class ItemData : ScriptableObject
{
    [Header("Basic Info")]
    public string itemID;
    public string itemName;
    [TextArea] public string description;
    public Sprite icon;

    [Header("Settings")]
    public ItemType type;
    public bool isStackable = false;
    public int maxStackSize = 1;

    [Header("Crafting")]
    public CraftingRecipe[] craftingRecipes;
}

[System.Serializable]
public struct CraftingRecipe
{
    public ItemData item1;
    public ItemData item2;
}

--- Путь к файлу: .\Scripts\Inventory\ItemDBSO.cs ---

using UnityEngine;

[CreateAssetMenu(fileName = "Item Database", menuName = "Inventory/Item Database")]
public class ItemDBSO : ScriptableObject
{
    public ItemData[] allItems;

    public ItemData GetItemByID(string id)
    {
        if (allItems == null)
        {
            return null;
        }

        if (string.IsNullOrEmpty(id))
        {
            return null;
        }

        foreach (ItemData item in allItems)
        {
            if (item == null)
            {
                continue;
            }

            if (item.itemID == id)
            {
                return item;
            }
        }

        return null;
    }
}

--- Путь к файлу: .\Scripts\Inventory\ItemPickup.cs ---

using UnityEngine;

public class ItemPickup : MonoBehaviour
{
    [Header("Item Settings")]
    public ItemData itemData;
    public int amount = 1;

    [Header("Interaction Settings")]
    public KeyCode interactKey = KeyCode.E;

    private bool playerInRange = false;

    void Start()
    {
        if (itemData != null && itemData.icon != null)
        {
            SpriteRenderer spriteRenderer = GetComponent<SpriteRenderer>();
            if (spriteRenderer != null)
            {
                spriteRenderer.sprite = itemData.icon;
            }
        }
    }

    void Update()
    {
        if (playerInRange && Input.GetKeyDown(interactKey))
        {
            TryPickupItem();
        }
    }

    void OnTriggerEnter2D(Collider2D other)
    {
        if (other.CompareTag("Player"))
        {
            playerInRange = true;
        }
        UIInteractPrompt.Instance.Show(" E,  ");
    }

    void OnTriggerExit2D(Collider2D other)
    {
        if (other.CompareTag("Player"))
        {
            playerInRange = false;
            Debug.Log("   ");
        }
        UIInteractPrompt.Instance.Hide();
    }

    void TryPickupItem()
    {
        if (itemData == null)
        {
            return;
        }

        if (InventoryManager.Instance.AddItem(itemData.itemID, amount))
        {
            Destroy(gameObject);
        }
    }
}

--- Путь к файлу: .\Scripts\PlatesMiniGame\FalsePlate.cs ---

using UnityEngine;

public class FalsePlate : MonoBehaviour
{
    [Header("False Plate Settings")]
    public Transform resetPosition;
    public bool usePuzzleStartPosition = true;

    private Transform puzzleStartPosition;

    public void Initialize(Transform puzzleStartPos)
    {
        puzzleStartPosition = puzzleStartPos;
    }

    private void OnTriggerEnter2D(Collider2D other)
    {
        if (other.CompareTag("Player"))
        {
            Debug.Log("Player stepped on false plate!");
            ResetPlayer(other.gameObject);
        }
    }

    private void ResetPlayer(GameObject player)
    {
        Transform targetPosition = usePuzzleStartPosition ? puzzleStartPosition : resetPosition;

        if (targetPosition != null)
        {
            player.transform.position = targetPosition.position;
            Debug.Log($"Player reset to position: {targetPosition.name}");
        }

        PressurePlatePuzzle puzzle = FindObjectOfType<PressurePlatePuzzle>();
        if (puzzle != null)
        {
            puzzle.ResetPuzzle();
        }
    }
}

--- Путь к файлу: .\Scripts\PlatesMiniGame\PressurePlate.cs ---

using System.Collections;
using UnityEngine;

public class PressurePlate : MonoBehaviour
{
    [Header("Plate Settings")]
    public int plateIndex;
    public bool isCorrectPlate = true;

    [Header("Animations")]
    public AnimationClip activationAnimation;
    public AnimationClip rightStepAnimation;
    public AnimationClip wrongStepAnimation;

    private PressurePlatePuzzle puzzleController;
    private Animator animator;

    public static PressurePlate Instance;

    void Awake()
    {
        Instance = this;
    }

    public void Initialize(PressurePlatePuzzle controller)
    {
        puzzleController = controller;
        animator = GetComponent<Animator>();

        if (animator != null)
        {
            animator.enabled = false;
        }
    }

    public void PlayActivationAnimation()
    {
        if (animator != null && activationAnimation != null)
        {
            animator.enabled = true;
            animator.Play(activationAnimation.name);
        }
    }

    public void PlayRightStepAnimation()
    {
        if (animator != null && rightStepAnimation != null)
        {
            animator.enabled = true;
            animator.Play(rightStepAnimation.name);
        }
    }

    public void PlayWrongStepAnimation()
    {
        if (animator != null && wrongStepAnimation != null)
        {
            animator.enabled = true;
            animator.Play(wrongStepAnimation.name);
        }
    }

    private void OnTriggerEnter2D(Collider2D other)
    {
        if (other.CompareTag("Player"))
        {
            if (puzzleController != null)
            {
                puzzleController.OnPlateStepped(plateIndex, isCorrectPlate);
            }
        }
    }
}

--- Путь к файлу: .\Scripts\PlatesMiniGame\PressurePlatePuzzle.cs ---

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PressurePlatePuzzle : MonoBehaviour
{
    [Header("Puzzle Settings")]
    public List<PressurePlate> puzzlePlates = new List<PressurePlate>();
    public float sequenceDelay = 1f;
    public Transform playerStartPosition;

    [Header("Trigger Zone")]
    public GameObject triggerZone;

    [Header("False Plates Settings")]
    public GameObject falsePlatesParent;
    public List<FalsePlate> falsePlates = new List<FalsePlate>();

    [Header("Camera Settings")]
    public Transform puzzleCameraPosition; //   
    public float cameraMoveSpeed = 5f;

    private Camera mainCamera;
    private MonoBehaviour cameraFollowScript;
    private Vector3 cameraStartPosition;
    private bool isCameraMovingToPuzzle = false;
    private bool isCameraMovingBack = false;

    private bool isSequencePlaying = false;
    private bool isPuzzleActive = false;
    private int currentStep = 0;
    private PlayerMovement playerMovement;
    private Transform playerTransform;
    private Coroutine cameraReturnCoroutine;

    public static PressurePlatePuzzle Instance;

    void Awake()
    {
        Instance = this;
    }

    void Start()
    {
        playerMovement = FindObjectOfType<PlayerMovement>();

        GameObject player = GameObject.FindGameObjectWithTag("Player");
        if (player != null)
        {
            playerTransform = player.transform;
        }

        //  
        mainCamera = Camera.main;
        if (mainCamera != null)
        {
            cameraFollowScript = mainCamera.GetComponent<MonoBehaviour>();
        }

        foreach (PressurePlate plate in puzzlePlates)
        {
            plate.Initialize(this);
        }

        if (falsePlatesParent != null && falsePlates.Count == 0)
        {
            FindFalsePlatesAutomatically();
        }

        foreach (FalsePlate falsePlate in falsePlates)
        {
            falsePlate.Initialize(playerStartPosition);
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.E) && IsPlayerInTriggerZone() && !isSequencePlaying && !isPuzzleActive)
        {
            StartPuzzleSequence();
        }

        //    
        if (isCameraMovingToPuzzle && puzzleCameraPosition != null)
        {
            MoveCameraToPuzzle();
        }

        //   
        if (isCameraMovingBack && playerTransform != null)
        {
            MoveCameraBackToPlayer();
        }
    }

    void MoveCameraToPuzzle()
    {
        Vector3 targetPos = puzzleCameraPosition.position;
        mainCamera.transform.position = Vector3.MoveTowards(
            mainCamera.transform.position,
            targetPos,
            cameraMoveSpeed * Time.deltaTime
        );

        //    
        if (Vector3.Distance(mainCamera.transform.position, targetPos) < 0.01f)
        {
            mainCamera.transform.position = targetPos;
            isCameraMovingToPuzzle = false;

            //    -   
            StartCoroutine(PlayPlateSequence());
        }
    }

    void MoveCameraBackToPlayer()
    {
        if (playerTransform == null) return;

        //   -   
        Vector3 targetPos = new Vector3(
            playerTransform.position.x,
            playerTransform.position.y,
            mainCamera.transform.position.z
        );

        mainCamera.transform.position = Vector3.MoveTowards(
            mainCamera.transform.position,
            targetPos,
            cameraMoveSpeed * Time.deltaTime
        );

        //      
        if (Vector3.Distance(mainCamera.transform.position, targetPos) < 0.01f)
        {
            isCameraMovingBack = false;

            //    
            if (cameraFollowScript != null)
            {
                cameraFollowScript.enabled = true;
            }
        }
    }

    private bool IsPlayerInTriggerZone()
    {
        if (triggerZone == null || playerTransform == null) return false;

        Collider2D triggerCollider = triggerZone.GetComponent<Collider2D>();
        if (triggerCollider != null)
        {
            return triggerCollider.OverlapPoint(playerTransform.position);
        }
        return false;
    }

    private void FindFalsePlatesAutomatically()
    {
        FalsePlate[] foundPlates = falsePlatesParent.GetComponentsInChildren<FalsePlate>();
        falsePlates.AddRange(foundPlates);
    }

    private void StartPuzzleSequence()
    {
        isSequencePlaying = true;
        isPuzzleActive = true;
        currentStep = 0;

        //    
        cameraStartPosition = mainCamera.transform.position;

        //    
        if (cameraFollowScript != null)
        {
            cameraFollowScript.enabled = false;
        }

        //     
        isCameraMovingToPuzzle = true;
        isCameraMovingBack = false;

        //   
        if (playerMovement != null)
        {
            playerMovement.enabled = false;
        }
    }

    private IEnumerator PlayPlateSequence()
    {
        //     
        yield return new WaitForSeconds(0.5f);

        for (int i = 0; i < puzzlePlates.Count; i++)
        {
            float delayForThisPlate = sequenceDelay * i;
            StartCoroutine(PlayPlateAnimationWithDelay(i, delayForThisPlate));
        }

        //     
        float totalSequenceTime = sequenceDelay * puzzlePlates.Count;
        yield return new WaitForSeconds(totalSequenceTime + 0.5f);

        //   
        StartCameraReturn();

        if (playerMovement != null)
        {
            playerMovement.enabled = true;
        }
        isSequencePlaying = false;
    }

    private IEnumerator PlayPlateAnimationWithDelay(int plateIndex, float delay)
    {
        yield return new WaitForSeconds(delay);
        puzzlePlates[plateIndex].PlayActivationAnimation();
    }

    public void OnPlateStepped(int plateIndex, bool isCorrectStep)
    {
        if (!isPuzzleActive)
        {
            ReturnPlayerToStart();
            PlayAllWrongStepAnimations();
            ResetPuzzle();
            return;
        }

        if (isSequencePlaying)
        {
            return;
        }

        if (isCorrectStep)
        {
            if (plateIndex == currentStep)
            {
                puzzlePlates[plateIndex].PlayRightStepAnimation();
                currentStep++;

                if (currentStep >= puzzlePlates.Count)
                {
                    PuzzleCompleted();
                }
            }
            else
            {
                ReturnPlayerToStart();
                PlayAllWrongStepAnimations();
                ResetPuzzle();
            }
        }
        else
        {
            ReturnPlayerToStart();
            PlayAllWrongStepAnimations();
            ResetPuzzle();
        }
    }

    private void ReturnPlayerToStart()
    {
        if (playerTransform != null && playerStartPosition != null)
        {
            playerTransform.position = playerStartPosition.position;
        }
    }

    private void PuzzleCompleted()
    {
        isPuzzleActive = false;
        //  1      
        Invoke("StartCameraReturn", 1f);
    }

    private void StartCameraReturn()
    {
        isCameraMovingBack = true;
        isCameraMovingToPuzzle = false;
    }

    private void PlayAllWrongStepAnimations()
    {
        foreach (PressurePlate plate in puzzlePlates)
        {
            plate.PlayWrongStepAnimation();
        }
    }

    public void ResetPuzzle()
    {
        PlayAllWrongStepAnimations();
        StopAllCoroutines();

        //     
        StartCameraReturn();

        //  
        if (playerMovement != null)
        {
            playerMovement.enabled = true;
        }

        isSequencePlaying = false;
        isPuzzleActive = false;
        currentStep = 0;
    }

    public bool IsPuzzleActive()
    {
        return isPuzzleActive;
    }

    public bool IsSequencePlaying()
    {
        return isSequencePlaying;
    }
}

--- Путь к файлу: .\Scripts\PlatesMiniGame\PuzzleActivationZone.cs ---

using UnityEngine;

public class PuzzleActivationZone : MonoBehaviour
{
    [Header("UI Prompt")]
    public GameObject pressEPrompt;

    

    private void OnTriggerEnter2D(Collider2D other)
    {
        if (other.CompareTag("Player") && pressEPrompt != null)
        {
            pressEPrompt.SetActive(true);
        }

        
    }

    private void OnTriggerExit2D(Collider2D other)
    {
        if (other.CompareTag("Player") && pressEPrompt != null)
        {
            pressEPrompt.SetActive(false);
        }
    }
}

--- Путь к файлу: .\Scripts\Quests\ActivateObject.cs ---

﻿using UnityEngine;

public class ActivateObject : MonoBehaviour
{
    public GameObject objectToActivate;

    void OnTriggerEnter2D(Collider2D other)
    {
        if (other.CompareTag("Player"))
        {
            objectToActivate.SetActive(true);
        }
    }
}


--- Путь к файлу: .\Scripts\Quests\AnimationManager.cs ---

﻿using UnityEngine;
using System.Collections;

public class AnimationManager : MonoBehaviour
{
	public static AnimationManager Instance;

	void Awake()
	{
		Instance = this;
	}

	public void PlayAnimation(string animationName)
	{
		GameObject obj = GameObject.Find(animationName);
		if (obj != null)
		{
			Animator animator = obj.GetComponent<Animator>();
			if (animator != null)
			{
				animator.enabled = true;
				animator.Play(animationName);
			}
		}
	}

	public void PlayMultipleAnimations(string[] animationNames)
	{
		StartCoroutine(PlayAnimationsSequentially(animationNames));
	}

	private IEnumerator PlayAnimationsSequentially(string[] animationNames)
	{
		foreach (string animationName in animationNames)
		{
			PlayAnimation(animationName);
			yield return new WaitForSeconds(0.1f);
		}
	}
}

--- Путь к файлу: .\Scripts\Quests\TriggerManager.cs ---

﻿using UnityEngine;

public class TriggerManager : MonoBehaviour
{
	public static TriggerManager Instance;

	void Awake()
	{
		Instance = this;
	}

	public void ActivateTrigger(string triggerName)
	{
		GameObject trigger = GameObject.Find(triggerName);
		if (trigger != null)
		{
			Collider2D collider = trigger.GetComponent<Collider2D>();
			if (collider != null) 
			{
				collider.enabled = true;
			}
		}
	}

	public void DeactivateObject(string objectName)
	{
		GameObject obj = GameObject.Find(objectName);
		if (obj != null)
		{
			obj.SetActive(false);
		}
	}
}

--- Путь к файлу: .\Scripts\SudokuMiniGame\DraggableNumber.cs ---

﻿using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class DraggableNumber : MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler
{
	public int numberValue;
	private CanvasGroup canvasGroup;
	private Vector3 startPosition;

	void Start()
	{
		canvasGroup = GetComponent<CanvasGroup>();
		if (canvasGroup == null)
			canvasGroup = gameObject.AddComponent<CanvasGroup>();
        
		numberValue = int.Parse(GetComponentInChildren<Text>().text);
	}

	public void OnBeginDrag(PointerEventData eventData)
	{
		canvasGroup.alpha = 0.6f;
		canvasGroup.blocksRaycasts = false;
		startPosition = transform.position;
	}

	public void OnDrag(PointerEventData eventData)
	{
		transform.position = eventData.position;
	}

	public void OnEndDrag(PointerEventData eventData)
	{
		canvasGroup.alpha = 1f;
		canvasGroup.blocksRaycasts = true;
		transform.position = startPosition;
	}
}

--- Путь к файлу: .\Scripts\SudokuMiniGame\GameManager.cs ---

﻿using UnityEngine;
using UnityEngine.UI;
using System.Collections;

public class GameManager : MonoBehaviour
{
    [Header("Settings")]
    public int gridSize = 3;
    public int targetSum = 15;

    [Header("Initial Values")]
    public string initialGrid = "000000000";

    [Header("Prefabs")]
    public GameObject cellPrefab;
    public GameObject numberPrefab;

    [Header("UI")]
    public Transform gridParent;
    public Transform numbersPanel;
    public Text targetText;
    public Image statusIndicator;
    public Button resetButton;
    public GameObject gamePanel;

    public AnimationClip treeAnimation;
    public GameObject treeObject;

    private Animator treeAnimator;

    private TableCell[,] gridCells;
    private MonoBehaviour playerController;

    public static GameManager Instance;

    void Awake()
    {
        Instance = this;
        
        gamePanel.SetActive(false);
        playerController = FindObjectOfType<PlayerMovement>();

        if (treeObject != null)
        {
            treeAnimator = treeObject.GetComponent<Animator>();

            if (treeAnimator != null)
            {
                treeAnimator.enabled = false;
            }
        }


    }
    public void StartMiniGame()
    {
        if(playerController != null)
        {
            playerController.enabled = false;
        }

        // Настраиваем кнопку сброса
        if (resetButton != null)
        {
            resetButton.onClick.AddListener(ResetGrid);
        }

        gamePanel.SetActive(true);
        CreateGrid();
        CreateNumbers();
        SetupInitialValues();
        targetText.text = $"object.targetposition = {targetSum}";
    }

    void CreateGrid()
    {
        foreach (Transform child in gridParent)
            Destroy(child.gameObject);

        GridLayoutGroup gridLayout = gridParent.GetComponent<GridLayoutGroup>();
        if (gridLayout == null)
            gridLayout = gridParent.gameObject.AddComponent<GridLayoutGroup>();

        gridLayout.cellSize = new Vector2(80, 80);
        gridLayout.spacing = new Vector2(5, 5);
        gridLayout.constraint = GridLayoutGroup.Constraint.FixedColumnCount;
        gridLayout.constraintCount = gridSize;

        gridCells = new TableCell[gridSize, gridSize];

        for (int i = 0; i < gridSize * gridSize; i++)
        {
            GameObject cell = Instantiate(cellPrefab, gridParent);
            TableCell tableCell = cell.GetComponent<TableCell>();

            int row = i / gridSize;
            int col = i % gridSize;
            gridCells[row, col] = tableCell;
        }
    }

    void CreateNumbers()
    {
        foreach (Transform child in numbersPanel)
            Destroy(child.gameObject);

        for (int i = 1; i <= 9; i++)
        {
            GameObject number = Instantiate(numberPrefab, numbersPanel);
            number.GetComponentInChildren<Text>().text = i.ToString();
        }
    }

    void SetupInitialValues()
    {
        for (int i = 0; i < gridSize * gridSize && i < initialGrid.Length; i++)
        {
            int row = i / gridSize;
            int col = i % gridSize;
            int value = int.Parse(initialGrid[i].ToString());

            if (gridCells[row, col] != null)
            {
                if (value > 0)
                {
                    gridCells[row, col].GetComponentInChildren<Text>().text = value.ToString();
                    gridCells[row, col].currentValue = value;
                    gridCells[row, col].isLocked = true;
                }
                else
                {
                    gridCells[row, col].GetComponentInChildren<Text>().text = "";
                    gridCells[row, col].currentValue = 0;
                    gridCells[row, col].isLocked = false;
                }
            }
        }
        statusIndicator.color = Color.red;
    }

    public void ResetGrid()
    {
        SetupInitialValues();
        Debug.Log("Таблица сброшена к начальным значениям!");
    }

    public void CheckSolution()
    {
        bool isSolved = true;

        for (int row = 0; row < gridSize; row++)
        {
            int rowSum = 0;
            for (int col = 0; col < gridSize; col++)
            {
                if (gridCells[row, col] != null)
                {
                    rowSum += gridCells[row, col].currentValue;
                }
            }
            if (rowSum != targetSum)
            {
                isSolved = false;
                break;
            }
        }

        if (isSolved)
        {
            for (int col = 0; col < gridSize; col++)
            {
                int colSum = 0;
                for (int row = 0; row < gridSize; row++)
                {
                    if (gridCells[row, col] != null)
                    {
                        colSum += gridCells[row, col].currentValue;
                    }
                }
                if (colSum != targetSum)
                {
                    isSolved = false;
                    break;
                }
            }
        }

        if (isSolved)
        {
            statusIndicator.color = Color.green;
            Invoke("EndMiniGame", 1.5f);
        }
        else
        {
            statusIndicator.color = Color.red;
        }
    }

    void EndMiniGame()
    {
        if (playerController != null)
        {
            playerController.enabled = true;
        }

        gamePanel.SetActive(false);

        if (treeAnimator != null && treeAnimation != null)
        {
            treeAnimator.enabled = true;
            treeAnimator.Play(treeAnimation.name);
        }
    }

}

--- Путь к файлу: .\Scripts\SudokuMiniGame\SudokuMiniGameTrigger.cs ---

using UnityEngine;

public class SudokuMiniGameTrigger : MonoBehaviour
{
    [Header("  ")]
    public bool workOnlyOnce = false;
    public bool startOnEnter = true;
    public bool requirePressE = false;

    bool inRange = false;
    bool alreadyUsed = false;

    void OnTriggerEnter2D(Collider2D other)
    {
        if (alreadyUsed && workOnlyOnce) return;
        if (other.CompareTag("Player"))
        {
            inRange = true;
            if (startOnEnter && !requirePressE) StartGame();
            else if (requirePressE) UIInteractPrompt.Instance.Show(" E");

        }
    }

    void OnTriggerExit2D(Collider2D other)
    {
        if (other.CompareTag("Player"))
        {
            inRange = false;
            UIInteractPrompt.Instance.Hide();
        }
    }

    void Update()
    {
        if(inRange && requirePressE && Input.GetKeyDown(KeyCode.E))
        {
            UIInteractPrompt.Instance.Hide();
            StartGame();
        }
    }

    void StartGame()
    {
        if (workOnlyOnce)
        {
            alreadyUsed = true;
            inRange = false;
        }

        GameManager.Instance.StartMiniGame();
    }
}


--- Путь к файлу: .\Scripts\SudokuMiniGame\TableCell.cs ---

﻿using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;

public class TableCell : MonoBehaviour, IDropHandler
{
    private Text numberText;
    public int currentValue;
    public bool isLocked = false; // Добавили флаг блокировки

    void Start()
    {
        numberText = GetComponentInChildren<Text>();
    }

    public void OnDrop(PointerEventData eventData)
    {
        // Если ячейка заблокирована - ничего не делаем
        if (isLocked) return;

        GameObject draggedNumber = eventData.pointerDrag;
        if (draggedNumber == null) return;

        DraggableNumber draggable = draggedNumber.GetComponent<DraggableNumber>();
        if (draggable != null)
        {
            numberText.text = draggable.numberValue.ToString();
            currentValue = draggable.numberValue;
            FindObjectOfType<GameManager>().CheckSolution();
        }
    }
}

--- Путь к файлу: .\Scripts\UI\CutSceneTrigger.cs ---

using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Video;

public class CutSceneTrigger : MonoBehaviour
{
    public Canvas canvas;
    public VideoPlayer videoPlayer;

    private MonoBehaviour playerController;
    private bool used = false;

    private void Start()
    {
        playerController = FindObjectOfType<PlayerMovement>();
    }

    private void OnTriggerEnter2D(Collider2D other)
    {
        if (used) return;
        if (!other.CompareTag("Player")) return;

        used = true;
        canvas.gameObject.SetActive(true);

        if (playerController != null)
            playerController.enabled = false;

        videoPlayer.Play();
        videoPlayer.loopPointReached += OnVideoFinished;
    }

    private void OnVideoFinished(VideoPlayer vp)
    {
        canvas.enabled = false;

        if (playerController != null)
            playerController.enabled = true;
    }
}



--- Путь к файлу: .\Scripts\UI\MenuManager.cs ---

using UnityEngine;
using UnityEngine.UI;
using UnityEngine.SceneManagement;

public class MenuManager : MonoBehaviour
{
    [Header(" ")]
    public GameObject mainMenuPanel;
    public Button continueButton;
    public Button newGameButton;
    public Button settingsButton;
    public Button exitButton;

    [Header(" ")]
    public GameObject settingsPanel;
    public Button backButton;

    [Header("")]
    public string gameSceneName = "GameScene";

    void Start()
    {
        mainMenuPanel.SetActive(true);
        settingsPanel.SetActive(false);

        continueButton.onClick.AddListener(OnContinueButton);
        newGameButton.onClick.AddListener(OnNewGameButton);
        settingsButton.onClick.AddListener(OnSettingsButton);
        exitButton.onClick.AddListener(OnExitButton);

        backButton.onClick.AddListener(OnBackButton);

        UpdateContinueButton();
    }

    void UpdateContinueButton()
    {
        bool hasSave = SaveSystem.HasSaveData();
        continueButton.gameObject.SetActive(hasSave);
    }

    public void OnContinueButton()
    {
        if (SaveSystem.HasSaveData())
        {
            SceneManager.LoadScene(gameSceneName);
        }
        else
        {
            UpdateContinueButton();
        }
    }

    public void OnNewGameButton()
    {
        SaveSystem.DeleteSave();
        SceneManager.LoadScene(gameSceneName);
    }

    public void OnSettingsButton()
    {
        mainMenuPanel.SetActive(false);
        settingsPanel.SetActive(true);
    }

    public void OnBackButton()
    {
        mainMenuPanel.SetActive(true);
        settingsPanel.SetActive(false);
    }

    public void OnExitButton()
    {

        #if UNITY_EDITOR
        UnityEditor.EditorApplication.isPlaying = false;
        #else

        Application.Quit();
        #endif
    }
}

--- Путь к файлу: .\Scripts\UI\PanelController.cs ---

using UnityEngine;
using UnityEngine.SceneManagement;
public class PanelController : MonoBehaviour
{
    [Header("")]
    public GameObject panel;
    public string sceneName;

    [Header(" ")]
    public bool workOnlyOnce = false;
    private string playerTag = "Player";

    [Header(" ")]
    public bool disablePlayerControl = true;

    public bool goToMenu = false;

    private PlayerMovement playerController;
    private bool alreadyTriggered = false;

    void Start()
    {
        playerController = FindObjectOfType<PlayerMovement>();

        if (panel != null)
            panel.SetActive(false);
    }

    private void OnTriggerEnter2D(Collider2D other)
    {
        if (other.CompareTag(playerTag) && (!workOnlyOnce || !alreadyTriggered))
        {
            if (panel != null)
                panel.SetActive(true);

            if (disablePlayerControl && playerController != null)
                playerController.enabled = false;

            if (goToMenu)
            {
                Invoke("LoadMenu", 5f);
            }

            alreadyTriggered = true;
        }
    }

    public void LoadMenu()
    {
        SceneManager.LoadScene(sceneName);
    }

    public void HidePanel()
    {
        if (panel != null)
            panel.SetActive(false);

        if (disablePlayerControl && playerController != null)
            playerController.enabled = true;
    }

    public void ResetTrigger()
    {
        alreadyTriggered = false;
    }
}

--- Путь к файлу: .\Scripts\UI\PauseManager.cs ---

using UnityEngine;
using UnityEngine.UI;

public class PauseManager : MonoBehaviour
{
    [Header("")]
    public GameObject pausePanel;
    public GameObject settingsPanel;

    [Header(" ")]
    public Button settingsButton;
    public Button continueButton;
    public Button menuButton;

    [Header("   ")]
    public Button backButton;

    private bool isPaused = false;

    void Start()
    {
        pausePanel.SetActive(false);
        settingsPanel.SetActive(false);

        settingsButton.onClick.AddListener(OpenSettings);
        continueButton.onClick.AddListener(ContinueGame);
        menuButton.onClick.AddListener(GoToMainMenu);
        backButton.onClick.AddListener(CloseSettings);
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            if (isPaused)
            {
                if (settingsPanel.activeSelf)
                {
                    CloseSettings();
                }
                else
                {
                    ContinueGame();
                }
            }
            else
            {
                PauseGame();
            }
        }
    }

    void PauseGame()
    {
        isPaused = true;
        Time.timeScale = 0f;

        pausePanel.SetActive(true);
        settingsPanel.SetActive(false);

        Debug.Log("  ");
    }

    void ContinueGame()
    {
        isPaused = false;
        Time.timeScale = 1f;

        pausePanel.SetActive(false);
        settingsPanel.SetActive(false);

        Debug.Log(" ");
    }

    void OpenSettings()
    {
        pausePanel.SetActive(false);
        settingsPanel.SetActive(true);
    }

    void CloseSettings()
    {
        settingsPanel.SetActive(false);
        pausePanel.SetActive(true);
    }

    void GoToMainMenu()
    {
        Time.timeScale = 1f;
        UnityEngine.SceneManagement.SceneManager.LoadScene("MainMenu");
    }
}

--- Путь к файлу: .\Scripts\UI\SettingsManager.cs ---

using UnityEngine;
using UnityEngine.UI;

public class SettingsManager : MonoBehaviour
{
    [Header(" ")]
    public Slider volumeSlider;

    [Header("UI")]
    public GameObject settingsPanel;
    public Button backButton;

    private Dropdown screenModeDropdown;

    void Start()
    {
        screenModeDropdown = settingsPanel.GetComponentInChildren<Dropdown>();

        if (volumeSlider != null)
        {
            volumeSlider.value = PlayerPrefs.GetFloat("MasterVolume", 1f);
            volumeSlider.onValueChanged.AddListener(SetMasterVolume);
        }

        if (screenModeDropdown != null)
        {
            screenModeDropdown.value = Screen.fullScreen ? 0 : 1;
            screenModeDropdown.onValueChanged.AddListener(SetFullscreen);
        }

        if (backButton != null)
            backButton.onClick.AddListener(CloseSettings);
    }

    public void SetMasterVolume(float volume)
    {
        AudioListener.volume = volume;
        PlayerPrefs.SetFloat("MasterVolume", volume);
    }

    public void SetFullscreen(int isFullscreen)
    {
        bool fullscreen = (isFullscreen == 0);
        Screen.fullScreen = fullscreen;
    }

    public void CloseSettings()
    {
        PlayerPrefs.Save();
        if (settingsPanel != null)
            settingsPanel.SetActive(false);
    }

    public void OpenSettings()
    {
        if (settingsPanel != null)
            settingsPanel.SetActive(true);
    }
}

