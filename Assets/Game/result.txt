--- Путь к файлу: .\CameraController.cs ---

using UnityEngine;

public class CameraController : MonoBehaviour
{
    public static CameraController Instance;

    [Header("Target")]
    public Transform target;

    [Tooltip("    .  ,   .")]
    public float smoothTime = 0.25f;

    [Header("State")]
    public bool isLocked = false;

    //    
    private Vector3 offset;
    //    SmoothDamp (   )
    private Vector3 currentVelocity = Vector3.zero;

    void Awake()
    {
        Instance = this;
    }

    void Start()
    {
        //   
        if (target != null)
        {
            offset = transform.position - target.position;
        }
    }

    void LateUpdate()
    {
        if (isLocked || target == null) return;

        Vector3 targetPosition;

        if (target.CompareTag("Player"))
        {
            //      (offset)
            targetPosition = target.position + offset;
        }
        else
        {
            //  NPC       ,  Z 
            targetPosition = new Vector3(target.position.x, target.position.y, transform.position.z);
        }

        //    SmoothDamp
        // currentVelocity   
        transform.position = Vector3.SmoothDamp(
            transform.position,
            targetPosition,
            ref currentVelocity,
            smoothTime
        );
    }

    public void SetTarget(string targetName)
    {
        //     ,    " "   
        currentVelocity = Vector3.zero;

        if (targetName.ToLower() == "player")
        {
            GameObject player = GameObject.FindGameObjectWithTag("Player");
            if (player != null) target = player.transform;
        }
        else
        {
            GameObject obj = GameObject.Find(targetName);
            if (obj != null) target = obj.transform;
        }
    }
}

--- Путь к файлу: .\MenuCleanup.cs ---

using UnityEngine;

public class MenuCleanup : MonoBehaviour
{
    void Awake()
    {
        // 1.    ,     (  )
        GameObject player = GameObject.FindGameObjectWithTag("Player");
        if (player != null)
        {
            //      (, PersistentRoot),   
            Destroy(player.transform.root.gameObject);
        }

        // 2.   ,     
        if (InventoryManager.Instance != null)
            Destroy(InventoryManager.Instance.gameObject);

        if (DialogueManager.Instance != null)
            Destroy(DialogueManager.Instance.gameObject);

        if (QuestsManager.Instance != null)
            Destroy(QuestsManager.Instance.gameObject);

        // : GameSaveManager.Instance   ! 
        //   ,   .

        // 3.  
        Cursor.visible = true;
        Cursor.lockState = CursorLockMode.None;
        Time.timeScale = 1f;

        Debug.Log(" .     .   .");
    }
}

--- Путь к файлу: .\Scripts\DefaultSpawner.cs ---

using UnityEngine;

public class DefaultSpawner : MonoBehaviour
{
    [Header("     ")]
    public Transform startPoint;

    void Start()
    {
        // ,   . 
        //     ,   .
        if (!SaveSystem.HasSaveData())
        {
            GameObject player = GameObject.FindGameObjectWithTag("Player");

            //     (   ),  
            if (player == null && GameSaveManager.Instance.gameSystemsPrefab != null)
            {
                Instantiate(GameSaveManager.Instance.gameSystemsPrefab);
                player = GameObject.FindGameObjectWithTag("Player");
            }

            //    
            if (player != null && startPoint != null)
            {
                player.transform.position = startPoint.position;
                Debug.Log(" :     .");
            }
        }
    }
}

--- Путь к файлу: .\Scripts\GoToScene.cs ---

﻿using UnityEngine;
using UnityEngine.SceneManagement;

public class GoToScene : MonoBehaviour
{
    public string sceneName;
    public string spawnPointName;

    void OnTriggerEnter2D(Collider2D other)
    {
        if (other.CompareTag("Player"))
        {
            PlayerPrefs.SetString("NextSpawnPoint", spawnPointName);
            SceneManager.LoadScene(sceneName);
        }
    }
}

--- Путь к файлу: .\Scripts\PersistentRoot.cs ---

using UnityEngine;

public class PersistentRoot : MonoBehaviour
{
    private static PersistentRoot instance;

    void Awake()
    {
        if (instance != null)
        {
            Destroy(gameObject);
            return;
        }

        instance = this;
        DontDestroyOnLoad(gameObject);
    }
}

--- Путь к файлу: .\Scripts\SceneTransition.cs ---

﻿using UnityEngine;
using UnityEngine.SceneManagement;

public class SceneTransition : MonoBehaviour
{
    [Header("����� �����")]
    public int sceneNumber;
    public void Transition()
    {
        SceneManager.LoadScene(sceneNumber);
    }
}


--- Путь к файлу: .\Scripts\SilhouetteSync.cs ---

using UnityEngine;

public class SilhouetteSync : MonoBehaviour
{
    [Header("")]
    //   
    public SpriteRenderer mainRenderer;
    //   (    Visuals  Silhouette)
    public SpriteRenderer shadowRenderer;

    void LateUpdate()
    {
        if (mainRenderer == null || shadowRenderer == null) return;

        // 1.    ()
        //    ,      mainRenderer
        shadowRenderer.sprite = mainRenderer.sprite;

        // 2.   (Flip)
        shadowRenderer.flipX = mainRenderer.flipX;
        shadowRenderer.flipY = mainRenderer.flipY;

        // 3.   (,    /)
        // shadowRenderer.color = mainRenderer.color; 

        // 4.   ( ,      )
        // shadowRenderer.sortingOrder = mainRenderer.sortingOrder + 1;
    }
}

--- Путь к файлу: .\Scripts\SpawnManager.cs ---

using UnityEngine;

public class SpawnManager : MonoBehaviour
{
    void Start()
    {
        string targetPoint = PlayerPrefs.GetString("NextSpawnPoint");

        if (!string.IsNullOrEmpty(targetPoint))
        {
            GameObject spawnPoint = GameObject.Find(targetPoint);
            if (spawnPoint != null)
            {
                GameObject player = GameObject.FindGameObjectWithTag("Player");
                if (player != null)
                {
                    player.transform.position = spawnPoint.transform.position;
                }
            }
        }
    }
}

--- Путь к файлу: .\Scripts\Teleport.cs ---

﻿using UnityEngine;

public class Teleport : MonoBehaviour
{
	public Transform targetPosition;

	void OnTriggerEnter2D(Collider2D other)
	{
		if (other.CompareTag("Player"))
		{
			other.transform.position = targetPosition.position;
		}
	}
}


--- Путь к файлу: .\Scripts\Dialogues\AnimatorAutoDisable.cs ---

﻿using UnityEngine;

public class AnimationAutoDisable : MonoBehaviour
{
    private Animator animator;

    void Awake()
    {
        animator = GetComponent<Animator>();
    }

    public void OnAnimationFinished()
    {
        if (animator != null)
        {
            animator.enabled = false; 
        }
    }
}


--- Путь к файлу: .\Scripts\Dialogues\DialogueManager.cs ---

﻿using Ink.Runtime;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using TMPro;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class DialogueManager : MonoBehaviour
{
    public static DialogueManager Instance;

    [Header("UI")]
    public GameObject dialoguePanel;
    public TMP_Text dialogueText;

    [Header("Speaker UI")]
    public Image portraitLeft;
    public TMP_Text nameLeft;
    public Image portraitRight;
    public TMP_Text nameRight;

    [Header("Choices")]
    public Transform choicesContainer;
    public GameObject choiceButtonPrefab;

    [Header("Audio & Typing")]
    public AudioSource audioSource;
    public AudioClip defaultTypingSound;

    private Coroutine typingCoroutine;
    private bool isTyping = false;
    private string currentFullLine = "";

    private AudioClip currentVoiceSound;
    private float currentTypingSpeed = 0.04f;

    private Story story;
    private bool isPlaying = false;
    private bool isWaiting = false;
    private NPCData currentNPC;
    private MonoBehaviour playerController;

    private Dictionary<string, object> globalVariables = new Dictionary<string, object>();

    private int activeCutscenesCount = 0;

    public Dictionary<string, object> GetGlobalVariables() => globalVariables;

    private class ActionData
    {
        public string name;
        public List<string> paramsList = new List<string>();
    }

    void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
            return;
        }

        if (choicesContainer != null) choicesContainer.gameObject.SetActive(false);
        if (dialoguePanel != null) dialoguePanel.SetActive(false);

        playerController = FindObjectOfType<PlayerMovement>();
    }

    public void SetGlobalVariable(string key, string value)
    {
        if (globalVariables.ContainsKey(key)) globalVariables[key] = value;
        else globalVariables.Add(key, value);
    }

    void Update()
    {
        if (!isPlaying || isWaiting) return;

        if (Input.GetMouseButtonDown(0) || Input.GetKeyDown(KeyCode.Space) || Input.GetKeyDown(KeyCode.Return))
        {
            if (EventSystem.current.IsPointerOverGameObject()) return;
            ContinueDialogue();
        }
    }

    public void StartDialogue(TextAsset inkJSON, string startKnot = null, NPCData npcData = null)
    {
        if (isPlaying) return;

        if (playerController != null)
        {
            playerController.enabled = false;
            Rigidbody2D rb = playerController.GetComponent<Rigidbody2D>();
            if (rb != null)
            {
                rb.linearVelocity = Vector2.zero;
                rb.angularVelocity = 0f;
            }
            Animator anim = playerController.GetComponentInChildren<Animator>();
            if (anim != null)
            {
                anim.SetFloat("Speed", 0f);
                anim.Play("Idle");
                anim.Update(0f);
            }
        }

        story = new Story(inkJSON.text);
        currentNPC = npcData;

        RestoreGlobalVariables();
        UpdatePlayerStateVariables();

        if (!string.IsNullOrEmpty(startKnot)) story.ChoosePathString(startKnot);
        if (npcData != null) SetDefaultSpeaker(npcData);

        dialoguePanel.SetActive(true);
        isPlaying = true;

        ContinueDialogue();
    }

    public void ContinueDialogue()
    {
        if (isWaiting) return;

        if (isTyping)
        {
            StopCoroutine(typingCoroutine);
            dialogueText.maxVisibleCharacters = currentFullLine.Length;
            isTyping = false;
            return;
        }

        foreach (Transform child in choicesContainer) Destroy(child.gameObject);

        if (story.canContinue)
        {
            string text = story.Continue();
            currentFullLine = text.Trim();
            StartCoroutine(ProcessTagsRoutine());
        }
        else if (story.currentChoices.Count > 0)
        {
            ShowChoices();
        }
        else
        {
            EndDialogue();
        }
    }

    private IEnumerator ProcessTagsRoutine()
    {
        List<string> currentTags = story.currentTags;
        List<ActionData> actionsToExecute = new List<ActionData>();
        ActionData currentAction = null;

        foreach (string tag in currentTags)
        {
            string cleanTag = tag.Trim();
            if (cleanTag.StartsWith("action:"))
            {
                currentAction = new ActionData();
                currentAction.name = cleanTag.Substring(7).Trim();
                actionsToExecute.Add(currentAction);
            }
            else if (cleanTag == "delay" || cleanTag.StartsWith("delay:"))
            {
                currentAction = new ActionData { name = "delay" };
                if (cleanTag.Contains(":")) currentAction.paramsList.Add(cleanTag);
                actionsToExecute.Add(currentAction);
            }
            else if (currentAction != null && cleanTag.Contains(":"))
            {
                currentAction.paramsList.Add(cleanTag);
            }
            else if (cleanTag.StartsWith("set_"))
            {
                ProcessSetTag(cleanTag);
            }
        }

        foreach (var act in actionsToExecute)
        {
            ExecuteAction(act.name, act.paramsList);

            // Если действие включило режим ожидания (например, delay)
            while (isWaiting)
            {
                yield return null;
            }
        }

        // Если мы не в режиме ожидания #delay, показываем панель и печатаем текст
        if (!isWaiting)
        {
            dialoguePanel.SetActive(true);
            ApplyVisualTags();
            typingCoroutine = StartCoroutine(TypewriterRoutine(currentFullLine));
        }
    }

    private void ExecuteAction(string actionType, List<string> parameters)
    {
        switch (actionType)
        {
            case "play_cutscene": PlayCutsceneAction(parameters); break;
            case "delay": DelayAction(parameters); break;
            case "camera_target": CameraTargetAction(parameters); break;
            case "give_item": GiveItemAction(parameters); break;
            case "take_item": TakeItemAction(parameters); break;
            case "quest_add": AddQuestAction(parameters); break;
            case "quest_add_item": AddQuestItemAction(parameters); break;
            case "quest_complete": CompleteQuestAction(parameters); break;
            case "activate_trigger": ActivateTriggerAction(parameters); break;
            case "deactivate_object": DeactivateObjectAction(parameters); break;
            case "activate_object": ActivateObjectAction(parameters); break;
            case "start_animation": StartAnimationAction(parameters); break;
            case "quest_text": QuestTextAction(parameters); break;
            case "change_scene": ChangeSceneAction(parameters); break;
            case "teleport_player": TeleportPlayerAction(parameters); break;
            case "unlock_ability": UnlockAbilityAction(parameters); break;
            case "text_speed": ChangeSpeedAction(parameters); break;
            case "play_animation_sequence": PlayAnimationSequenceAction(parameters); break;
            default: Debug.LogWarning($"Unknown action: {actionType}"); break;
        }
    }

    private void PlayCutsceneAction(List<string> parameters)
    {
        string targetName = GetParameterValue(parameters, "target");
        string animName = GetParameterValue(parameters, "animation_name");
        string destination = GetParameterValue(parameters, "move_after");
        string moveTargetName = GetParameterValue(parameters, "move_target");

        if (string.IsNullOrEmpty(targetName)) targetName = animName;

        if (!string.IsNullOrEmpty(targetName) && !string.IsNullOrEmpty(animName))
        {
            activeCutscenesCount++;
            dialoguePanel.SetActive(false); // Скрываем панель сразу при запуске анимации
            StartCoroutine(PlayCutsceneRoutine(targetName, animName, destination, moveTargetName));
        }
    }

    private IEnumerator PlayCutsceneRoutine(string targetName, string animName, string destination, string moveTargetName)
    {
        if (AnimationManager.Instance != null)
            AnimationManager.Instance.PlayAnimation(targetName, animName);

        float duration = 1.5f;
        if (AnimationManager.Instance != null)
        {
            duration = AnimationManager.Instance.GetAnimationLength(targetName, animName);
            if (duration <= 0) duration = 1.5f;
        }

        yield return new WaitForSeconds(duration);

        if (!string.IsNullOrEmpty(destination))
        {
            string actualObjectToMoveName = !string.IsNullOrEmpty(moveTargetName) ? moveTargetName : targetName;
            GameObject objToMove = GameObject.Find(actualObjectToMoveName);
            GameObject destObj = GameObject.Find(destination);
            if (objToMove != null && destObj != null)
                objToMove.transform.position = destObj.transform.position;
        }

        activeCutscenesCount--;
    }

    private void DelayAction(List<string> parameters)
    {
        float time = -1f;
        string val = GetParameterValue(parameters, "time");
        if (!string.IsNullOrEmpty(val) && float.TryParse(val, System.Globalization.NumberStyles.Any, System.Globalization.CultureInfo.InvariantCulture, out float t))
        {
            time = t;
        }

        StartCoroutine(WaitRoutine(time));
    }

    private IEnumerator WaitRoutine(float time)
    {
        isWaiting = true;
        dialoguePanel.SetActive(false);

        if (time > 0)
        {
            yield return new WaitForSeconds(time);
        }
        else
        {
            // Ждем, пока все запущенные катсцены закончатся
            while (activeCutscenesCount > 0)
            {
                yield return null;
            }
        }

        isWaiting = false;

        // Показываем панель только если не осталось активных катсцен
        if (activeCutscenesCount <= 0)
        {
            dialoguePanel.SetActive(true);
        }
    }

    // --- ОСТАЛЬНЫЕ МЕТОДЫ (Typewriter, Inventory, etc.) ---
    // Они остались без изменений, я включил их, чтобы скрипт был целым

    private IEnumerator TypewriterRoutine(string line)
    {
        isTyping = true;
        dialogueText.text = line;
        dialogueText.maxVisibleCharacters = 0;
        yield return null;
        for (int i = 0; i < line.Length; i++)
        {
            dialogueText.maxVisibleCharacters = i + 1;
            if (i % 2 == 0 && audioSource != null)
            {
                AudioClip clip = currentVoiceSound != null ? currentVoiceSound : defaultTypingSound;
                if (clip != null) { audioSource.pitch = Random.Range(0.95f, 1.05f); audioSource.PlayOneShot(clip); }
            }
            yield return new WaitForSeconds(currentTypingSpeed);
        }
        isTyping = false;
    }

    private void UpdatePlayerStateVariables()
    {
        if (story == null) return;
        List<string> names = new List<string>(story.variablesState);
        foreach (string n in names)
        {
            if (n.StartsWith("has_item_"))
            {
                string[] p = n.Split('_');
                if (p.Length >= 4 && int.TryParse(p[3], out int amt))
                    story.variablesState[n] = CheckActiveSlotForItem(p[2], amt);
            }
        }
    }

    private bool CheckActiveSlotForItem(string id, int amt)
    {
        if (InventoryManager.Instance == null) return false;
        return InventoryManager.Instance.GetActiveSlotItemCount(id) >= amt;
    }

    private void RestoreGlobalVariables()
    {
        foreach (var v in globalVariables) { try { story.variablesState[v.Key] = v.Value; } catch { } }
    }

    private void SaveGlobalVariables()
    {
        if (story == null) return;
        foreach (string v in story.variablesState) globalVariables[v] = story.variablesState[v];
    }

    private void PlayAnimationSequenceAction(List<string> p)
    {
        string t = GetParameterValue(p, "target");
        string a = GetParameterValue(p, "animations");
        if (!string.IsNullOrEmpty(t) && !string.IsNullOrEmpty(a) && AnimationManager.Instance != null)
            AnimationManager.Instance.PlaySequenceOnObject(t, a.Split(',').Select(s => s.Trim()).ToArray());
    }

    private void CameraTargetAction(List<string> p)
    {
        string t = GetParameterValue(p, "target");
        if (!string.IsNullOrEmpty(t) && CameraController.Instance != null) CameraController.Instance.SetTarget(t);
    }

    private void AddQuestAction(List<string> p)
    {
        if (QuestsManager.Instance != null) QuestsManager.Instance.AddQuest(GetParameterValue(p, "id"), GetParameterValue(p, "desc"));
    }

    private void AddQuestItemAction(List<string> p)
    {
        if (QuestsManager.Instance != null) QuestsManager.Instance.AddQuest(GetParameterValue(p, "id"), GetParameterValue(p, "desc"), GetParameterValue(p, "item_id"), GetIntParameterValue(p, "amount", 1));
    }

    private void CompleteQuestAction(List<string> p)
    {
        if (QuestsManager.Instance != null) QuestsManager.Instance.CompleteQuest(GetParameterValue(p, "id"));
    }

    private void GiveItemAction(List<string> p)
    {
        if (InventoryManager.Instance != null) InventoryManager.Instance.AddItem(GetParameterValue(p, "item_id"), GetIntParameterValue(p, "amount", 1));
    }

    private void TakeItemAction(List<string> p)
    {
        if (InventoryManager.Instance != null) InventoryManager.Instance.RemoveItemFromActiveSlot(GetParameterValue(p, "item_id"), GetIntParameterValue(p, "amount", 1));
    }

    private void ActivateTriggerAction(List<string> p)
    {
        GameObject g = GameObject.Find(GetParameterValue(p, "trigger_name"));
        if (g != null && g.GetComponent<Collider2D>()) g.GetComponent<Collider2D>().enabled = true;
    }

    private void DeactivateObjectAction(List<string> p)
    {
        GameObject g = GameObject.Find(GetParameterValue(p, "object_name"));
        if (g != null) g.SetActive(false);
    }

    private void ActivateObjectAction(List<string> p)
    {
        string objName = GetParameterValue(p, "object_name");
        string parentName = GetParameterValue(p, "parent_name"); // Опциональный параметр

        GameObject target = null;

        // ВАРИАНТ 1: Если указан родитель (Самый надежный способ для выключенных объектов)
        if (!string.IsNullOrEmpty(parentName))
        {
            GameObject parent = GameObject.Find(parentName);
            if (parent != null)
            {
                // transform.Find находит даже выключенные дочерние объекты!
                Transform child = parent.transform.Find(objName);
                if (child != null) target = child.gameObject;
                else Debug.LogWarning($"Родитель '{parentName}' найден, но внутри нет '{objName}'");
            }
            else
            {
                Debug.LogWarning($"Родитель '{parentName}' не найден на сцене (он должен быть активен)");
            }
        }
        // ВАРИАНТ 2: Пытаемся найти просто по имени (Сработает ТОЛЬКО если объект уже активен, что редко имеет смысл)
        else
        {
            target = GameObject.Find(objName);
        }

        if (target != null)
        {
            target.SetActive(true);
            Debug.Log($"Объект '{objName}' активирован.");
        }
        else
        {
            Debug.LogWarning($"Не удалось найти объект '{objName}' для активации. Совет: если объект выключен, укажите его родителя через parent_name.");
        }
    }

    private void StartAnimationAction(List<string> p)
    {
        string a = GetParameterValue(p, "animation_name");
        string ans = GetParameterValue(p, "animation_names");
        if (!string.IsNullOrEmpty(ans)) AnimationManager.Instance.PlayMultipleAnimations(ans.Split(','));
        else if (!string.IsNullOrEmpty(a)) AnimationManager.Instance.PlayAnimation(a);
    }

    private void ChangeSceneAction(List<string> p)
    {
        string s = GetParameterValue(p, "scene_name");
        if (!string.IsNullOrEmpty(s)) UnityEngine.SceneManagement.SceneManager.LoadScene(s);
    }

    private void QuestTextAction(List<string> p) { }

    private void TeleportPlayerAction(List<string> p)
    {
        string dest = GetParameterValue(p, "destination");
        string t = GetParameterValue(p, "target");
        if (string.IsNullOrEmpty(t)) t = "Player";
        GameObject obj = GameObject.Find(t);
        GameObject dObj = GameObject.Find(dest);
        if (obj != null && dObj != null) obj.transform.position = dObj.transform.position;
    }

    private void ChangeSpeedAction(List<string> p)
    {
        if (float.TryParse(GetParameterValue(p, "val"), System.Globalization.NumberStyles.Any, System.Globalization.CultureInfo.InvariantCulture, out float s)) currentTypingSpeed = s;
    }

    private void UnlockAbilityAction(List<string> p) { }

    private string GetParameterValue(List<string> p, string k)
    {
        foreach (string s in p) if (s.Trim().StartsWith(k + ":")) return s.Trim().Substring(k.Length + 1).Trim();
        return "";
    }

    private int GetIntParameterValue(List<string> p, string k, int d)
    {
        return int.TryParse(GetParameterValue(p, k), out int r) ? r : d;
    }

    private void ProcessSetTag(string t)
    {
        string[] p = t.Split(' ');
        if (p.Length == 2)
        {
            string v = p[1].ToLower();
            if (v == "true") story.variablesState[p[0].Substring(4)] = true;
            else if (v == "false") story.variablesState[p[0].Substring(4)] = false;
            else story.variablesState[p[0].Substring(4)] = p[1];
        }
    }

    private void ApplyVisualTags()
    {
        portraitLeft.gameObject.SetActive(false);
        portraitRight.gameObject.SetActive(false);
        nameLeft.gameObject.SetActive(false);
        nameRight.gameObject.SetActive(false);

        foreach (string t in story.currentTags)
        {
            if (t == "side:left") { portraitLeft.gameObject.SetActive(true); nameLeft.gameObject.SetActive(true); }
            else if (t == "side:right") { portraitRight.gameObject.SetActive(true); nameRight.gameObject.SetActive(true); }
            else if (t.StartsWith("speaker:"))
            {
                string s = t.Substring(8).Trim();
                if (portraitLeft.gameObject.activeSelf) nameLeft.text = s;
                if (portraitRight.gameObject.activeSelf) nameRight.text = s;
            }
            else if (t.StartsWith("portrait:"))
            {
                Sprite s = Resources.Load<Sprite>("Portraits/" + t.Substring(9).Trim());
                if (s != null)
                {
                    if (portraitLeft.gameObject.activeSelf) portraitLeft.sprite = s;
                    if (portraitRight.gameObject.activeSelf) portraitRight.sprite = s;
                }
            }
        }
    }

    private void SetDefaultSpeaker(NPCData n)
    {
        portraitLeft.gameObject.SetActive(true); nameLeft.gameObject.SetActive(true);
        nameLeft.text = n.npcName; if (n.portrait != null) portraitLeft.sprite = n.portrait;
        currentVoiceSound = n.voiceSound;
        currentTypingSpeed = n.typingSpeed > 0 ? n.typingSpeed : 0.04f;
    }

    private void ShowChoices()
    {
        choicesContainer.gameObject.SetActive(true);
        for (int i = 0; i < story.currentChoices.Count; i++)
        {
            Choice c = story.currentChoices[i];
            GameObject b = Instantiate(choiceButtonPrefab, choicesContainer);
            b.GetComponentInChildren<TMP_Text>().text = c.text;
            int idx = i;
            b.GetComponent<Button>().onClick.AddListener(() => { story.ChooseChoiceIndex(idx); ContinueDialogue(); });
        }
    }

    private void EndDialogue()
    {
        SaveGlobalVariables();
        isPlaying = false;
        isWaiting = false;
        dialoguePanel.SetActive(false);
        choicesContainer.gameObject.SetActive(false);
        if (playerController != null) playerController.enabled = true;
        if (CameraController.Instance != null) CameraController.Instance.SetTarget("Player");
        currentNPC = null;
    }

    public bool IsPlaying() => isPlaying;
}

--- Путь к файлу: .\Scripts\Dialogues\DialogueTrigger.cs ---

﻿using Ink.Runtime;
using System.Xml.Linq;
using UnityEngine;

public class DialogueTrigger : MonoBehaviour
{
    [Header("NPC Settings")]
    public NPCData npcData;

    [Header("Trigger Settings")]
    public bool workOnlyOnce = false;
    public bool startOnEnter = false;
    public bool requirePressE = true;

    private bool inRange = false;
    private bool alreadyUsed = false;

    void OnTriggerEnter2D(Collider2D other)
    {
        if (alreadyUsed && workOnlyOnce) return;
        if (other.CompareTag("Player"))
        {
            inRange = true;
            if (startOnEnter && !requirePressE)
                StartDialogue();
            else if (requirePressE)
                UIInteractPrompt.Instance.Show("Нажми E");
        }
    }

    void OnTriggerExit2D(Collider2D other)
    {
        if (other.CompareTag("Player"))
        {
            inRange = false;
            UIInteractPrompt.Instance.Hide();
        }
    }

    void Update()
    {
        if (inRange && requirePressE && Input.GetKeyDown(KeyCode.E))
        {
            if (DialogueManager.Instance != null && DialogueManager.Instance.IsPlaying())
            {
                return;
            }

            UIInteractPrompt.Instance.Hide();
            StartDialogue();
        }
    }

    void StartDialogue()
    {
        if (workOnlyOnce)
        {
            alreadyUsed = true;
            inRange = false;
        }

        DialogueManager.Instance.StartDialogue(npcData.inkFile, "start", npcData);
    }

    public void ResetMeeting()
    {
        alreadyUsed = false;
    }
}

--- Путь к файлу: .\Scripts\Dialogues\ForestExitTrigger.cs ---

using UnityEngine;
using System.Collections;
using TMPro;

public class ForestExitTrigger : MonoBehaviour
{
    [Header(" ")]
    public Transform returnPoint;

    [Header("")]
    public TextAsset[] dialogues;

    [Header(" ")]
    public float moveSpeed = 3f;
    public int maxAttempts = 3;
    public bool enableQuickTimeEvent = true;

    [Header(" QTE")]
    public float requiredPresses = 10f;
    public float moveDistancePerPress = 0.2f;
    public float timeLimit = 3f;

    [Header(" QTE")]
    [Tooltip("    'A' (,   UI Image)")]
    public GameObject quickTimeAnimationObject;
    public TextMeshProUGUI timerText; // :  /

    [Header("")]
    public AudioSource audioSource;
    public AudioClip successSound;
    public AudioClip failSound;

    private int exitAttempts = 0;
    private PlayerMovement playerController;
    private Animator playerAnimator;
    private bool isReturning = false;
    private bool quickTimeActive = false;
    private float currentPresses = 0f;
    private float quickTimeTimer = 0f;
    private Vector3 quickTimeStartPosition;

    void Start()
    {
        playerController = FindObjectOfType<PlayerMovement>();
        if (playerController != null)
        {
            playerAnimator = playerController.GetComponentInChildren<Animator>();
        }

        //  AudioSource  ,     
        if (audioSource == null) audioSource = GetComponent<AudioSource>();

        //      
        if (quickTimeAnimationObject != null) quickTimeAnimationObject.SetActive(false);
        if (timerText != null) timerText.gameObject.SetActive(false);
    }

    private void OnTriggerEnter2D(Collider2D other)
    {
        if (other.CompareTag("Player") && exitAttempts < maxAttempts && !isReturning && !quickTimeActive)
        {
            exitAttempts++;

            if (exitAttempts == maxAttempts && enableQuickTimeEvent)
            {
                StartQuickTimeEvent(other.gameObject);
            }
            else
            {
                StartCoroutine(ReturnPlayer(other.gameObject));
            }
        }
    }

    void StartQuickTimeEvent(GameObject player)
    {
        quickTimeActive = true;
        currentPresses = 0f;
        quickTimeTimer = timeLimit;
        quickTimeStartPosition = player.transform.position;

        //  
        if (quickTimeAnimationObject != null) quickTimeAnimationObject.SetActive(true);
        if (timerText != null) timerText.gameObject.SetActive(true);

        if (playerController != null) playerController.enabled = false;
    }

    void Update()
    {
        if (quickTimeActive)
        {
            quickTimeTimer -= Time.deltaTime;

            if (Input.GetKeyDown(KeyCode.A))
            {
                OnQuickTimePress();
            }

            UpdateQuickTimeUI();

            if (currentPresses >= requiredPresses)
            {
                QuickTimeSuccess();
            }
            else if (quickTimeTimer <= 0f)
            {
                QuickTimeFail();
            }
        }
    }

    void OnQuickTimePress()
    {
        currentPresses++;

        GameObject player = GameObject.FindGameObjectWithTag("Player");
        if (player != null)
        {
            player.transform.position += Vector3.left * moveDistancePerPress;

            if (playerAnimator != null)
            {
                playerAnimator.SetFloat("Horizontal", -1f);
                playerAnimator.SetFloat("Vertical", 0f);
                playerAnimator.SetFloat("Speed", 1f);
            }
        }
    }

    void UpdateQuickTimeUI()
    {
        if (timerText != null)
        {
            //    ( )
            timerText.text = $"{quickTimeTimer:F1}";
        }
    }

    void QuickTimeSuccess()
    {
        EndQuickTimeEvent();
        PlaySound(successSound);
        StartAnDialogue();
    }

    void QuickTimeFail()
    {
        EndQuickTimeEvent();
        PlaySound(failSound);

        GameObject player = GameObject.FindGameObjectWithTag("Player");
        if (player != null)
        {
            player.transform.position = returnPoint.transform.position;
        }

        exitAttempts--; //   
    }

    void EndQuickTimeEvent()
    {
        quickTimeActive = false;
        StopPlayerAnimation();

        //  
        if (quickTimeAnimationObject != null) quickTimeAnimationObject.SetActive(false);
        if (timerText != null) timerText.gameObject.SetActive(false);

        if (playerController != null) playerController.enabled = true;
    }

    void PlaySound(AudioClip clip)
    {
        if (audioSource != null && clip != null)
        {
            audioSource.PlayOneShot(clip);
        }
    }

    // ---     ---

    void StopPlayerAnimation()
    {
        if (playerAnimator != null) playerAnimator.SetFloat("Speed", 0f);
    }

    IEnumerator ReturnPlayer(GameObject player)
    {
        isReturning = true;
        if (playerController != null) playerController.enabled = false;
        yield return new WaitForSeconds(0.3f);

        while (Vector3.Distance(player.transform.position, returnPoint.position) > 0.1f)
        {
            Vector3 direction = (returnPoint.position - player.transform.position).normalized;
            player.transform.position += direction * moveSpeed * Time.deltaTime;
            UpdatePlayerAnimation(direction);
            yield return null;
        }

        StopPlayerAnimation();
        if (playerController != null) playerController.enabled = true;
        isReturning = false;
        StartAnDialogue();
    }

    void UpdatePlayerAnimation(Vector3 direction)
    {
        if (playerAnimator == null) return;
        playerAnimator.SetFloat("Horizontal", direction.x);
        playerAnimator.SetFloat("Vertical", direction.y);
        playerAnimator.SetFloat("Speed", 1f);
    }

    void StartAnDialogue()
    {
        TextAsset dialogueToPlay = GetDialogue();
        DialogueManager dialogueManager = FindObjectOfType<DialogueManager>();
        if (dialogueManager != null && dialogueToPlay != null)
        {
            dialogueManager.StartDialogue(dialogueToPlay);
        }
    }

    TextAsset GetDialogue()
    {
        if (exitAttempts <= dialogues.Length) return dialogues[exitAttempts - 1];
        else return dialogues[dialogues.Length - 1];
    }

    public void ResetAttempts()
    {
        exitAttempts = 0;
        EndQuickTimeEvent();
    }
}

--- Путь к файлу: .\Scripts\Dialogues\NPCData.cs ---

using UnityEngine;

[CreateAssetMenu(fileName = "New NPC", menuName = "Dialogue/NPC Data")]
public class NPCData : ScriptableObject
{
    [Header("Basic Info")]
    public string npcName;
    public Sprite portrait;

    [Header("Voice Settings")]
    [Tooltip(",     ")]
    public AudioClip voiceSound;

    [Tooltip("   (). 0.05 = .")]
    [Range(0.01f, 0.2f)]
    public float typingSpeed = 0.04f;

    [Header("Ink File")]
    public TextAsset inkFile;
}

--- Путь к файлу: .\Scripts\Dialogues\UIInteractPrompt.cs ---

using UnityEngine;
using TMPro;

public class UIInteractPrompt : MonoBehaviour
{
    public static UIInteractPrompt Instance;
    public TMP_Text promptText;

    void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            //     [GAME_SYSTEMS],    
            if (transform.parent == null) DontDestroyOnLoad(gameObject);
        }
        else if (Instance != this)
        {
            Destroy(gameObject);
            return;
        }

        if (promptText != null) promptText.gameObject.SetActive(false);
    }

    public void Show(string text)
    {
        // :       ,   
        if (promptText == null) return;

        promptText.text = text;
        promptText.gameObject.SetActive(true);
    }

    public void Hide()
    {
        if (promptText == null) return;
        promptText.gameObject.SetActive(false);
    }
}

--- Путь к файлу: .\Scripts\GameSave\Checkpoint.cs ---

using UnityEngine;

public class Checkpoint : MonoBehaviour
{
    [Header("  ")]
    public bool isActive = true;
    public string playerTag = "Player";


    private Renderer checkpointRenderer;

    void Start()
    {
        checkpointRenderer = GetComponent<Renderer>();
    }

    private void OnTriggerEnter(Collider other)
    {
        if (!isActive) return;

        if (other.CompareTag(playerTag))
        {
            SaveAtCheckpoint();
        }
    }

    private void OnTriggerEnter2D(Collider2D other)
    {
        if (!isActive) return;

        if (other.CompareTag(playerTag))
        {
            SaveAtCheckpoint();
        }
    }

    private void SaveAtCheckpoint()
    {
        GameObject player = GameObject.FindGameObjectWithTag(playerTag);
        if (player != null)
        {
            SaveSystem.SaveGame(player.transform.position);
            isActive = false;
            Debug.Log("   !");
        }
    }
}

--- Путь к файлу: .\Scripts\GameSave\GameLoader.cs ---

using UnityEngine;

public class GameLoader : MonoBehaviour
{
    [Header(" ")]
    public Transform defaultSpawnPoint;

    void Start()
    {
        LoadGameState();
    }

    void LoadGameState()
    {
        SaveData saveData = SaveSystem.LoadGame();

        GameObject player = GameObject.FindGameObjectWithTag("Player");
        if (player == null)
        {
            return;
        }

        Vector3 spawnPosition;

        if (saveData != null && saveData.hasSaveData)
        {
            spawnPosition = saveData.GetPlayerPosition();
        }
        else
        {
            spawnPosition = defaultSpawnPoint != null ? defaultSpawnPoint.position : Vector3.zero;
        }

        player.transform.position = spawnPosition;
    }
}

--- Путь к файлу: .\Scripts\GameSave\GameSaveManager.cs ---

using UnityEngine;
using UnityEngine.SceneManagement;
using System.Collections;
using System.Collections.Generic;

public class GameSaveManager : MonoBehaviour
{
    public static GameSaveManager Instance;

    [Header(" ")]
    [Tooltip(",  , ,   ")]
    public GameObject gameSystemsPrefab;

    //   ID  ( ,  )
    private HashSet<string> worldEvents = new HashSet<string>();

    void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
            Debug.Log("GameSaveManager .");
        }
        else if (Instance != this)
        {
            Debug.Log(" GameSaveManager .");
            Destroy(gameObject);
        }
    }

    void Update()
    {
        //    F5
        if (Input.GetKeyDown(KeyCode.F5))
        {
            Debug.Log("  F5  ...");
            SaveGame();
        }

        //    F9 ( )
        if (Input.GetKeyDown(KeyCode.F9))
        {
            Debug.Log("  F9  ...");
            LoadGame();
        }
    }

    //   (   )
    public void RegisterEvent(string id) => worldEvents.Add(id);
    public bool IsEventDone(string id) => worldEvents.Contains(id);

    // ---  ---
    public void SaveGame()
    {
        Debug.Log("---   ---");
        try
        {
            SaveData data = new SaveData();

            // 1. 
            GameObject player = GameObject.FindGameObjectWithTag("Player");
            if (player != null)
            {
                data.sceneName = SceneManager.GetActiveScene().name;
                data.playerX = player.transform.position.x;
                data.playerY = player.transform.position.y;
                data.playerZ = player.transform.position.z;
                Debug.Log("1.   .");
            }
            else
            {
                Debug.LogError(":    Player    !");
                return;
            }

            // 2. 
            if (InventoryManager.Instance != null)
            {
                foreach (var slot in InventoryManager.Instance.inventorySlots)
                {
                    if (slot.HasItem())
                    {
                        data.invIDs.Add(slot.Item.data.itemID);
                        data.invCounts.Add(slot.Item.stackSize);
                    }
                }
                if (InventoryManager.Instance.activeItemSlot != null && InventoryManager.Instance.activeItemSlot.HasItem())
                {
                    data.activeID = InventoryManager.Instance.activeItemSlot.Item.data.itemID;
                    data.activeCount = InventoryManager.Instance.activeItemSlot.Item.stackSize;
                }
                Debug.Log("2.  .");
            }

            // 3. 
            if (QuestsManager.Instance != null)
            {
                foreach (var q in QuestsManager.Instance.allQuests)
                {
                    if (q.isCompleted) data.completedQuests.Add(q.id);
                    else data.activeQuests.Add(q.id);
                }
                Debug.Log("3.  .");
            }

            // 4. 
            data.worldEvents = new List<string>(worldEvents);
            Debug.Log($"4.   ({worldEvents.Count}) .");

            // 5. 
            if (DialogueManager.Instance != null)
            {
                var inkVars = DialogueManager.Instance.GetGlobalVariables();
                if (inkVars != null)
                {
                    foreach (var v in inkVars)
                    {
                        data.inkKeys.Add(v.Key);
                        data.inkValues.Add(v.Value.ToString());
                    }
                    Debug.Log("5.   .");
                }
            }

            // 6.   
            SaveSystem.Save(data);
            Debug.Log("---      ---");
        }
        catch (System.Exception e)
        {
            Debug.LogError("   : " + e.Message);
        }
    }

    // ---  ---
    public void LoadGame()
    {
        SaveData data = SaveSystem.LoadGame();
        if (data != null)
        {
            StartCoroutine(LoadRoutine(data));
        }
        else
        {
            Debug.LogError("   !");
        }
    }

    private IEnumerator LoadRoutine(SaveData data)
    {
        Debug.Log(" : " + data.sceneName);

        // 1.   
        AsyncOperation asyncLoad = SceneManager.LoadSceneAsync(data.sceneName);
        while (!asyncLoad.isDone) yield return null;

        //   ,   
        yield return new WaitForEndOfFrame();

        // 2.  .        
        GameObject player = GameObject.FindGameObjectWithTag("Player");
        if (player == null)
        {
            if (gameSystemsPrefab != null)
            {
                Debug.Log("  .   ...");
                Instantiate(gameSystemsPrefab);
                player = GameObject.FindGameObjectWithTag("Player");
            }
            else
            {
                Debug.LogError(" :  GameSaveManager    [GAME_SYSTEMS]!");
            }
        }

        // 3.     
        if (player != null)
        {
            player.transform.position = new Vector3(data.playerX, data.playerY, data.playerZ);
        }

        // 4.    (HashSet)
        worldEvents = new HashSet<string>(data.worldEvents);

        //   ,        Awake/Start
        yield return null;

        // 5.  
        if (InventoryManager.Instance != null)
        {
            InventoryManager.Instance.ClearAll();

            //   
            for (int i = 0; i < data.invIDs.Count; i++)
            {
                InventoryManager.Instance.AddItem(data.invIDs[i], data.invCounts[i]);
            }

            //      
            if (!string.IsNullOrEmpty(data.activeID))
            {
                InventoryManager.Instance.SetActiveItemFromSave(data.activeID, data.activeCount);
            }

            InventoryManager.Instance.ForceInventoryUpdate();
        }

        // 6.   ( )
        //    QuestsManager.Instance.RestoreQuests(data.activeQuests, data.completedQuests)

        // 7.    Ink
        if (DialogueManager.Instance != null)
        {
            for (int i = 0; i < data.inkKeys.Count; i++)
            {
                DialogueManager.Instance.SetGlobalVariable(data.inkKeys[i], data.inkValues[i]);
            }
        }

        Debug.Log("  !");
    }

    public void PrepareNewGame()
    {
        // 1.    (   ,   )
        worldEvents.Clear();

        // 2.     
        SaveSystem.DeleteSave();

        Debug.Log("    .");
    }
}

--- Путь к файлу: .\Scripts\GameSave\SaveSystem.cs ---

using UnityEngine;
using System.IO;
using System;
using System.Collections.Generic;

[Serializable]
public class SaveData
{
    public string sceneName;

    //  (     )
    public float playerX;
    public float playerY;
    public float playerZ;

    // 
    public List<string> invIDs = new List<string>();
    public List<int> invCounts = new List<int>();
    public string activeID;
    public int activeCount;

    // 
    public List<string> activeQuests = new List<string>();
    public List<string> completedQuests = new List<string>();

    //   (-,  )
    public List<string> worldEvents = new List<string>();

    //  Ink
    public List<string> inkKeys = new List<string>();
    public List<string> inkValues = new List<string>();

    public bool hasSaveData = false;

    //    Vector3 (  GameLoader)
    public Vector3 GetPlayerPosition()
    {
        return new Vector3(playerX, playerY, playerZ);
    }
}

public static class SaveSystem
{
    private static string path = Path.Combine(Application.persistentDataPath, "gamesave.json");

    //    
    public static void Save(SaveData data)
    {
        data.hasSaveData = true;
        string json = JsonUtility.ToJson(data, true);
        File.WriteAllText(path, json);
    }

    //    ( )
    public static void SaveGame(Vector3 position)
    {
        SaveData data = LoadGame();
        if (data == null) data = new SaveData();

        data.playerX = position.x;
        data.playerY = position.y;
        data.playerZ = position.z;
        data.hasSaveData = true;

        string json = JsonUtility.ToJson(data, true);
        File.WriteAllText(path, json);
    }

    //  
    public static SaveData LoadGame()
    {
        if (!File.Exists(path)) return null;
        try
        {
            string json = File.ReadAllText(path);
            return JsonUtility.FromJson<SaveData>(json);
        }
        catch
        {
            return null;
        }
    }

    public static bool HasSaveData() => File.Exists(path);
    public static void DeleteSave() { if (File.Exists(path)) File.Delete(path); }
}

--- Путь к файлу: .\Scripts\Inventory\InventoryItem.cs ---

using UnityEngine;

[System.Serializable]
public class InventoryItem
{
    public ItemData data;
    public int stackSize;

    public InventoryItem(ItemData itemData, int amount = 1)
    {
        data = itemData;
        stackSize = amount;
    }

    public bool AddToStack(int amount = 1)
    {
        if (stackSize + amount <= data.maxStackSize)
        {
            stackSize += amount;
            return true;
        }
        return false;
    }

    public bool RemoveFromStack(int amount = 1)
    {
        stackSize -= amount;
        return stackSize <= 0;
    }
}

--- Путь к файлу: .\Scripts\Inventory\InventoryManager.cs ---

using UnityEngine;
using System;
using System.Collections.Generic;
using UnityEngine.SceneManagement;

public class InventoryManager : MonoBehaviour
{
    public static InventoryManager Instance;

    public static event Action<InventorySlot[]> OnInventoryChanged;
    public static event Action<InventoryItem> OnActiveItemChanged;

    [SerializeField] private int inventorySize = 9;
    public InventorySlot[] inventorySlots;
    public InventorySlot activeItemSlot;

    [SerializeField] private ItemDBSO itemDatabase;

    [Header("UI Settings")]
    public GameObject inventoryPanel;

    private MonoBehaviour playerController;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
            InitializeInventory();
        }
        else
        {
            Destroy(gameObject);
            return;
        }
    }

    private void OnEnable() => SceneManager.sceneLoaded += OnSceneLoaded;
    private void OnDisable() => SceneManager.sceneLoaded -= OnSceneLoaded;
    private void OnSceneLoaded(Scene scene, LoadSceneMode mode) => RefreshReferences();

    private void RefreshReferences()
    {
        playerController = FindObjectOfType<PlayerMovement>();
        if (inventoryPanel == null || !inventoryPanel.activeInHierarchy)
        {
            GameObject found = GameObject.Find("InventoryPanel");
            if (found != null) inventoryPanel = found;
        }
        Invoke("ForceInventoryUpdate", 0.1f);
    }

    private void InitializeInventory()
    {
        if (inventorySlots == null || inventorySlots.Length == 0)
        {
            inventorySlots = new InventorySlot[inventorySize];
            for (int i = 0; i < inventorySlots.Length; i++)
                inventorySlots[i] = new InventorySlot();
        }
        if (activeItemSlot == null) activeItemSlot = new InventorySlot();
    }

    private void Update()
    {
        if (DialogueManager.Instance != null && DialogueManager.Instance.IsPlaying())
        {
            if (inventoryPanel != null && inventoryPanel.activeInHierarchy)
                inventoryPanel.SetActive(false);
            return;
        }

        if (Input.GetKeyDown(KeyCode.Tab)) ToggleInventory();
    }

    public void ToggleInventory()
    {
        if (inventoryPanel != null)
        {
            bool newState = !inventoryPanel.activeInHierarchy;
            inventoryPanel.SetActive(newState);
            if (playerController != null) playerController.enabled = !newState;
        }
    }

    public bool AddItem(string itemID, int amount = 1)
    {
        ItemData itemToAdd = itemDatabase.GetItemByID(itemID);
        if (itemToAdd == null) return false;

        // 1.       ( )
        if (activeItemSlot.HasItem() && activeItemSlot.Item.data.itemID == itemID && itemToAdd.isStackable)
        {
            activeItemSlot.Item.AddToStack(amount);
            ForceInventoryUpdate();
            return true;
        }
        else
        {
            // 2.    
            if (itemToAdd.isStackable)
            {
                for (int i = 0; i < inventorySlots.Length; i++)
                {
                    if (inventorySlots[i].HasItem() && inventorySlots[i].Item.data == itemToAdd)
                    {
                        if (inventorySlots[i].Item.AddToStack(amount))
                        {
                            ForceInventoryUpdate();
                            return true;
                        }
                    }
                }
            }

            // 3.   
            for (int i = 0; i < inventorySlots.Length; i++)
            {
                if (!inventorySlots[i].HasItem())
                {
                    inventorySlots[i].SetItem(new InventoryItem(itemToAdd, amount));
                    ForceInventoryUpdate();
                    return true;
                }
            }
        }
        return false;
    }

    public void TryCraftItems(int from, int to)
    {
        if (from == to) return;
        InventoryItem itemA = inventorySlots[from].Item;
        InventoryItem itemB = inventorySlots[to].Item;
        if (itemA == null || itemB == null) return;

        foreach (ItemData res in itemDatabase.allItems)
        {
            if (res.craftingRecipes == null) continue;
            foreach (var recipe in res.craftingRecipes)
            {
                if ((recipe.item1 == itemA.data && recipe.item2 == itemB.data) ||
                    (recipe.item1 == itemB.data && recipe.item2 == itemA.data))
                {
                    inventorySlots[from].ClearSlot();
                    inventorySlots[to].ClearSlot();
                    AddItem(res.itemID);
                    return;
                }
            }
        }
    }

    public void MoveToActiveSlot(int fromSlotIndex)
    {
        if (fromSlotIndex < 0 || fromSlotIndex >= inventorySlots.Length) return;
        if (!inventorySlots[fromSlotIndex].HasItem()) return;

        if (activeItemSlot.HasItem())
        {
            int emptySlot = FindEmptySlot();
            if (emptySlot != -1)
            {
                inventorySlots[emptySlot].SetItem(activeItemSlot.Item);
                activeItemSlot.ClearSlot();
            }
            else return;
        }

        activeItemSlot.SetItem(inventorySlots[fromSlotIndex].Item);
        inventorySlots[fromSlotIndex].ClearSlot();
        ForceInventoryUpdate();
    }

    public void MoveToInventoryFromActive()
    {
        if (!activeItemSlot.HasItem()) return;
        int emptySlot = FindEmptySlot();
        if (emptySlot != -1)
        {
            inventorySlots[emptySlot].SetItem(activeItemSlot.Item);
            activeItemSlot.ClearSlot();
            ForceInventoryUpdate();
        }
    }

    private int FindEmptySlot()
    {
        for (int i = 0; i < inventorySlots.Length; i++)
            if (!inventorySlots[i].HasItem()) return i;
        return -1;
    }

    public void RemoveItemFromSlot(int slotIndex)
    {
        if (slotIndex >= 0 && slotIndex < inventorySlots.Length)
        {
            inventorySlots[slotIndex].ClearSlot();
            ForceInventoryUpdate();
        }
    }

    public bool RemoveItemFromActiveSlot(string itemID, int amount)
    {
        if (activeItemSlot.HasItem() && activeItemSlot.Item.data.itemID == itemID)
        {
            if (activeItemSlot.Item.stackSize >= amount)
            {
                activeItemSlot.Item.stackSize -= amount;
                if (activeItemSlot.Item.stackSize <= 0) activeItemSlot.ClearSlot();
                ForceInventoryUpdate();
                return true;
            }
        }
        return false;
    }

    public void ClearAll()
    {
        foreach (var slot in inventorySlots) slot.ClearSlot();
        activeItemSlot.ClearSlot();
        ForceInventoryUpdate();
    }

    public void SetActiveItemFromSave(string id, int count)
    {
        ItemData data = itemDatabase.GetItemByID(id);
        if (data != null)
        {
            activeItemSlot.SetItem(new InventoryItem(data, count));
            ForceInventoryUpdate();
        }
    }

    public int GetFirstItemIndex(string id)
    {
        for (int i = 0; i < inventorySlots.Length; i++)
            if (inventorySlots[i].HasItem() && inventorySlots[i].Item.data.itemID == id) return i;
        return -1;
    }

    public int GetItemCount(string itemID)
    {
        int total = (activeItemSlot.HasItem() && activeItemSlot.Item.data.itemID == itemID) ? activeItemSlot.Item.stackSize : 0;
        foreach (var slot in inventorySlots) if (slot.HasItem() && slot.Item.data.itemID == itemID) total += slot.Item.stackSize;
        return total;
    }

    public int GetActiveSlotItemCount(string itemID)
    {
        if (activeItemSlot.HasItem() && activeItemSlot.Item.data.itemID == itemID) return activeItemSlot.Item.stackSize;
        return 0;
    }

    public void ForceInventoryUpdate()
    {
        OnInventoryChanged?.Invoke(inventorySlots);
        OnActiveItemChanged?.Invoke(activeItemSlot != null && activeItemSlot.HasItem() ? activeItemSlot.Item : null);
    }
}

// ---   (   ) ---

[System.Serializable]
public class InventorySlot
{
    public InventoryItem Item;
    public bool HasItem() => Item != null && Item.data != null;
    public void SetItem(InventoryItem newItem) => Item = newItem;
    public void ClearSlot() => Item = null;
}

--- Путь к файлу: .\Scripts\Inventory\InventorySlotUI.cs ---

using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class InventorySlotUI : MonoBehaviour, IPointerClickHandler, IBeginDragHandler, IEndDragHandler, IDropHandler, IDragHandler
{
    [SerializeField] private Image itemIcon;
    [SerializeField] private TMPro.TextMeshProUGUI stackCountText;

    public int SlotIndex;
    public bool isActiveItemSlot = false;

    private InventorySlot assignedSlot;
    private GameObject dragObject;
    private float lastClickTime;

    private void Start()
    {
        InventoryManager.OnInventoryChanged += UpdateSlotUI;
        InventoryManager.OnActiveItemChanged += UpdateActiveSlotUI;

        AssignSlot();
    }

    private void OnDestroy()
    {
        InventoryManager.OnInventoryChanged -= UpdateSlotUI;
        InventoryManager.OnActiveItemChanged -= UpdateActiveSlotUI;
    }

    private void AssignSlot()
    {
        if (InventoryManager.Instance == null) return;

        if (!isActiveItemSlot)
        {
            // : ,     
            if (InventoryManager.Instance.inventorySlots != null && SlotIndex < InventoryManager.Instance.inventorySlots.Length)
            {
                assignedSlot = InventoryManager.Instance.inventorySlots[SlotIndex];
            }
        }
        else
        {
            assignedSlot = InventoryManager.Instance.activeItemSlot;
        }

        UpdateSlotDisplay();
    }

    private void UpdateSlotUI(InventorySlot[] inventory)
    {
        if (!isActiveItemSlot) UpdateSlotDisplay();
    }

    private void UpdateActiveSlotUI(InventoryItem activeItem)
    {
        if (isActiveItemSlot) UpdateSlotDisplay();
    }

    private void UpdateSlotDisplay()
    {
        if (itemIcon == null) return; //   MissingReference

        if (assignedSlot != null && assignedSlot.HasItem())
        {
            itemIcon.sprite = assignedSlot.Item.data.icon;
            itemIcon.color = Color.white;
            itemIcon.enabled = true; //   

            if (stackCountText != null)
                stackCountText.text = assignedSlot.Item.stackSize > 1 ? assignedSlot.Item.stackSize.ToString() : "";
        }
        else
        {
            itemIcon.sprite = null;
            itemIcon.color = Color.clear;
            itemIcon.enabled = false; //  ,   

            if (stackCountText != null)
                stackCountText.text = "";
        }
    }

    public void OnPointerClick(PointerEventData eventData)
    {
        if (assignedSlot == null) return;

        if (eventData.button == PointerEventData.InputButton.Left)
        {
            if (Time.time - lastClickTime <= 0.3f)
            {
                if (!isActiveItemSlot && assignedSlot.HasItem())
                    InventoryManager.Instance.MoveToActiveSlot(SlotIndex);
                else if (isActiveItemSlot && assignedSlot.HasItem())
                    InventoryManager.Instance.MoveToInventoryFromActive();
            }
            lastClickTime = Time.time;
        }
    }

    // Drag n Drop  ( )
    public void OnBeginDrag(PointerEventData eventData) { /*   */ }
    public void OnDrag(PointerEventData eventData) { if (dragObject != null) dragObject.transform.position = eventData.position; }
    public void OnEndDrag(PointerEventData eventData) { if (dragObject != null) Destroy(dragObject); AssignSlot(); }
    public void OnDrop(PointerEventData eventData)
    {
        var from = eventData.pointerDrag?.GetComponent<InventorySlotUI>();
        if (from != null && !from.isActiveItemSlot && !isActiveItemSlot)
            InventoryManager.Instance.TryCraftItems(from.SlotIndex, SlotIndex);
    }
}

--- Путь к файлу: .\Scripts\Inventory\ItemData.cs ---

using UnityEngine;

public enum ItemType
{
    Default,
    Consumable,
    Weapon,
    QuestItem
}

[CreateAssetMenu(fileName = "New Item", menuName = "Inventory/Item Data")]
public class ItemData : ScriptableObject
{
    [Header("Basic Info")]
    public string itemID;
    public string itemName;
    [TextArea] public string description;
    public Sprite icon;

    [Header("Settings")]
    public ItemType type;
    public bool isStackable = false;
    public int maxStackSize = 1;

    [Header("Crafting")]
    public CraftingRecipe[] craftingRecipes;
}

[System.Serializable]
public struct CraftingRecipe
{
    public ItemData item1;
    public ItemData item2;
}

--- Путь к файлу: .\Scripts\Inventory\ItemDBSO.cs ---

using UnityEngine;

[CreateAssetMenu(fileName = "Item Database", menuName = "Inventory/Item Database")]
public class ItemDBSO : ScriptableObject
{
    public ItemData[] allItems;

    public ItemData GetItemByID(string id)
    {
        if (allItems == null)
        {
            return null;
        }

        if (string.IsNullOrEmpty(id))
        {
            return null;
        }

        foreach (ItemData item in allItems)
        {
            if (item == null)
            {
                continue;
            }

            if (item.itemID == id)
            {
                return item;
            }
        }

        return null;
    }
}

--- Путь к файлу: .\Scripts\Inventory\ItemPickup.cs ---

using System.Xml;
using UnityEngine;

public class ItemPickup : MonoBehaviour
{
    [Header("Unique Settings")]
    public string uniqueID;

    [Header("Item Settings")]
    public ItemData itemData;
    public int amount = 1;

    [Header("Interaction Settings")]
    public KeyCode interactKey = KeyCode.E;

    private bool playerInRange = false;

    void Awake()
    {
        if (GameSaveManager.Instance.IsEventDone(uniqueID))
        {
            Destroy(gameObject);
        }
    }

    void Start()
    {
        if (itemData != null && itemData.icon != null)
        {
            SpriteRenderer spriteRenderer = GetComponent<SpriteRenderer>();
            if (spriteRenderer != null)
            {
                spriteRenderer.sprite = itemData.icon;
            }
        }
    }

    void Update()
    {
        if (playerInRange && Input.GetKeyDown(interactKey))
        {
            TryPickupItem();
        }
    }

    void OnTriggerEnter2D(Collider2D other)
    {
        if (other.CompareTag("Player"))
        {
            playerInRange = true;
        }
        UIInteractPrompt.Instance.Show(" E,  ");
    }

    void OnTriggerExit2D(Collider2D other)
    {
        if (other.CompareTag("Player"))
        {
            playerInRange = false;
            Debug.Log("   ");
        }
        UIInteractPrompt.Instance.Hide();
    }

    void TryPickupItem()
    {
        if (InventoryManager.Instance.AddItem(itemData.itemID, amount))
        {
            GameSaveManager.Instance.RegisterEvent(uniqueID); 
            Destroy(gameObject);
        }

        Debug.Log(" : " + itemData.itemID);
        if (itemData == null)
        {
            return;
        }
    }
}

--- Путь к файлу: .\Scripts\Payer\PlayerMovement.cs ---

﻿using UnityEngine;

public class PlayerMovement : MonoBehaviour
{
    [Header("Настройки")]
    public float runSpeed = 10f;
    public float moveSpeed = 5f;

    // Ссылка на компонент Аниматор
    public Animator animator;

    // Сюда больше не нужно перетаскивать отдельные спрайты!
    // public Sprite frontsprite; <-- Удали или забудь про эти переменные
    // public Sprite backsprite;
    // ...

    private Rigidbody2D rb;
    private Vector2 movement;

    void Start()
    {
        rb = GetComponent<Rigidbody2D>();

        // --- ИСПРАВЛЕНИЕ ---
        // Если забыл привязать в инспекторе, ищем ВНУТРИ дочерних объектов (Visuals)
        if (animator == null)
        {
            animator = GetComponentInChildren<Animator>();
        }

        // Если всё равно не нашли - ругаемся в консоль
        if (animator == null)
        {
            Debug.LogError("❌ ОШИБКА: Скрипт PlayerMovement не нашел Animator! Убедись, что на объекте Visuals есть компонент Animator.");
        }
    }

    void Update()
    {
        // 1. Ввод
        movement.x = Input.GetKey(KeyCode.D) ? 1 : Input.GetKey(KeyCode.A) ? -1 : 0;
        movement.y = Input.GetKey(KeyCode.W) ? 1 : Input.GetKey(KeyCode.S) ? -1 : 0;
        movement = movement.normalized;

        // 2. Определяем, бежим мы или идем
        // Если нажат Shift - используем runSpeed, иначе moveSpeed
        bool isRunning = Input.GetKey(KeyCode.LeftShift);

        // 3. Вычисляем множитель анимации
        // Если стоим -> 0
        // Если идем -> 1
        // Если бежим -> (runSpeed / moveSpeed), например 8/5 = 1.6
        float animationSpeedMultiplier = 0f;

        if (movement.sqrMagnitude > 0)
        {
            if (isRunning)
            {
                animationSpeedMultiplier = runSpeed / moveSpeed; // Например 1.6
            }
            else
            {
                animationSpeedMultiplier = 1f; // Обычная скорость
            }
        }

        // 4. Передаем в Аниматор
        if (animator != null)
        {
            // Теперь Speed управляет и переходом (0 -> 1), и скоростью шагов (1 -> 1.6)
            animator.SetFloat("Speed", animationSpeedMultiplier);

            if (movement.x != 0 || movement.y != 0)
            {
                animator.SetFloat("Horizontal", movement.x);
                animator.SetFloat("Vertical", movement.y);
            }
        }
    }

    void FixedUpdate()
    {
        float currentSpeed = Input.GetKey(KeyCode.LeftShift) ? runSpeed : moveSpeed;
        rb.MovePosition(rb.position + movement * currentSpeed * Time.fixedDeltaTime);
    }
}

--- Путь к файлу: .\Scripts\Payer\ZSorter.cs ---

using UnityEngine;

[ExecuteInEditMode]
public class ZSorter : MonoBehaviour
{
    [Header(" ")]
    //   =   
    public float zOffset = 0f;

    [Header(" ")]
    //    -   Z   0 (  )
    //    - Z   (  )
    public bool activeInEditor = false;

    void LateUpdate()
    {
        // :
        //    (Application.isPlaying) ->  .
        //     ->      activeInEditor.

        bool shouldUpdateZ = Application.isPlaying || activeInEditor;

        Vector3 pos = transform.position;

        if (shouldUpdateZ)
        {
            //  Z    Y (    )
            //   -1,     (Y+) Z 
            // (  -1f,    )
            pos.z = (pos.y * 1f) + zOffset;
        }
        else
        {
            //        ->  Z  
            // (    )
            pos.z = 0f;
        }

        transform.position = pos;
    }
}

--- Путь к файлу: .\Scripts\PlatesMiniGame\FalsePlate.cs ---

using UnityEngine;

public class FalsePlate : MonoBehaviour
{
    //    ,     ,
    //     - .
    public void Initialize(Transform unused = null)
    {
        //       ,   
    }

    private void OnTriggerEnter2D(Collider2D other)
    {
        if (other.CompareTag("Player"))
        {
            //   ,   
            if (PressurePlatePuzzle.Instance != null)
            {
                PressurePlatePuzzle.Instance.OnFalsePlateStepped();
            }
        }
    }
}

--- Путь к файлу: .\Scripts\PlatesMiniGame\PressurePlate.cs ---

using UnityEngine;

public class PressurePlate : MonoBehaviour
{
    [Header("Plate Settings")]
    public int plateIndex;
    public bool isCorrectPlate = true;

    [Header("Animations")]
    public AnimationClip activationAnimation;
    public AnimationClip rightStepAnimation;
    public AnimationClip wrongStepAnimation;

    private PressurePlatePuzzle puzzleController;
    private Animator animator;

    public void Initialize(PressurePlatePuzzle controller)
    {
        puzzleController = controller;
        animator = GetComponent<Animator>();
        if (animator != null) animator.enabled = false;
    }

    // --- :    ---

    public void PlayActivationAnimation()
    {
        if (animator != null && activationAnimation != null)
        {
            animator.enabled = true;
            // Play(, , ). 0f  "  0 "
            animator.Play(activationAnimation.name, -1, 0f);
        }
    }

    public void PlayRightStepAnimation()
    {
        if (animator != null && rightStepAnimation != null)
        {
            animator.enabled = true;
            animator.Play(rightStepAnimation.name, -1, 0f);
        }
    }

    public void PlayWrongStepAnimation()
    {
        if (animator != null && wrongStepAnimation != null)
        {
            animator.enabled = true;
            animator.Play(wrongStepAnimation.name, -1, 0f);
        }
    }

    private void OnTriggerEnter2D(Collider2D other)
    {
        if (other.CompareTag("Player"))
        {
            if (puzzleController != null)
            {
                puzzleController.OnPlateStepped(plateIndex, isCorrectPlate);
            }
        }
    }
}

--- Путь к файлу: .\Scripts\PlatesMiniGame\PressurePlatePuzzle.cs ---

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PressurePlatePuzzle : MonoBehaviour
{
    public static PressurePlatePuzzle Instance;

    public string puzzleID;

    [Header("Puzzle Settings")]
    public List<PressurePlate> puzzlePlates = new List<PressurePlate>();
    public float sequenceDelay = 1f;
    public Transform playerStartPosition;

    [Header("Trigger Zone (Камень)")]
    // Сюда перетащи объект камня, чтобы проверять дистанцию
    public Transform triggerZoneObject;
    public float interactionRadius = 3.0f; // Радиус, в котором работает кнопка E

    [Header("False Plates")]
    public GameObject falsePlatesParent;
    public List<FalsePlate> falsePlates = new List<FalsePlate>();

    [Header("Camera Settings")]
    public Transform puzzleCameraPosition;
    // ЧЕМ БОЛЬШЕ ЭТО ЧИСЛО, ТЕМ МЕДЛЕННЕЕ КАМЕРА (0.1 = быстро, 1.0 = очень медленно)
    public float smoothTime = 0.8f;

    private bool isPuzzleSolved = false;
    private bool isShowingHint = false;

    private Camera mainCamera;
    private CameraController cameraController;
    private Transform playerTransform;
    private PlayerMovement playerMovement;

    private Vector3 initialCameraOffset;
    private Vector3 currentVelocity; // Для SmoothDamp

    void Awake()
    {
        Instance = this;
    }

    void Start()
    {
        mainCamera = Camera.main;
        if (mainCamera != null)
        {
            cameraController = mainCamera.GetComponent<CameraController>();
            GameObject player = GameObject.FindGameObjectWithTag("Player");
            if (player != null)
            {
                playerTransform = player.transform;
                playerMovement = player.GetComponent<PlayerMovement>();
                initialCameraOffset = mainCamera.transform.position - player.transform.position;
            }
        }

        foreach (PressurePlate plate in puzzlePlates) plate.Initialize(this);

        if (falsePlatesParent != null && falsePlates.Count == 0)
        {
            FalsePlate[] foundPlates = falsePlatesParent.GetComponentsInChildren<FalsePlate>();
            falsePlates.AddRange(foundPlates);
        }

        foreach (FalsePlate falsePlate in falsePlates) falsePlate.Initialize();
    }

    void Update()
    {
        // Если пазл решен или мультик уже идет - ничего не делаем
        if (isPuzzleSolved || isShowingHint) return;

        // Если нажали E и мы рядом с камнем
        if (Input.GetKeyDown(KeyCode.E) && IsPlayerNearStone())
        {
            StartCoroutine(PlayHintRoutine());
        }
    }

    private bool IsPlayerNearStone()
    {
        if (triggerZoneObject == null || playerTransform == null) return false;
        return Vector2.Distance(triggerZoneObject.position, playerTransform.position) <= interactionRadius;
    }

    private IEnumerator PlayHintRoutine()
    {
        isShowingHint = true;

        if (playerMovement != null) playerMovement.enabled = false;
        if (cameraController != null) cameraController.isLocked = true;

        Vector3 targetCamPos = puzzleCameraPosition.position;
        targetCamPos.z = mainCamera.transform.position.z;

        // --- ДВИЖЕНИЕ К ПАЗЛУ ---
        // Двигаемся, пока дистанция больше 0.1
        while (Vector3.Distance(mainCamera.transform.position, targetCamPos) > 0.1f)
        {
            mainCamera.transform.position = Vector3.SmoothDamp(
                mainCamera.transform.position,
                targetCamPos,
                ref currentVelocity,
                smoothTime
            );
            yield return null;
        }

        // --- АНИМАЦИЯ ---
        currentVelocity = Vector3.zero; // Сброс скорости
        yield return new WaitForSeconds(0.3f);

        for (int i = 0; i < puzzlePlates.Count; i++)
        {
            puzzlePlates[i].PlayActivationAnimation();
            yield return new WaitForSeconds(sequenceDelay);
        }

        yield return new WaitForSeconds(0.5f);

        // --- ДВИЖЕНИЕ ОБРАТНО ---
        Vector3 returnPos = playerTransform.position + initialCameraOffset;

        while (Vector3.Distance(mainCamera.transform.position, returnPos) > 0.1f)
        {
            // Обновляем цель (если игрок чуть сдвинулся физикой)
            returnPos = playerTransform.position + initialCameraOffset;

            mainCamera.transform.position = Vector3.SmoothDamp(
                mainCamera.transform.position,
                returnPos,
                ref currentVelocity,
                smoothTime
            );
            yield return null;
        }

        // Финальная доводка
        mainCamera.transform.position = returnPos;

        if (cameraController != null) cameraController.isLocked = false;
        if (playerMovement != null) playerMovement.enabled = true;

        isShowingHint = false;
    }

    public void OnPlateStepped(int plateIndex, bool isCorrectPlate)
    {
        if (isPuzzleSolved || isShowingHint) return;

        if (isCorrectPlate)
        {
            puzzlePlates[plateIndex].PlayRightStepAnimation();
            if (plateIndex == puzzlePlates.Count - 1) PuzzleCompleted();
        }
        else ResetPlayer();
    }

    public void OnFalsePlateStepped() { if (!isPuzzleSolved) ResetPlayer(); }

    private void ResetPlayer()
    {
        if (playerTransform != null && playerStartPosition != null)
        {
            Rigidbody2D rb = playerTransform.GetComponent<Rigidbody2D>();
            if (rb != null) rb.linearVelocity = Vector2.zero;
            playerTransform.position = playerStartPosition.position;
        }
        foreach (PressurePlate plate in puzzlePlates) plate.PlayWrongStepAnimation();
    }

    private void PuzzleCompleted()
    {
        isPuzzleSolved = true;
        Debug.Log("✅ ГОЛОВОЛОМКА ПРОЙДЕНА!");

        // Ищем скрипт зоны на объекте триггера
        if (triggerZoneObject != null)
        {
            PuzzleActivationZone zoneScript = triggerZoneObject.GetComponent<PuzzleActivationZone>();

            if (zoneScript != null)
            {
                zoneScript.DisableZone(); // Вызываем наш новый метод
            }
            else
            {
                // Если скрипт не найден, попробуем просто выключить объект
                // (Если камень - это только триггер, а не декорация)
                // triggerZoneObject.gameObject.SetActive(false); 

                Debug.LogWarning("⚠️ Не найден скрипт PuzzleActivationZone на камне!");
            }
        }
    }
}

--- Путь к файлу: .\Scripts\PlatesMiniGame\PuzzleActivationZone.cs ---

using UnityEngine;

public class PuzzleActivationZone : MonoBehaviour
{
    [Header("UI Prompt")]
    public GameObject pressEPrompt;

    private void OnTriggerEnter2D(Collider2D other)
    {
        if (other.CompareTag("Player") && pressEPrompt != null)
            pressEPrompt.SetActive(true);
    }

    private void OnTriggerExit2D(Collider2D other)
    {
        if (other.CompareTag("Player") && pressEPrompt != null)
            pressEPrompt.SetActive(false);
    }

    //  :  
    public void DisableZone()
    {
        if (pressEPrompt != null) pressEPrompt.SetActive(false); //  
        gameObject.SetActive(false); //    (   )
        // : this.enabled = false; GetComponent<Collider2D>().enabled = false; (    ,  )
    }
}

--- Путь к файлу: .\Scripts\Quests\ActivateObject.cs ---

﻿using UnityEngine;

public class ActivateObject : MonoBehaviour
{
    public GameObject objectToActivate;

    void OnTriggerEnter2D(Collider2D other)
    {
        if (other.CompareTag("Player"))
        {
            objectToActivate.SetActive(true);
        }
    }
}


--- Путь к файлу: .\Scripts\Quests\AnimationManager.cs ---

﻿using UnityEngine;
using System.Collections;
using System.Linq;

public class AnimationManager : MonoBehaviour
{
    public static AnimationManager Instance;

    void Awake()
    {
        Instance = this;
    }

    public void PlayAnimation(string objectName, string animationName)
    {
        GameObject obj = GameObject.Find(objectName);
        if (obj != null)
        {
            Animator animator = obj.GetComponent<Animator>();
            if (animator != null)
            {
                animator.enabled = true;
                animator.Play(animationName);
            }
        }
    }

    public float GetAnimationLength(string objectName, string animationName)
    {
        GameObject obj = GameObject.Find(objectName);
        if (obj != null)
        {
            Animator animator = obj.GetComponent<Animator>();
            if (animator != null && animator.runtimeAnimatorController != null)
            {
                foreach (AnimationClip clip in animator.runtimeAnimatorController.animationClips)
                {
                    if (clip.name == animationName || clip.name.EndsWith(animationName))
                    {
                        return clip.length;
                    }
                }
            }
        }
        return 0f;
    }

    public void PlayAnimation(string animationName)
    {
        PlayAnimation(animationName, animationName);
    }

    public void PlayMultipleAnimations(string[] animationNames)
    {
        StartCoroutine(PlayAnimationsSequentially(animationNames));
    }

    private IEnumerator PlayAnimationsSequentially(string[] animationNames)
    {
        foreach (string animationName in animationNames)
        {
            PlayAnimation(animationName);
            yield return new WaitForSeconds(0.1f);
        }
    }

    public void PlaySequenceOnObject(string objectName, string[] animationNames)
    {
        StartCoroutine(PlaySequenceRoutine(objectName, animationNames));
    }

    private IEnumerator PlaySequenceRoutine(string objectName, string[] anims)
    {
        foreach (string anim in anims)
        {
            PlayAnimation(objectName, anim);
            float duration = GetAnimationLength(objectName, anim);
            if (duration <= 0) duration = 0.5f;
            yield return new WaitForSeconds(duration);
        }
    }

    public float GetAnimationLength(string animationName)
    {
        return GetAnimationLength(animationName, animationName);
    }
}

--- Путь к файлу: .\Scripts\Quests\QuestsManager.cs ---

using UnityEngine;
using System.Collections.Generic;
using TMPro;          
using UnityEngine.UI; 

[System.Serializable]
public class Quest
{
    public string id;            
    public string description;   
    public bool isCompleted;     

    public string requiredItemID; 
    public int requiredAmount;  
    public int currentAmount;    

    public Quest(string id, string desc, string itemID = "", int amount = 0)
    {
        this.id = id;
        this.description = desc;
        this.requiredItemID = itemID;
        this.requiredAmount = amount;
        this.isCompleted = false;
        this.currentAmount = 0;
    }

    public string GetDisplayText()
    {
        if (string.IsNullOrEmpty(requiredItemID) || isCompleted)
        {
            return description;
        }

        else
        {
            return $"{description} ({currentAmount}/{requiredAmount})";
        }
    }
}

public class QuestsManager : MonoBehaviour
{
    public static QuestsManager Instance;

    [Header("  (UI)")]
    public GameObject questPanel;    
    public Transform choicesPanel;      
    public GameObject questButtonPrefab; 

    [Header("   (HUD)")]
    public TMP_Text activeQuestHUD;    

    public List<Quest> allQuests = new List<Quest>();

    private Quest trackedQuest;

    private MonoBehaviour playerController;

    void Awake()
    {
        Instance = this;
        if (activeQuestHUD != null) activeQuestHUD.text = "";
        playerController = FindObjectOfType<PlayerMovement>();
    }

    void Start()
    {
        InventoryManager.OnInventoryChanged += OnInventoryUpdate;
    }

    void OnDestroy()
    {
        InventoryManager.OnInventoryChanged -= OnInventoryUpdate;
    }

    void Update()
    {
        if (!DialogueManager.Instance.IsPlaying())
        {
            if (Input.GetKeyDown(KeyCode.J))
            {
                ToggleQuestsList();
            }
        }

        if (DialogueManager.Instance.IsPlaying() && questPanel.activeInHierarchy)
        {
            questPanel.SetActive(false);
            DeleteQuestsList();
        }

    }

    private void OnInventoryUpdate(InventorySlot[] slots)
    {
        bool needsUpdate = false;

        foreach (var quest in allQuests)
        {
            if (!quest.isCompleted && !string.IsNullOrEmpty(quest.requiredItemID))
            {
                int count = InventoryManager.Instance.GetItemCount(quest.requiredItemID);

                if (quest.currentAmount != count)
                {
                    quest.currentAmount = count;
                    needsUpdate = true;
                }
            }
        }

        if (needsUpdate)
        {
            UpdateHUD();
            if (questPanel.activeInHierarchy) ShowQuestsInJournal();
        }
    }

    public void ToggleQuestsList()
    {
        bool isActive = questPanel.activeInHierarchy;
        if (isActive)
        {
            if (playerController != null) playerController.enabled = true;
            questPanel.SetActive(false);
            DeleteQuestsList();
        }
        else
        {
            if (playerController != null) playerController.enabled = false;
            questPanel.SetActive(true);
            ShowQuestsInJournal();
        }

    }

    public void AddQuest(string id, string desc, string itemID = "", int amount = 0)
    {
        if (allQuests.Exists(x => x.id == id)) return;

        Quest newQuest = new Quest(id, desc, itemID, amount);

        if (!string.IsNullOrEmpty(itemID))
        {
            newQuest.currentAmount = InventoryManager.Instance.GetItemCount(itemID);
        }

        allQuests.Add(newQuest);

        TrackQuest(newQuest);
    }

    public void CompleteQuest(string id)
    {
        Quest quest = allQuests.Find(x => x.id == id);
        if (quest != null)
        {
            quest.isCompleted = true;

            if (trackedQuest == quest)
            {
                activeQuestHUD.text = "";
                trackedQuest = null;
            }

            if (questPanel.activeInHierarchy) ShowQuestsInJournal();
        }
    }

    public void TrackQuest(Quest quest)
    {
        if (quest.isCompleted) return;

        trackedQuest = quest;
        UpdateHUD();
    }

    private void UpdateHUD()
    {
        if (activeQuestHUD == null) return;

        if (trackedQuest != null && !trackedQuest.isCompleted)
        {
            activeQuestHUD.text = trackedQuest.GetDisplayText();
        }
        else
        {
            activeQuestHUD.text = "";
        }
    }

    public void ShowQuestsInJournal()
    {
        DeleteQuestsList();

        foreach (Quest quest in allQuests)
        {
            GameObject buttonObj = Instantiate(questButtonPrefab, choicesPanel);
            TMP_Text buttonText = buttonObj.GetComponentInChildren<TMP_Text>();
            Button btn = buttonObj.GetComponent<Button>();

            if (quest.isCompleted)
            {

                buttonText.text = $"<s>{quest.description}</s> <color=black></color>";
                buttonText.color = Color.gray;
                btn.interactable = false; 
            }
            else
            {

                buttonText.text = quest.GetDisplayText();
                if (trackedQuest == quest) buttonText.color = Color.black;

                else buttonText.color = Color.white;


                btn.onClick.AddListener(() => {
                    TrackQuest(quest);
                    ShowQuestsInJournal();
                });
            }
        }
    }

    public void DeleteQuestsList()
    {
        foreach (Transform child in choicesPanel)
        {
            Destroy(child.gameObject);
        }
    }
}

--- Путь к файлу: .\Scripts\Quests\TriggerManager.cs ---

﻿using UnityEngine;

public class TriggerManager : MonoBehaviour
{
	public static TriggerManager Instance;

	void Awake()
	{
		Instance = this;
	}

	public void ActivateTrigger(string triggerName)
	{
		GameObject trigger = GameObject.Find(triggerName);
		if (trigger != null)
		{
			Collider2D collider = trigger.GetComponent<Collider2D>();
			if (collider != null) 
			{
				collider.enabled = true;
			}
		}
	}

	public void DeactivateObject(string objectName)
	{
		GameObject obj = GameObject.Find(objectName);
		if (obj != null)
		{
			obj.SetActive(false);
		}
	}
}

--- Путь к файлу: .\Scripts\SudokuMiniGame\DraggableNumber.cs ---

﻿using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class DraggableNumber : MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler
{
	public int numberValue;
	private CanvasGroup canvasGroup;
	private Vector3 startPosition;

	void Start()
	{
		canvasGroup = GetComponent<CanvasGroup>();
		if (canvasGroup == null)
			canvasGroup = gameObject.AddComponent<CanvasGroup>();
        
		numberValue = int.Parse(GetComponentInChildren<Text>().text);
	}

	public void OnBeginDrag(PointerEventData eventData)
	{
		canvasGroup.alpha = 0.6f;
		canvasGroup.blocksRaycasts = false;
		startPosition = transform.position;
	}

	public void OnDrag(PointerEventData eventData)
	{
		transform.position = eventData.position;
	}

	public void OnEndDrag(PointerEventData eventData)
	{
		canvasGroup.alpha = 1f;
		canvasGroup.blocksRaycasts = true;
		transform.position = startPosition;
	}
}

--- Путь к файлу: .\Scripts\SudokuMiniGame\GameManager.cs ---

﻿using UnityEngine;
using UnityEngine.UI;
using System.Collections;

public class GameManager : MonoBehaviour
{
    public string puzzleID;

    [Header("Settings")]
    public int gridSize = 3;
    public int targetSum = 15;

    [Header("Initial Values")]
    public string initialGrid = "000000000";

    [Header("Prefabs")]
    public GameObject cellPrefab;
    public GameObject numberPrefab;

    [Header("UI")]
    public Transform gridParent;
    public Transform numbersPanel;
    public Text targetText;
    public Image statusIndicator;
    public Button resetButton;
    public GameObject gamePanel;

    public AnimationClip treeAnimation;
    public GameObject treeObject;

    private Animator treeAnimator;

    private TableCell[,] gridCells;
    private MonoBehaviour playerController;

    public static GameManager Instance;

    void Awake()
    {
        Instance = this;
        
        gamePanel.SetActive(false);
        playerController = FindObjectOfType<PlayerMovement>();

        if (treeObject != null)
        {
            treeAnimator = treeObject.GetComponent<Animator>();

            if (treeAnimator != null)
            {
                treeAnimator.enabled = false;
            }
        }


    }
    public void StartMiniGame()
    {
        if(playerController != null)
        {
            playerController.enabled = false;
        }

        if (resetButton != null)
        {
            resetButton.onClick.AddListener(ResetGrid);
        }

        gamePanel.SetActive(true);
        CreateGrid();
        CreateNumbers();
        SetupInitialValues();
        targetText.text = $"object.targetposition = {targetSum}";
    }

    void CreateGrid()
    {
        foreach (Transform child in gridParent)
            Destroy(child.gameObject);

        GridLayoutGroup gridLayout = gridParent.GetComponent<GridLayoutGroup>();
        if (gridLayout == null)
            gridLayout = gridParent.gameObject.AddComponent<GridLayoutGroup>();

        gridLayout.cellSize = new Vector2(80, 80);
        gridLayout.spacing = new Vector2(5, 5);
        gridLayout.constraint = GridLayoutGroup.Constraint.FixedColumnCount;
        gridLayout.constraintCount = gridSize;

        gridCells = new TableCell[gridSize, gridSize];

        for (int i = 0; i < gridSize * gridSize; i++)
        {
            GameObject cell = Instantiate(cellPrefab, gridParent);
            TableCell tableCell = cell.GetComponent<TableCell>();

            int row = i / gridSize;
            int col = i % gridSize;
            gridCells[row, col] = tableCell;
        }
    }

    void CreateNumbers()
    {
        foreach (Transform child in numbersPanel)
            Destroy(child.gameObject);

        for (int i = 1; i <= 9; i++)
        {
            GameObject number = Instantiate(numberPrefab, numbersPanel);
            number.GetComponentInChildren<Text>().text = i.ToString();
        }
    }

    void SetupInitialValues()
    {
        for (int i = 0; i < gridSize * gridSize && i < initialGrid.Length; i++)
        {
            int row = i / gridSize;
            int col = i % gridSize;
            int value = int.Parse(initialGrid[i].ToString());

            if (gridCells[row, col] != null)
            {
                if (value > 0)
                {
                    gridCells[row, col].GetComponentInChildren<Text>().text = value.ToString();
                    gridCells[row, col].currentValue = value;
                    gridCells[row, col].isLocked = true;
                }
                else
                {
                    gridCells[row, col].GetComponentInChildren<Text>().text = "";
                    gridCells[row, col].currentValue = 0;
                    gridCells[row, col].isLocked = false;
                }
            }
        }
        statusIndicator.color = Color.red;
    }

    public void ResetGrid()
    {
        SetupInitialValues();
    }

    public void CheckSolution()
    {
        bool isSolved = true;

        for (int row = 0; row < gridSize; row++)
        {
            int rowSum = 0;
            for (int col = 0; col < gridSize; col++)
            {
                if (gridCells[row, col] != null)
                {
                    rowSum += gridCells[row, col].currentValue;
                }
            }
            if (rowSum != targetSum)
            {
                isSolved = false;
                break;
            }
        }

        if (isSolved)
        {
            for (int col = 0; col < gridSize; col++)
            {
                int colSum = 0;
                for (int row = 0; row < gridSize; row++)
                {
                    if (gridCells[row, col] != null)
                    {
                        colSum += gridCells[row, col].currentValue;
                    }
                }
                if (colSum != targetSum)
                {
                    isSolved = false;
                    break;
                }
            }
        }

        if (isSolved)
        {
            statusIndicator.color = Color.green;
            Invoke("EndMiniGame", 1.5f);
        }
        else
        {
            statusIndicator.color = Color.red;
        }
    }

    void EndMiniGame()
    {
        if (playerController != null)
        {
            playerController.enabled = true;
        }

        gamePanel.SetActive(false);

        if (treeAnimator != null && treeAnimation != null)
        {
            treeAnimator.enabled = true;
            treeAnimator.Play(treeAnimation.name);
        }
    }

}

--- Путь к файлу: .\Scripts\SudokuMiniGame\SudokuMiniGameTrigger.cs ---

using UnityEngine;

public class SudokuMiniGameTrigger : MonoBehaviour
{
    [Header("  ")]
    public bool workOnlyOnce = false;
    public bool startOnEnter = true;
    public bool requirePressE = false;

    bool inRange = false;
    bool alreadyUsed = false;

    void OnTriggerEnter2D(Collider2D other)
    {
        if (alreadyUsed && workOnlyOnce) return;
        if (other.CompareTag("Player"))
        {
            inRange = true;
            if (startOnEnter && !requirePressE) StartGame();
            else if (requirePressE) UIInteractPrompt.Instance.Show(" E");

        }
    }

    void OnTriggerExit2D(Collider2D other)
    {
        if (other.CompareTag("Player"))
        {
            inRange = false;
            UIInteractPrompt.Instance.Hide();
        }
    }

    void Update()
    {
        if(inRange && requirePressE && Input.GetKeyDown(KeyCode.E))
        {
            UIInteractPrompt.Instance.Hide();
            StartGame();
        }
    }

    void StartGame()
    {
        if (workOnlyOnce)
        {
            alreadyUsed = true;
            inRange = false;
        }

        GameManager.Instance.StartMiniGame();
    }
}


--- Путь к файлу: .\Scripts\SudokuMiniGame\TableCell.cs ---

﻿using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;

public class TableCell : MonoBehaviour, IDropHandler
{
    private Text numberText;
    public int currentValue;
    public bool isLocked = false; 

    void Start()
    {
        numberText = GetComponentInChildren<Text>();
    }

    public void OnDrop(PointerEventData eventData)
    {
        if (isLocked) return;

        GameObject draggedNumber = eventData.pointerDrag;
        if (draggedNumber == null) return;

        DraggableNumber draggable = draggedNumber.GetComponent<DraggableNumber>();
        if (draggable != null)
        {
            numberText.text = draggable.numberValue.ToString();
            currentValue = draggable.numberValue;
            FindObjectOfType<GameManager>().CheckSolution();
        }
    }
}

--- Путь к файлу: .\Scripts\UI\CutSceneTrigger.cs ---

using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Video;

public class CutSceneTrigger : MonoBehaviour
{
    public Canvas canvas;
    public VideoPlayer videoPlayer;

    private MonoBehaviour playerController;
    private bool used = false;

    private void Start()
    {
        playerController = FindObjectOfType<PlayerMovement>();
    }

    private void OnTriggerEnter2D(Collider2D other)
    {
        if (used) return;
        if (!other.CompareTag("Player")) return;

        used = true;
        canvas.gameObject.SetActive(true);

        if (playerController != null)
            playerController.enabled = false;

        videoPlayer.Play();
        videoPlayer.loopPointReached += OnVideoFinished;
    }

    private void OnVideoFinished(VideoPlayer vp)
    {
        canvas.enabled = false;

        if (playerController != null)
            playerController.enabled = true;
    }
}



--- Путь к файлу: .\Scripts\UI\MenuManager.cs ---

using UnityEngine;
using UnityEngine.UI;
using UnityEngine.SceneManagement;

public class MenuManager : MonoBehaviour
{
    [Header(" ")]
    public GameObject mainMenuPanel;
    public Button continueButton;
    public Button newGameButton;
    public Button settingsButton;
    public Button exitButton;

    [Header(" ")]
    public GameObject settingsPanel;
    public Button backButton;

    [Header("")]
    public string gameSceneName = "GameScene";

    void Start()
    {
        mainMenuPanel.SetActive(true);
        settingsPanel.SetActive(false);

        continueButton.onClick.AddListener(OnContinueButton);
        newGameButton.onClick.AddListener(OnNewGameButton);
        settingsButton.onClick.AddListener(OnSettingsButton);
        exitButton.onClick.AddListener(OnExitButton);

        backButton.onClick.AddListener(OnBackButton);

        UpdateContinueButton();
    }

    void UpdateContinueButton()
    {
        bool hasSave = SaveSystem.HasSaveData();
        continueButton.gameObject.SetActive(hasSave);
    }

    public void OnContinueButton()
    {
        if (SaveSystem.HasSaveData())
        {
            //       
            if (GameSaveManager.Instance != null)
            {
                GameSaveManager.Instance.LoadGame();
            }
            else
            {
                //       ,     Find
                GameSaveManager manager = FindObjectOfType<GameSaveManager>();
                if (manager != null)
                {
                    manager.LoadGame();
                }
                else
                {
                    Debug.LogError(" : GameSaveManager      !");
                }
            }
        }
    }

    public void OnNewGameButton()
    {
        if (GameSaveManager.Instance != null)
        {
            //    
            GameSaveManager.Instance.PrepareNewGame();
        }

        //   
        UnityEngine.SceneManagement.SceneManager.LoadScene(gameSceneName);
    }

    public void OnSettingsButton()
    {
        mainMenuPanel.SetActive(false);
        settingsPanel.SetActive(true);
    }

    public void OnBackButton()
    {
        mainMenuPanel.SetActive(true);
        settingsPanel.SetActive(false);
    }

    public void OnExitButton()
    {

        #if UNITY_EDITOR
        UnityEditor.EditorApplication.isPlaying = false;
        #else

        Application.Quit();
        #endif
    }
}

--- Путь к файлу: .\Scripts\UI\PanelController.cs ---

using UnityEngine;
using UnityEngine.SceneManagement;
public class PanelController : MonoBehaviour
{
    [Header("")]
    public GameObject panel;
    public string sceneName;

    [Header(" ")]
    public bool workOnlyOnce = false;
    private string playerTag = "Player";

    [Header(" ")]
    public bool disablePlayerControl = true;

    public bool goToMenu = false;

    private PlayerMovement playerController;
    private bool alreadyTriggered = false;

    void Start()
    {
        playerController = FindObjectOfType<PlayerMovement>();

        if (panel != null)
            panel.SetActive(false);
    }

    private void OnTriggerEnter2D(Collider2D other)
    {
        if (other.CompareTag(playerTag) && (!workOnlyOnce || !alreadyTriggered))
        {
            if (panel != null)
                panel.SetActive(true);

            if (disablePlayerControl && playerController != null)
                playerController.enabled = false;

            if (goToMenu)
            {
                Invoke("LoadMenu", 5f);
            }

            alreadyTriggered = true;
        }
    }

    public void LoadMenu()
    {
        SceneManager.LoadScene(sceneName);
    }

    public void HidePanel()
    {
        if (panel != null)
            panel.SetActive(false);

        if (disablePlayerControl && playerController != null)
            playerController.enabled = true;
    }

    public void ResetTrigger()
    {
        alreadyTriggered = false;
    }
}

--- Путь к файлу: .\Scripts\UI\PauseManager.cs ---

using UnityEngine;
using UnityEngine.UI;

public class PauseManager : MonoBehaviour
{
    [Header("")]
    public GameObject pausePanel;
    public GameObject settingsPanel;

    [Header(" ")]
    public Button settingsButton;
    public Button continueButton;
    public Button menuButton;

    [Header("   ")]
    public Button backButton;

    private bool isPaused = false;

    void Start()
    {
        pausePanel.SetActive(false);
        settingsPanel.SetActive(false);

        settingsButton.onClick.AddListener(OpenSettings);
        continueButton.onClick.AddListener(ContinueGame);
        menuButton.onClick.AddListener(GoToMainMenu);
        backButton.onClick.AddListener(CloseSettings);
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            if (isPaused)
            {
                if (settingsPanel.activeSelf)
                {
                    CloseSettings();
                }
                else
                {
                    ContinueGame();
                }
            }
            else
            {
                PauseGame();
            }
        }
    }

    public void SaveGameButton()
    {
        if (GameSaveManager.Instance != null)
        {
            GameSaveManager.Instance.SaveGame();
        }
        else
        {
            Debug.LogError("  : GameSaveManager    !");
        }
    }

    void PauseGame()
    {
        isPaused = true;
        Time.timeScale = 0f;

        pausePanel.SetActive(true);
        settingsPanel.SetActive(false);

        Debug.Log("  ");
    }

    void ContinueGame()
    {
        isPaused = false;
        Time.timeScale = 1f;

        pausePanel.SetActive(false);
        settingsPanel.SetActive(false);

        Debug.Log(" ");
    }

    void OpenSettings()
    {
        pausePanel.SetActive(false);
        settingsPanel.SetActive(true);
    }

    void CloseSettings()
    {
        settingsPanel.SetActive(false);
        pausePanel.SetActive(true);
    }

    void GoToMainMenu()
    {
        Time.timeScale = 1f;
        UnityEngine.SceneManagement.SceneManager.LoadScene("MainMenu");
    }
}

--- Путь к файлу: .\Scripts\UI\SettingsManager.cs ---

using UnityEngine;
using UnityEngine.UI;

public class SettingsManager : MonoBehaviour
{
    [Header(" ")]
    public Slider volumeSlider;

    [Header("UI ")]
    public GameObject settingsPanel;
    public Button backButton;

    //    Unity   TMPro.TMP_Dropdown, 
    //        
    private Dropdown screenModeDropdown;

    void Start()
    {
        screenModeDropdown = settingsPanel.GetComponentInChildren<Dropdown>();

        // 1.  .      0.5f (50%)
        float savedVolume = PlayerPrefs.GetFloat("MasterVolume", 0.5f);

        if (volumeSlider != null)
        {
            //      
            volumeSlider.minValue = 0f;
            volumeSlider.maxValue = 1f;

            //     
            volumeSlider.value = savedVolume;

            //         
            AudioListener.volume = savedVolume;

            //   
            volumeSlider.onValueChanged.AddListener(SetMasterVolume);
        }

        if (screenModeDropdown != null)
        {
            screenModeDropdown.value = Screen.fullScreen ? 0 : 1;
            screenModeDropdown.onValueChanged.AddListener(SetFullscreen);
        }

        if (backButton != null)
            backButton.onClick.AddListener(CloseSettings);
    }

    public void SetMasterVolume(float volume)
    {
        //    
        AudioListener.volume = volume;
        //  
        PlayerPrefs.SetFloat("MasterVolume", volume);
    }

    public void SetFullscreen(int isFullscreen)
    {
        bool fullscreen = (isFullscreen == 0);
        Screen.fullScreen = fullscreen;
    }

    public void CloseSettings()
    {
        //    PlayerPrefs  
        PlayerPrefs.Save();

        if (settingsPanel != null)
            settingsPanel.SetActive(false);
    }

    public void OpenSettings()
    {
        if (settingsPanel != null)
            settingsPanel.SetActive(true);

        //     
        if (volumeSlider != null)
        {
            volumeSlider.value = PlayerPrefs.GetFloat("MasterVolume", 0.5f);
        }
    }
}

