--- Путь к файлу: .\Assets\Game\DepthSorter.cs ---

using UnityEngine;

[ExecuteInEditMode]
public class DepthSorter : MonoBehaviour
{
    //   ,    
    private const float Z_FACTOR = 0.001f;

    void Update()
    {
        Vector3 pos = transform.position;
        //    ( Y),      ( Z)
        pos.z = pos.y * Z_FACTOR;
        transform.position = pos;
    }
}

--- Путь к файлу: .\Assets\Game\StaticDepthSorter.cs ---

using UnityEngine;

public class StaticDepthSorter : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}


--- Путь к файлу: .\Assets\Game\Scripts\GoToScene.cs ---

﻿using UnityEngine;
using UnityEngine.SceneManagement;

public class GoToScene : MonoBehaviour
{
	public string sceneName;

	void OnTriggerEnter2D(Collider2D other)
	{
		if (other.CompareTag("Player"))
		{
			SceneManager.LoadScene(sceneName);
		}
	}
}

--- Путь к файлу: .\Assets\Game\Scripts\PlayerMovement.cs ---

using UnityEngine;

public class PlayerMovement : MonoBehaviour
{
    [Header("")]
    public Sprite frontsprite;
    public Sprite backsprite;
    public Sprite rightsprite;
    public Sprite leftsprite;
    public SpriteRenderer spriterenderer;

    public float runSpeed = 10f;
    public float moveSpeed = 5f;

    private Rigidbody2D rb;
    private Vector2 movement;

    void Start()
    {
        rb = GetComponent<Rigidbody2D>();
    }

    void Update()
    {
        movement.x = Input.GetKey(KeyCode.D) ? 1 : Input.GetKey(KeyCode.A) ? -1 : 0;

        movement.y = Input.GetKey(KeyCode.W) ? 1 : Input.GetKey(KeyCode.S) ? -1 : 0;

        if (Input.GetKey(KeyCode.D))
        {
            spriterenderer.sprite = rightsprite;

        }
        else
        {
            if (Input.GetKey(KeyCode.A))
            {
                spriterenderer.sprite = leftsprite;
            }
            else
            {
                if (Input.GetKey(KeyCode.W))
                {
                    spriterenderer.sprite = backsprite;

                }
                else
                {
                    if (Input.GetKey(KeyCode.S))
                    {
                        spriterenderer.sprite = frontsprite;
                    }
                }
            }
        }

        movement = movement.normalized;
    }

    void FixedUpdate()
    {
        if (Input.GetKey(KeyCode.LeftShift))
        {
            rb.MovePosition(rb.position + movement * runSpeed * Time.fixedDeltaTime);
            return;
        }
        else
        {
            rb.MovePosition(rb.position + movement * moveSpeed * Time.fixedDeltaTime);
        }

            
        
            
    }
}


--- Путь к файлу: .\Assets\Game\Scripts\QuestsManager.cs ---

using UnityEngine;
using System.Collections.Generic;
using TMPro;          
using UnityEngine.UI; 

[System.Serializable]
public class Quest
{
    public string id;            
    public string description;   
    public bool isCompleted;     

    public string requiredItemID; 
    public int requiredAmount;  
    public int currentAmount;    

    public Quest(string id, string desc, string itemID = "", int amount = 0)
    {
        this.id = id;
        this.description = desc;
        this.requiredItemID = itemID;
        this.requiredAmount = amount;
        this.isCompleted = false;
        this.currentAmount = 0;
    }

    public string GetDisplayText()
    {
        if (string.IsNullOrEmpty(requiredItemID) || isCompleted)
        {
            return description;
        }

        else
        {
            return $"{description} ({currentAmount}/{requiredAmount})";
        }
    }
}

public class QuestsManager : MonoBehaviour
{
    public static QuestsManager Instance;

    [Header("  (UI)")]
    public GameObject questPanel;    
    public Transform choicesPanel;      
    public GameObject questButtonPrefab; 

    [Header("   (HUD)")]
    public TMP_Text activeQuestHUD;    

    public List<Quest> allQuests = new List<Quest>();

    private Quest trackedQuest;

    private MonoBehaviour playerController;

    void Awake()
    {
        Instance = this;
        if (activeQuestHUD != null) activeQuestHUD.text = "";
        playerController = FindObjectOfType<PlayerMovement>();
    }

    void Start()
    {
        InventoryManager.OnInventoryChanged += OnInventoryUpdate;
    }

    void OnDestroy()
    {
        InventoryManager.OnInventoryChanged -= OnInventoryUpdate;
    }

    void Update()
    {
        if (!DialogueManager.Instance.IsPlaying())
        {
            if (Input.GetKeyDown(KeyCode.J))
            {
                ToggleQuestsList();
            }
        }

        if (DialogueManager.Instance.IsPlaying() && questPanel.activeInHierarchy)
        {
            questPanel.SetActive(false);
            DeleteQuestsList();
        }

    }

    private void OnInventoryUpdate(InventorySlot[] slots)
    {
        bool needsUpdate = false;

        foreach (var quest in allQuests)
        {
            if (!quest.isCompleted && !string.IsNullOrEmpty(quest.requiredItemID))
            {
                int count = InventoryManager.Instance.GetItemCount(quest.requiredItemID);

                if (quest.currentAmount != count)
                {
                    quest.currentAmount = count;
                    needsUpdate = true;
                }
            }
        }

        if (needsUpdate)
        {
            UpdateHUD();
            if (questPanel.activeInHierarchy) ShowQuestsInJournal();
        }
    }

    public void ToggleQuestsList()
    {
        bool isActive = questPanel.activeInHierarchy;
        if (isActive)
        {
            if (playerController != null) playerController.enabled = true;
            questPanel.SetActive(false);
            DeleteQuestsList();
        }
        else
        {
            if (playerController != null) playerController.enabled = false;
            questPanel.SetActive(true);
            ShowQuestsInJournal();
        }

    }

    public void AddQuest(string id, string desc, string itemID = "", int amount = 0)
    {
        if (allQuests.Exists(x => x.id == id)) return;

        Quest newQuest = new Quest(id, desc, itemID, amount);

        if (!string.IsNullOrEmpty(itemID))
        {
            newQuest.currentAmount = InventoryManager.Instance.GetItemCount(itemID);
        }

        allQuests.Add(newQuest);

        TrackQuest(newQuest);
    }

    public void CompleteQuest(string id)
    {
        Quest quest = allQuests.Find(x => x.id == id);
        if (quest != null)
        {
            quest.isCompleted = true;

            if (trackedQuest == quest)
            {
                activeQuestHUD.text = "";
                trackedQuest = null;
            }

            if (questPanel.activeInHierarchy) ShowQuestsInJournal();
        }
    }

    public void TrackQuest(Quest quest)
    {
        if (quest.isCompleted) return;

        trackedQuest = quest;
        UpdateHUD();
    }

    private void UpdateHUD()
    {
        if (activeQuestHUD == null) return;

        if (trackedQuest != null && !trackedQuest.isCompleted)
        {
            activeQuestHUD.text = trackedQuest.GetDisplayText();
        }
        else
        {
            activeQuestHUD.text = "";
        }
    }

    public void ShowQuestsInJournal()
    {
        DeleteQuestsList();

        foreach (Quest quest in allQuests)
        {
            GameObject buttonObj = Instantiate(questButtonPrefab, choicesPanel);
            TMP_Text buttonText = buttonObj.GetComponentInChildren<TMP_Text>();
            Button btn = buttonObj.GetComponent<Button>();

            if (quest.isCompleted)
            {

                buttonText.text = $"<s>{quest.description}</s> <color=black></color>";
                buttonText.color = Color.gray;
                btn.interactable = false; 
            }
            else
            {

                buttonText.text = quest.GetDisplayText();
                if (trackedQuest == quest) buttonText.color = Color.black;

                else buttonText.color = Color.white;


                btn.onClick.AddListener(() => {
                    TrackQuest(quest);
                    ShowQuestsInJournal();
                });
            }
        }
    }

    public void DeleteQuestsList()
    {
        foreach (Transform child in choicesPanel)
        {
            Destroy(child.gameObject);
        }
    }
}

--- Путь к файлу: .\Assets\Game\Scripts\SceneTransition.cs ---

﻿using UnityEngine;
using UnityEngine.SceneManagement;

public class SceneTransition : MonoBehaviour
{
    [Header("����� �����")]
    public int sceneNumber;
    public void Transition()
    {
        SceneManager.LoadScene(sceneNumber);
    }
}


--- Путь к файлу: .\Assets\Game\Scripts\Teleport.cs ---

﻿using UnityEngine;

public class Teleport : MonoBehaviour
{
	public Transform targetPosition;

	void OnTriggerEnter2D(Collider2D other)
	{
		if (other.CompareTag("Player"))
		{
			other.transform.position = targetPosition.position;
		}
	}
}


--- Путь к файлу: .\Assets\Game\Scripts\Dialogues\AnimatorAutoDisable.cs ---

﻿using UnityEngine;

public class AnimationAutoDisable : MonoBehaviour
{
    private Animator animator;

    void Awake()
    {
        animator = GetComponent<Animator>();
    }

    public void OnAnimationFinished()
    {
        if (animator != null)
        {
            animator.enabled = false; 
        }
    }
}


--- Путь к файлу: .\Assets\Game\Scripts\Dialogues\DialogueManager.cs ---

﻿using Ink.Runtime;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;
using TMPro;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class DialogueManager : MonoBehaviour
{
    public static DialogueManager Instance;

    [Header("UI")]
    public GameObject dialoguePanel;
    public TMP_Text dialogueText;

    [Header("Speaker UI")]
    public Image portraitLeft;
    public TMP_Text nameLeft;
    public Image portraitRight;
    public TMP_Text nameRight;

    [Header("Choices")]
    public Transform choicesContainer;
    public GameObject choiceButtonPrefab;

    private Story story;
    private bool isPlaying = false;
    private NPCData currentNPC;
    private MonoBehaviour playerController;

    private Dictionary<string, object> globalVariables = new Dictionary<string, object>();

    void Awake()
    {
        Instance = this;
        if (choicesContainer != null) choicesContainer.gameObject.SetActive(false);
        if (dialoguePanel != null) dialoguePanel.SetActive(false);

        playerController = FindObjectOfType<PlayerMovement>();
    }

    void Update()
    {
        if (!isPlaying) return;

        if (Input.GetMouseButtonDown(0) || Input.GetKeyDown(KeyCode.Space) || Input.GetKeyDown(KeyCode.Return))
        {
            if (EventSystem.current.IsPointerOverGameObject()) return;

            ContinueDialogue();
        }
    }

    public void StartDialogue(TextAsset inkJSON, string startKnot = null, NPCData npcData = null)
    {
        if (isPlaying) return;

        if (playerController != null) playerController.enabled = false;

        story = new Story(inkJSON.text);
        currentNPC = npcData;

        RestoreGlobalVariables();

        UpdatePlayerStateVariables();

        if (!string.IsNullOrEmpty(startKnot))
        {
            story.ChoosePathString(startKnot);
        }

        if (npcData != null)
        {
            SetDefaultSpeaker(npcData);
        }

        dialoguePanel.SetActive(true);
        isPlaying = true;

        ContinueDialogue();
    }

    private void UpdatePlayerStateVariables()
    {
        if (story == null) return;

        List<string> variableNames = new List<string>();
        foreach (string varName in story.variablesState)
        {
            variableNames.Add(varName);
        }

        foreach (string varName in variableNames)
        {
            if (varName.StartsWith("has_item_"))
            {
                string[] parts = varName.Split('_');
                if (parts.Length >= 4)
                {
                    string itemId = parts[2];
                    if (int.TryParse(parts[3], out int requiredAmount))
                    {
                        bool hasItem = CheckActiveSlotForItem(itemId, requiredAmount);
                        story.variablesState[varName] = hasItem;
                    }
                }
            }
        }
    }

    private bool CheckActiveSlotForItem(string itemId, int requiredAmount)
    {
        if (InventoryManager.Instance == null) return false;

        int amountInHand = InventoryManager.Instance.GetActiveSlotItemCount(itemId);
        return amountInHand >= requiredAmount;
    }

    private void RestoreGlobalVariables()
    {
        foreach (var variable in globalVariables)
        {
            if (story.variablesState.Contains(variable.Key))
            {
                try
                {
                    story.variablesState[variable.Key] = variable.Value;
                }
                catch
                {
                }
            }
        }
    }

    private void SaveGlobalVariables()
    {
        if (story == null) return;

        List<string> variableNames = new List<string>();
        foreach (string variableName in story.variablesState)
        {
            variableNames.Add(variableName);
        }

        foreach (string variableName in variableNames)
        {
            globalVariables[variableName] = story.variablesState[variableName];
        }
    }

    public void ContinueDialogue()
    {
        foreach (Transform child in choicesContainer) Destroy(child.gameObject);

        if (story.canContinue)
        {
            string text = story.Continue();
            dialogueText.text = text.Trim();

            ProcessAllTags();
            ApplyVisualTags();
        }
        else if (story.currentChoices.Count > 0)
        {
            ShowChoices();
        }
        else
        {
            EndDialogue();
        }
    }

    private void ProcessAllTags()
    {
        List<string> currentTags = story.currentTags;
        Dictionary<string, List<string>> actions = new Dictionary<string, List<string>>();
        string currentAction = "";

        foreach (string tag in currentTags)
        {
            if (tag.StartsWith("action:"))
            {
                currentAction = tag.Substring(7).Trim();
                actions[currentAction] = new List<string>();
            }
            else if (!string.IsNullOrEmpty(currentAction) && tag.Contains(":"))
            {
                actions[currentAction].Add(tag);
            }
            else if (tag.StartsWith("set_"))
            {
                ProcessSetTag(tag);
            }
        }

        foreach (var action in actions)
        {
            ExecuteAction(action.Key, action.Value);
        }
    }

    private void ExecuteAction(string actionType, List<string> parameters)
    {
        switch (actionType)
        {
            case "give_item":
                GiveItemAction(parameters);
                break;
            case "take_item":
                TakeItemAction(parameters);
                break;
            case "quest_add":
                AddQuestAction(parameters);
                break;
            case "quest_add_item":
                AddQuestItemAction(parameters);
                break;
            case "quest_complete":
                CompleteQuestAction(parameters);
                break;
            case "activate_trigger":
                ActivateTriggerAction(parameters);
                break;
            case "deactivate_object":
                DeactivateObjectAction(parameters);
                break;
            case "start_animation":
                StartAnimationAction(parameters);
                break;
            case "quest_text":
                QuestTextAction(parameters);
                break;
            case "change_scene":
                ChangeSceneAction(parameters);
                break;
            case "animation_name":
                TeleportPlayerAction(parameters);
                break;
            case "unlock_ability":
                UnlockAbilityAction(parameters);
                break;
            default:
                Debug.LogWarning($"Неизвестное действие: {actionType}");
                break;
        }
    }

    private void AddQuestAction(List<string> parameters)
    {
        string id = GetParameterValue(parameters, "id");
        string desc = GetParameterValue(parameters, "desc");

        if (!string.IsNullOrEmpty(id) && QuestsManager.Instance != null)
        {
            QuestsManager.Instance.AddQuest(id, desc);
        }
    }

    private void AddQuestItemAction(List<string> parameters)
    {
        string id = GetParameterValue(parameters, "id");
        string desc = GetParameterValue(parameters, "desc");
        string itemId = GetParameterValue(parameters, "item_id");
        int amount = GetIntParameterValue(parameters, "amount", 1);

        if (!string.IsNullOrEmpty(id) && QuestsManager.Instance != null)
        {
            QuestsManager.Instance.AddQuest(id, desc, itemId, amount);
        }
    }

    private void CompleteQuestAction(List<string> parameters)
    {
        string id = GetParameterValue(parameters, "id");
        if (!string.IsNullOrEmpty(id) && QuestsManager.Instance != null)
        {
            QuestsManager.Instance.CompleteQuest(id);
        }
    }

    private void GiveItemAction(List<string> parameters)
    {
        string itemId = GetParameterValue(parameters, "item_id");
        int amount = GetIntParameterValue(parameters, "amount", 1);
        if (!string.IsNullOrEmpty(itemId)) InventoryManager.Instance.AddItem(itemId, amount);
    }

    private void TakeItemAction(List<string> parameters)
    {
        string itemId = GetParameterValue(parameters, "item_id");
        int amount = GetIntParameterValue(parameters, "amount", 1);
        if (!string.IsNullOrEmpty(itemId)) InventoryManager.Instance.RemoveItemFromActiveSlot(itemId, amount);
    }

    private void ActivateTriggerAction(List<string> parameters)
    {
        string triggerName = GetParameterValue(parameters, "trigger_name");
        GameObject trigger = GameObject.Find(triggerName);
        if (trigger != null && trigger.GetComponent<Collider2D>()) trigger.GetComponent<Collider2D>().enabled = true;
    }

    private void DeactivateObjectAction(List<string> parameters)
    {
        string objectName = GetParameterValue(parameters, "object_name");
        GameObject obj = GameObject.Find(objectName);
        if (obj != null) obj.SetActive(false);
    }

    private void StartAnimationAction(List<string> parameters)
    {
        string animationName = GetParameterValue(parameters, "animation_name");
        string animationNames = GetParameterValue(parameters, "animation_names");

        if (!string.IsNullOrEmpty(animationNames))
        {
            string[] names = animationNames.Split(',');
            AnimationManager.Instance.PlayMultipleAnimations(names);
        }
        else if (!string.IsNullOrEmpty(animationName))
        {
            AnimationManager.Instance.PlayAnimation(animationName);
        }
    }

    private void QuestTextAction(List<string> parameters)
    {
    }

    private void ChangeSceneAction(List<string> parameters)
    {
        string sceneName = GetParameterValue(parameters, "scene_name");
        if (!string.IsNullOrEmpty(sceneName)) UnityEngine.SceneManagement.SceneManager.LoadScene(sceneName);
    }

    private void TeleportPlayerAction(List<string> parameters)
    {
    }

    private void UnlockAbilityAction(List<string> parameters)
    {
    }

    private string GetParameterValue(List<string> parameters, string key)
    {
        foreach (string param in parameters)
        {
            if (param.Trim().StartsWith(key + ":"))
            {
                return param.Trim().Substring(key.Length + 1).Trim();
            }
        }
        return "";
    }

    private int GetIntParameterValue(List<string> parameters, string key, int defaultValue)
    {
        string value = GetParameterValue(parameters, key);
        return int.TryParse(value, out int result) ? result : defaultValue;
    }

    private void ProcessSetTag(string tag)
    {
        string[] parts = tag.Split(' ');
        if (parts.Length == 2)
        {
            string varName = parts[0].Substring(4);
            string value = parts[1].ToLower();

            if (value == "true") story.variablesState[varName] = true;
            else if (value == "false") story.variablesState[varName] = false;
            else story.variablesState[varName] = value;
        }
    }

    private void ApplyVisualTags()
    {
        portraitLeft.gameObject.SetActive(false);
        portraitRight.gameObject.SetActive(false);
        nameLeft.gameObject.SetActive(false);
        nameRight.gameObject.SetActive(false);

        foreach (string tag in story.currentTags)
        {
            if (tag == "side:left")
            {
                portraitLeft.gameObject.SetActive(true);
                nameLeft.gameObject.SetActive(true);
            }
            else if (tag == "side:right")
            {
                portraitRight.gameObject.SetActive(true);
                nameRight.gameObject.SetActive(true);
            }
            else if (tag.StartsWith("speaker:"))
            {
                string speakerName = tag.Substring(8).Trim();
                if (portraitLeft.gameObject.activeSelf) nameLeft.text = speakerName;
                if (portraitRight.gameObject.activeSelf) nameRight.text = speakerName;
            }
            else if (tag.StartsWith("portrait:"))
            {
                string portraitName = tag.Substring(9).Trim();
                Sprite sprite = Resources.Load<Sprite>("Portraits/" + portraitName);
                if (sprite != null)
                {
                    if (portraitLeft.gameObject.activeSelf) portraitLeft.sprite = sprite;
                    if (portraitRight.gameObject.activeSelf) portraitRight.sprite = sprite;
                }
            }
        }
    }

    private void SetDefaultSpeaker(NPCData npcData)
    {
        portraitLeft.gameObject.SetActive(true);
        nameLeft.gameObject.SetActive(true);
        nameLeft.text = npcData.npcName;
        if (npcData.portrait != null) portraitLeft.sprite = npcData.portrait;
    }

    private void ShowChoices()
    {
        choicesContainer.gameObject.SetActive(true);
        for (int i = 0; i < story.currentChoices.Count; i++)
        {
            Choice choice = story.currentChoices[i];
            GameObject button = Instantiate(choiceButtonPrefab, choicesContainer);
            TMP_Text buttonText = button.GetComponentInChildren<TMP_Text>();
            buttonText.text = choice.text;

            Button btn = button.GetComponent<Button>();
            int choiceIndex = i;
            btn.onClick.AddListener(() => {
                story.ChooseChoiceIndex(choiceIndex);
                ContinueDialogue();
            });
        }
    }

    private void EndDialogue()
    {
        SaveGlobalVariables();

        isPlaying = false;
        dialoguePanel.SetActive(false);
        choicesContainer.gameObject.SetActive(false);

        if (playerController != null) playerController.enabled = true;
        currentNPC = null;
    }

    public bool IsPlaying() => isPlaying;
}

--- Путь к файлу: .\Assets\Game\Scripts\Dialogues\DialogueTrigger.cs ---

﻿using Ink.Runtime;
using System.Xml.Linq;
using UnityEngine;

public class DialogueTrigger : MonoBehaviour
{
    [Header("NPC Settings")]
    public NPCData npcData;

    [Header("Trigger Settings")]
    public bool workOnlyOnce = false;
    public bool startOnEnter = false;
    public bool requirePressE = true;

    private bool inRange = false;
    private bool alreadyUsed = false;

    void OnTriggerEnter2D(Collider2D other)
    {
        if (alreadyUsed && workOnlyOnce) return;
        if (other.CompareTag("Player"))
        {
            inRange = true;
            if (startOnEnter && !requirePressE)
                StartDialogue();
            else if (requirePressE)
                UIInteractPrompt.Instance.Show("Нажми E");
        }
    }

    void OnTriggerExit2D(Collider2D other)
    {
        if (other.CompareTag("Player"))
        {
            inRange = false;
            UIInteractPrompt.Instance.Hide();
        }
    }

    void Update()
    {
        if (inRange && requirePressE && Input.GetKeyDown(KeyCode.E))
        {
            if (DialogueManager.Instance != null && DialogueManager.Instance.IsPlaying())
            {
                return;
            }

            UIInteractPrompt.Instance.Hide();
            StartDialogue();
        }
    }

    void StartDialogue()
    {
        if (workOnlyOnce)
        {
            alreadyUsed = true;
            inRange = false;
        }

        DialogueManager.Instance.StartDialogue(npcData.inkFile, "start", npcData);
    }

    public void ResetMeeting()
    {
        alreadyUsed = false;
    }
}

--- Путь к файлу: .\Assets\Game\Scripts\Dialogues\ForestExitTrigger.cs ---

using UnityEngine;
using System.Collections;
using TMPro;

public class ForestExitTrigger : MonoBehaviour
{
    [Header(" ")]
    public Transform returnPoint;

    [Header("")]
    public TextAsset[] dialogues;

    [Header(" ")]
    public float moveSpeed = 3f;
    public int maxAttempts = 3;
    public bool enableQuickTimeEvent = true;

    [Header("  ")]
    public float requiredPresses = 10f;
    public float moveDistancePerPress = 0.2f;
    public float timeLimit = 3f;

    [Header("UI ")]
    public TextMeshProUGUI quickTimeText;

    private int exitAttempts = 0;
    private PlayerMovement playerController;
    private SpriteRenderer playerSprite;
    private bool isReturning = false;
    private bool quickTimeActive = false;
    private float currentPresses = 0f;
    private float quickTimeTimer = 0f;
    private Vector3 quickTimeStartPosition;
    private Vector3 quickTimeTargetPosition;

    void Start()
    {
        playerController = FindObjectOfType<PlayerMovement>();
        GameObject player = GameObject.FindGameObjectWithTag("Player");
        playerSprite = player.GetComponent<SpriteRenderer>();

        if (quickTimeText != null)
            quickTimeText.gameObject.SetActive(false);
    }

    private void OnTriggerEnter2D(Collider2D other)
    {
        if (other.CompareTag("Player") && exitAttempts < maxAttempts && !isReturning && !quickTimeActive)
        {
            exitAttempts++;

            if (exitAttempts == maxAttempts && enableQuickTimeEvent)
            {
                StartQuickTimeEvent(other.gameObject);
            }
            else
            {
                StartCoroutine(ReturnPlayer(other.gameObject));
            }
        }
    }

    void StartQuickTimeEvent(GameObject player)
    {
        quickTimeActive = true;
        currentPresses = 0f;
        quickTimeTimer = timeLimit;

        quickTimeStartPosition = player.transform.position;
        quickTimeTargetPosition = returnPoint.position;

        if (quickTimeText != null)
        {
            quickTimeText.text = $"  A! {currentPresses}/{requiredPresses}";
            quickTimeText.gameObject.SetActive(true);
        }

        if (playerController != null)
            playerController.enabled = false;
    }

    void Update()
    {
        if (quickTimeActive)
        {
            quickTimeTimer -= Time.deltaTime;

            if (Input.GetKeyDown(KeyCode.A))
            {
                OnQuickTimePress();
            }

            UpdateQuickTimeUI();

            if (currentPresses >= requiredPresses)
            {
                QuickTimeSuccess();
            }
            else if (quickTimeTimer <= 0f)
            {
                QuickTimeFail();
            }
        }
    }

    void OnQuickTimePress()
    {
        currentPresses++;

        GameObject player = GameObject.FindGameObjectWithTag("Player");
        if (player != null)
        {
            player.transform.position += Vector3.left * moveDistancePerPress;

            playerSprite.sprite = playerController.leftsprite;
        }
    }

    void UpdateQuickTimeUI()
    {
        if (quickTimeText != null)
        {
            quickTimeText.text = $"  A! {currentPresses}/{requiredPresses}\n: {quickTimeTimer:F1}";
        }
    }

    void QuickTimeSuccess()
    {
        quickTimeActive = false;

        if (quickTimeText != null)
            quickTimeText.gameObject.SetActive(false);

        if (playerController != null)
            playerController.enabled = true;

        StartAnDialogue();
    }

    void QuickTimeFail()
    {
        quickTimeActive = false;

        if (quickTimeText != null)
            quickTimeText.gameObject.SetActive(false);

        GameObject player = GameObject.FindGameObjectWithTag("Player");
        if (player != null)
        {
            player.transform.position = returnPoint.transform.position;
        }


        if (playerController != null)
            playerController.enabled = true;

        exitAttempts --;
        
    }

    IEnumerator ReturnPlayer(GameObject player)
    {
        isReturning = true;

        if (playerController != null)
        {
            playerController.enabled = false;
        }

        yield return new WaitForSeconds(0.3f);

        while (Vector3.Distance(player.transform.position, returnPoint.position) > 0.1f)
        {
            Vector3 direction = (returnPoint.position - player.transform.position).normalized;
            player.transform.position += direction * moveSpeed * Time.deltaTime;
            UpdatePlayerSprite(direction);
            yield return null;
        }

        if (playerController != null)
        {
            playerController.enabled = true;
        }

        isReturning = false;
        StartAnDialogue();
    }

    void UpdatePlayerSprite(Vector3 direction)
    {
        if (playerSprite == null || playerController == null) return;

        if (Mathf.Abs(direction.x) > Mathf.Abs(direction.y))
        {
            if (direction.x > 0)
            {
                playerSprite.sprite = playerController.rightsprite;
            }
            else
            {
                playerSprite.sprite = playerController.leftsprite;
            }
        }
        else
        {
            if (direction.y > 0)
            {
                playerSprite.sprite = playerController.backsprite;
            }
            else
            {
                playerSprite.sprite = playerController.frontsprite;
            }
        }
    }

    void StartAnDialogue()
    {
        TextAsset dialogueToPlay = GetDialogue();

        DialogueManager dialogueManager = FindObjectOfType<DialogueManager>();
        if (dialogueManager != null && dialogueToPlay != null)
        {
            dialogueManager.StartDialogue(dialogueToPlay);
        }
    }


    TextAsset GetDialogue()
    {
        if (exitAttempts <= dialogues.Length)
        {
            return dialogues[exitAttempts - 1];
        }
        else
        {
            return dialogues[dialogues.Length - 1];
        }
    }

    public void ResetAttempts()
    {
        exitAttempts = 0;
        quickTimeActive = false;
        currentPresses = 0f;

        if (quickTimeText != null)
            quickTimeText.gameObject.SetActive(false);
    }
}

--- Путь к файлу: .\Assets\Game\Scripts\Dialogues\NPCData.cs ---

using UnityEngine;

[CreateAssetMenu(fileName = "New NPC", menuName = "Dialogue/NPC Data")]
public class NPCData : ScriptableObject
{
    [Header("Basic Info")]
    public string npcName;
    public Sprite portrait;

    [Header("Ink File")]
    public TextAsset inkFile;
}

--- Путь к файлу: .\Assets\Game\Scripts\Dialogues\UIInteractPrompt.cs ---

using UnityEngine;
using TMPro;

public class UIInteractPrompt : MonoBehaviour
{
    public static UIInteractPrompt Instance;

    public TMP_Text promptText;

    void Awake()
    {
        Instance = this;
        promptText.gameObject.SetActive(false);
    }

    public void Show(string text)
    {
        promptText.text = text;
        promptText.gameObject.SetActive(true);
    }

    public void Hide()
    {
        promptText.gameObject.SetActive(false);
    }
}


--- Путь к файлу: .\Assets\Game\Scripts\GameSave\Checkpoint.cs ---

using UnityEngine;

public class Checkpoint : MonoBehaviour
{
    [Header("  ")]
    public bool isActive = true;
    public string playerTag = "Player";


    private Renderer checkpointRenderer;

    void Start()
    {
        checkpointRenderer = GetComponent<Renderer>();
    }

    private void OnTriggerEnter(Collider other)
    {
        if (!isActive) return;

        if (other.CompareTag(playerTag))
        {
            SaveAtCheckpoint();
        }
    }

    private void OnTriggerEnter2D(Collider2D other)
    {
        if (!isActive) return;

        if (other.CompareTag(playerTag))
        {
            SaveAtCheckpoint();
        }
    }

    private void SaveAtCheckpoint()
    {
        GameObject player = GameObject.FindGameObjectWithTag(playerTag);
        if (player != null)
        {
            SaveSystem.SaveGame(player.transform.position);
            isActive = false;
            Debug.Log("   !");
        }
    }
}

--- Путь к файлу: .\Assets\Game\Scripts\GameSave\GameLoader.cs ---

using UnityEngine;

public class GameLoader : MonoBehaviour
{
    [Header(" ")]
    public Transform defaultSpawnPoint;

    void Start()
    {
        LoadGameState();
    }

    void LoadGameState()
    {
        SaveData saveData = SaveSystem.LoadGame();

        GameObject player = GameObject.FindGameObjectWithTag("Player");
        if (player == null)
        {
            return;
        }

        Vector3 spawnPosition;

        if (saveData != null && saveData.hasSaveData)
        {
            spawnPosition = saveData.GetPlayerPosition();
        }
        else
        {
            spawnPosition = defaultSpawnPoint != null ? defaultSpawnPoint.position : Vector3.zero;
        }

        player.transform.position = spawnPosition;
    }
}

--- Путь к файлу: .\Assets\Game\Scripts\GameSave\GameSaveManager.cs ---

using UnityEngine;

public class GameSaveManager : MonoBehaviour
{
    [Header(" ")]
    public bool enableQuickSaveKey = true;

    [Header("UI  ")]
    public bool enableSaveButton = true;

    [Header(" ")]
    public bool enableCheckpoints = true;

    public void SaveFromButton()
    {
        if (enableSaveButton)
        {
            SaveGame();
        }
    }

    public void QuickSave()
    {
        SaveGame();
    }

    private void SaveGame()
    {
        GameObject player = GameObject.FindGameObjectWithTag("Player");
        if (player != null)
        {
            SaveSystem.SaveGame(player.transform.position);
        }
    }
}

--- Путь к файлу: .\Assets\Game\Scripts\GameSave\SaveSystem.cs ---

using UnityEngine;
using System.IO;
using System;

[Serializable]
public class SaveData
{
    public float playerX;
    public float playerY;
    public float playerZ;
    public bool hasSaveData;

    public SaveData(Vector3 playerPosition)
    {
        playerX = playerPosition.x;
        playerY = playerPosition.y;
        playerZ = playerPosition.z;
        hasSaveData = true;
    }

    public Vector3 GetPlayerPosition()
    {
        return new Vector3(playerX, playerY, playerZ);
    }
}

public static class SaveSystem
{
    private static string savePath;
    private const string SAVE_FILE_NAME = "gamesave.json";

    static SaveSystem()
    {
        savePath = Path.Combine(Application.persistentDataPath, SAVE_FILE_NAME);
    }

    public static void SaveGame(Vector3 playerPosition)
    {
        SaveData saveData = new SaveData(playerPosition);
        string json = JsonUtility.ToJson(saveData);

        try
        {
            File.WriteAllText(savePath, json);
        }
        catch (System.Exception e)
        {
            Debug.LogError(" : " + e.Message);
        }
    }

    public static SaveData LoadGame()
    {
        if (!File.Exists(savePath))
        {
            return null;
        }

        try
        {
            string json = File.ReadAllText(savePath);
            SaveData saveData = JsonUtility.FromJson<SaveData>(json);
            return saveData;
        }
        catch (System.Exception e)
        {
            return null;
        }
    }

    public static bool HasSaveData()
    {
        if (!File.Exists(savePath)) return false;

        try
        {
            string json = File.ReadAllText(savePath);
            SaveData saveData = JsonUtility.FromJson<SaveData>(json);
            return saveData != null && saveData.hasSaveData;
        }
        catch
        {
            return false;
        }
    }

    public static void DeleteSave()
    {
        if (File.Exists(savePath))
        {
            File.Delete(savePath);
        }
    }
}

--- Путь к файлу: .\Assets\Game\Scripts\Inventory\InventoryItem.cs ---

using UnityEngine;

[System.Serializable]
public class InventoryItem
{
    public ItemData data;
    public int stackSize;

    public InventoryItem(ItemData itemData, int amount = 1)
    {
        data = itemData;
        stackSize = amount;
    }

    public bool AddToStack(int amount = 1)
    {
        if (stackSize + amount <= data.maxStackSize)
        {
            stackSize += amount;
            return true;
        }
        return false;
    }

    public bool RemoveFromStack(int amount = 1)
    {
        stackSize -= amount;
        return stackSize <= 0;
    }
}

--- Путь к файлу: .\Assets\Game\Scripts\Inventory\InventoryManager.cs ---

using UnityEngine;
using System;

public class InventoryManager : MonoBehaviour
{
    public static InventoryManager Instance;

    public static event Action<InventorySlot[]> OnInventoryChanged;
    public static event Action<InventoryItem> OnActiveItemChanged;

    [SerializeField] private int inventorySize = 9;
    public InventorySlot[] inventorySlots;
    public InventorySlot activeItemSlot;

    [SerializeField] private ItemDBSO itemDatabase;

    [Header("UI Settings")]
    public GameObject inventoryPanel;
    public GameObject activeSlotUI;

    private MonoBehaviour playerController;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
            return;
        }

        playerController = FindObjectOfType<PlayerMovement>();
        InitializeInventory();
    }

    private void Update()
    {
        if (!DialogueManager.Instance.IsPlaying())
        {
            if (Input.GetKeyDown(KeyCode.Tab))
            {
                ToggleInventory();
            }
        }

        if (DialogueManager.Instance.IsPlaying() && inventoryPanel.activeInHierarchy)
        {
            inventoryPanel.SetActive(false);
        }
    }

    private void InitializeInventory()
    {
        inventorySlots = new InventorySlot[inventorySize];
        activeItemSlot = new InventorySlot();

        for (int i = 0; i < inventorySlots.Length; i++)
        {
            inventorySlots[i] = new InventorySlot();
        }
    }

    public void ToggleInventory()
    {
        if (inventoryPanel != null)
        {
            bool newState = !inventoryPanel.activeInHierarchy;
            if (!newState)
            {
                if (playerController != null) playerController.enabled = true;
            }
            else
            {
                if (playerController != null) playerController.enabled = false;
            }

                inventoryPanel.SetActive(newState);
        }
    }

    public void MoveToActiveSlot(int fromSlotIndex)
    {
        if (fromSlotIndex < 0 || fromSlotIndex >= inventorySlots.Length) return;
        if (!inventorySlots[fromSlotIndex].HasItem()) return;

        if (activeItemSlot.HasItem())
        {
            int emptySlot = FindEmptySlot();
            if (emptySlot != -1)
            {
                inventorySlots[emptySlot].SetItem(activeItemSlot.Item);
                activeItemSlot.ClearSlot();
            }
            else
            {
                return;
            }
        }

        activeItemSlot.SetItem(inventorySlots[fromSlotIndex].Item);
        inventorySlots[fromSlotIndex].ClearSlot();

        OnInventoryChanged?.Invoke(inventorySlots);
        OnActiveItemChanged?.Invoke(activeItemSlot.Item);
    }

    public void MoveToInventoryFromActive()
    {
        if (!activeItemSlot.HasItem()) return;

        int emptySlot = FindEmptySlot();
        if (emptySlot != -1)
        {
            inventorySlots[emptySlot].SetItem(activeItemSlot.Item);
            activeItemSlot.ClearSlot();

            OnInventoryChanged?.Invoke(inventorySlots);
            OnActiveItemChanged?.Invoke(null);
        }
        else
        {
            Debug.Log("    !");
        }
    }

    private int FindEmptySlot()
    {
        for (int i = 0; i < inventorySlots.Length; i++)
        {
            if (!inventorySlots[i].HasItem())
            {
                return i;
            }
        }
        return -1;
    }

    public bool AddItem(string itemID, int amount = 1)
    {
        ItemData itemToAdd = itemDatabase.GetItemByID(itemID);
        if (itemToAdd == null) return false;

        if (activeItemSlot.HasItem() && itemToAdd == activeItemSlot.Item.data && itemToAdd.isStackable)
        {
            activeItemSlot.Item.AddToStack(amount);
            OnActiveItemChanged?.Invoke(null);
            return true;
            Debug.Log("Added to active slot stack.");
        }
        else
        {
            if (itemToAdd.isStackable)
            {
                for (int i = 0; i < inventorySlots.Length; i++)
                {
                    if (inventorySlots[i].HasItem() && inventorySlots[i].Item.data == itemToAdd)
                    {
                        if (inventorySlots[i].Item.AddToStack(amount))
                        {
                            OnInventoryChanged?.Invoke(inventorySlots);
                            return true;
                        }
                    }
                }
            }

            for (int i = 0; i < inventorySlots.Length; i++)
            {
                if (!inventorySlots[i].HasItem())
                {
                    inventorySlots[i].SetItem(new InventoryItem(itemToAdd, amount));
                    OnInventoryChanged?.Invoke(inventorySlots);
                    return true;
                }
            }
        }

        

        

        Debug.Log("Inventory is full!");
        return false;
    }

    public void TryCraftItems(int fromSlotIndex, int toSlotIndex)
    {
        InventoryItem itemA = inventorySlots[fromSlotIndex].Item;
        InventoryItem itemB = inventorySlots[toSlotIndex].Item;

        if (itemA == null || itemB == null) return;

        Debug.Log($" : {itemA.data.itemName} + {itemB.data.itemName}");

        ItemData resultItem = FindCraftingResult(itemA.data, itemB.data);

        if (resultItem != null)
        {
            Debug.Log($" ! : {resultItem.itemName}");

            RemoveItemFromSlot(fromSlotIndex);
            RemoveItemFromSlot(toSlotIndex);

            AddItem(resultItem.itemID);
        }
        else
        {
            Debug.Log($" : {itemA.data.itemName} + {itemB.data.itemName}");
        }
    }

    private ItemData FindCraftingResult(ItemData ingredient1, ItemData ingredient2)
    {
        foreach (ItemData potentialResult in itemDatabase.allItems)
        {
            if (potentialResult.craftingRecipes != null)
            {
                foreach (CraftingRecipe recipe in potentialResult.craftingRecipes)
                {
                    if ((recipe.item1 == ingredient1 && recipe.item2 == ingredient2) ||
                        (recipe.item1 == ingredient2 && recipe.item2 == ingredient1))
                    {
                        Debug.Log($" : {ingredient1.itemName} + {ingredient2.itemName} = {potentialResult.itemName}");
                        return potentialResult;
                    }
                }
            }
        }
        return null;
    }

    public bool RemoveItemFromActiveSlot(string itemID, int amount)
    {
        var activeSlot = activeItemSlot;

        if (activeSlot.HasItem() && activeSlot.Item.data.itemID == itemID)
        {
            if (activeSlot.Item.stackSize >= amount)
            {
                if (activeSlot.Item.stackSize == amount)
                {
                    activeSlot.ClearSlot();
                    ForceInventoryUpdate();

                    return true;
                }
                else
                {
                    activeSlot.Item.stackSize -= amount;
                    ForceInventoryUpdate();

                    return true;
                }
            }
        }

        return false;
    }

    public void SetActiveItem(InventoryItem item)
    {
        activeItemSlot.SetItem(item);
        OnActiveItemChanged?.Invoke(item);
    }

    public void ClearActiveItem()
    {
        activeItemSlot.ClearSlot();
        OnActiveItemChanged?.Invoke(null);
    }

    public void RemoveItemFromSlot(int slotIndex)
    {
        if (slotIndex >= 0 && slotIndex < inventorySlots.Length)
        {
            inventorySlots[slotIndex].ClearSlot();
            OnInventoryChanged?.Invoke(inventorySlots);
        }
    }

    public int GetItemCount(string itemID)
    {
        int totalCount = 0;

        if (activeItemSlot.HasItem() && activeItemSlot.Item.data.itemID == itemID)
        {
            totalCount += activeItemSlot.Item.stackSize;
        }

        foreach (var slot in inventorySlots)
        {
            if (slot.HasItem() && slot.Item.data.itemID == itemID)
            {
                totalCount += slot.Item.stackSize;
            }
        }

        return totalCount;
    }

    public int GetActiveSlotItemCount(string itemID)
    {
        if (activeItemSlot.HasItem() && activeItemSlot.Item.data.itemID == itemID)
        {
            return activeItemSlot.Item.stackSize;
        }
        return 0;
    }

    public void ForceInventoryUpdate()
    {
        OnInventoryChanged?.Invoke(inventorySlots);

        if (activeItemSlot.HasItem())
        {
            OnActiveItemChanged?.Invoke(activeItemSlot.Item);
        }
        else
        {
            OnActiveItemChanged?.Invoke(null);
        }
    }


    public void UpdateInventoryUI()
    {
        OnInventoryChanged?.Invoke(inventorySlots);
        if (activeItemSlot.HasItem())
        {
            OnActiveItemChanged?.Invoke(activeItemSlot.Item);
        }
        else
        {
            OnActiveItemChanged?.Invoke(null);
        }
    }
}

[System.Serializable]
public class InventorySlot
{
    public InventoryItem Item;

    public bool HasItem()
    {
        return Item != null;
    }

    public void SetItem(InventoryItem newItem)
    {
        Item = newItem;
    }

    public void ClearSlot()
    {
        Item = null;
    }
}

--- Путь к файлу: .\Assets\Game\Scripts\Inventory\InventorySlotUI.cs ---

using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class InventorySlotUI : MonoBehaviour, IPointerClickHandler, IBeginDragHandler, IEndDragHandler, IDropHandler, IDragHandler
{
    [SerializeField] private Image itemIcon;
    [SerializeField] private TMPro.TextMeshProUGUI stackCountText;

    public int SlotIndex;
    public bool isActiveItemSlot = false;

    private InventorySlot assignedSlot;
    private GameObject dragObject;
    private float lastClickTime;
    private const float doubleClickThreshold = 0.3f;

    private void Start()
    {
        InventoryManager.OnInventoryChanged += UpdateSlotUI;
        InventoryManager.OnActiveItemChanged += UpdateActiveSlotUI;

        if (!isActiveItemSlot)
        {
            assignedSlot = InventoryManager.Instance.inventorySlots[SlotIndex];
        }
        else
        {
            assignedSlot = InventoryManager.Instance.activeItemSlot;
            UpdateActiveSlotVisibility();
        }
        UpdateSlotDisplay();
    }

    private void OnDestroy()
    {
        InventoryManager.OnInventoryChanged -= UpdateSlotUI;
        InventoryManager.OnActiveItemChanged -= UpdateActiveSlotUI;
    }

    private void UpdateSlotUI(InventorySlot[] inventory)
    {
        if (!isActiveItemSlot)
        {
            UpdateSlotDisplay();
        }
    }

    private void UpdateActiveSlotUI(InventoryItem activeItem)
    {
        if (isActiveItemSlot)
        {
            UpdateSlotDisplay();
            UpdateActiveSlotVisibility();
        }
    }

    private void UpdateSlotDisplay()
    {
        if (assignedSlot.HasItem())
        {
            itemIcon.sprite = assignedSlot.Item.data.icon;
            itemIcon.color = Color.white;
            stackCountText.text = assignedSlot.Item.stackSize > 1 ? assignedSlot.Item.stackSize.ToString() : "";
        }
        else
        {
            itemIcon.sprite = null;
            itemIcon.color = Color.clear;
            stackCountText.text = "";
        }
    }

    private void UpdateActiveSlotVisibility()
    {
        if (isActiveItemSlot)
        {
            gameObject.SetActive(assignedSlot.HasItem());
        }
    }

    public void OnPointerClick(PointerEventData eventData)
    {
        if (eventData.button == PointerEventData.InputButton.Left)
        {
            float timeSinceLastClick = Time.time - lastClickTime;

            if (timeSinceLastClick <= doubleClickThreshold)
            {
                if (!isActiveItemSlot && assignedSlot.HasItem())
                {
                    InventoryManager.Instance.MoveToActiveSlot(SlotIndex);
                }
                else if (isActiveItemSlot && assignedSlot.HasItem())
                {
                    InventoryManager.Instance.MoveToInventoryFromActive();
                }
            }

            lastClickTime = Time.time;
        }
    }

    public void OnBeginDrag(PointerEventData eventData)
    {
        if (!assignedSlot.HasItem() || isActiveItemSlot) return;

        dragObject = new GameObject("DragIcon");
        dragObject.transform.SetParent(transform.root, false);
        dragObject.transform.SetAsLastSibling();

        Image dragImage = dragObject.AddComponent<Image>();
        dragImage.sprite = itemIcon.sprite;
        dragImage.raycastTarget = false;

        CanvasGroup canvasGroup = dragObject.AddComponent<CanvasGroup>();
        canvasGroup.alpha = 0.7f;
        canvasGroup.blocksRaycasts = false;

        itemIcon.color = new Color(1, 1, 1, 0.3f);
    }

    public void OnDrag(PointerEventData eventData)
    {
        if (dragObject != null)
        {
            dragObject.transform.position = eventData.position;
        }
    }

    public void OnEndDrag(PointerEventData eventData)
    {
        if (dragObject != null)
        {
            Destroy(dragObject);
            dragObject = null;
        }

        if (assignedSlot.HasItem())
        {
            itemIcon.color = Color.white;
        }
    }

    public void OnDrop(PointerEventData eventData)
    {
        GameObject droppedObject = eventData.pointerDrag;
        if (droppedObject == null) return;

        InventorySlotUI fromSlotUI = droppedObject.GetComponent<InventorySlotUI>();
        if (fromSlotUI == null || fromSlotUI.isActiveItemSlot) return;

        int fromIndex = fromSlotUI.SlotIndex;
        int toIndex = SlotIndex;

        if (fromIndex != toIndex)
        {
            InventoryManager.Instance.TryCraftItems(fromIndex, toIndex);
        }
    }
}

--- Путь к файлу: .\Assets\Game\Scripts\Inventory\ItemData.cs ---

using UnityEngine;

public enum ItemType
{
    Default,
    Consumable,
    Weapon,
    QuestItem
}

[CreateAssetMenu(fileName = "New Item", menuName = "Inventory/Item Data")]
public class ItemData : ScriptableObject
{
    [Header("Basic Info")]
    public string itemID;
    public string itemName;
    [TextArea] public string description;
    public Sprite icon;

    [Header("Settings")]
    public ItemType type;
    public bool isStackable = false;
    public int maxStackSize = 1;

    [Header("Crafting")]
    public CraftingRecipe[] craftingRecipes;
}

[System.Serializable]
public struct CraftingRecipe
{
    public ItemData item1;
    public ItemData item2;
}

--- Путь к файлу: .\Assets\Game\Scripts\Inventory\ItemDBSO.cs ---

using UnityEngine;

[CreateAssetMenu(fileName = "Item Database", menuName = "Inventory/Item Database")]
public class ItemDBSO : ScriptableObject
{
    public ItemData[] allItems;

    public ItemData GetItemByID(string id)
    {
        if (allItems == null)
        {
            return null;
        }

        if (string.IsNullOrEmpty(id))
        {
            return null;
        }

        foreach (ItemData item in allItems)
        {
            if (item == null)
            {
                continue;
            }

            if (item.itemID == id)
            {
                return item;
            }
        }

        return null;
    }
}

--- Путь к файлу: .\Assets\Game\Scripts\Inventory\ItemPickup.cs ---

using UnityEngine;

public class ItemPickup : MonoBehaviour
{
    [Header("Item Settings")]
    public ItemData itemData;
    public int amount = 1;

    [Header("Interaction Settings")]
    public KeyCode interactKey = KeyCode.E;

    private bool playerInRange = false;

    void Start()
    {
        if (itemData != null && itemData.icon != null)
        {
            SpriteRenderer spriteRenderer = GetComponent<SpriteRenderer>();
            if (spriteRenderer != null)
            {
                spriteRenderer.sprite = itemData.icon;
            }
        }
    }

    void Update()
    {
        if (playerInRange && Input.GetKeyDown(interactKey))
        {
            TryPickupItem();
        }
    }

    void OnTriggerEnter2D(Collider2D other)
    {
        if (other.CompareTag("Player"))
        {
            playerInRange = true;
        }
        UIInteractPrompt.Instance.Show(" E,  ");
    }

    void OnTriggerExit2D(Collider2D other)
    {
        if (other.CompareTag("Player"))
        {
            playerInRange = false;
            Debug.Log("   ");
        }
        UIInteractPrompt.Instance.Hide();
    }

    void TryPickupItem()
    {
        if (itemData == null)
        {
            return;
        }

        if (InventoryManager.Instance.AddItem(itemData.itemID, amount))
        {
            Destroy(gameObject);
        }
    }
}

--- Путь к файлу: .\Assets\Game\Scripts\PlatesMiniGame\FalsePlate.cs ---

using UnityEngine;

public class FalsePlate : MonoBehaviour
{
    [Header("False Plate Settings")]
    public Transform resetPosition;
    public bool usePuzzleStartPosition = true;

    private Transform puzzleStartPosition;

    public void Initialize(Transform puzzleStartPos)
    {
        puzzleStartPosition = puzzleStartPos;
    }

    private void OnTriggerEnter2D(Collider2D other)
    {
        if (other.CompareTag("Player"))
        {
            Debug.Log("Player stepped on false plate!");
            ResetPlayer(other.gameObject);
        }
    }

    private void ResetPlayer(GameObject player)
    {
        Transform targetPosition = usePuzzleStartPosition ? puzzleStartPosition : resetPosition;

        if (targetPosition != null)
        {
            player.transform.position = targetPosition.position;
            Debug.Log($"Player reset to position: {targetPosition.name}");
        }

        PressurePlatePuzzle puzzle = FindObjectOfType<PressurePlatePuzzle>();
        if (puzzle != null)
        {
            puzzle.ResetPuzzle();
        }
    }
}

--- Путь к файлу: .\Assets\Game\Scripts\PlatesMiniGame\PressurePlate.cs ---

using System.Collections;
using UnityEngine;

public class PressurePlate : MonoBehaviour
{
    [Header("Plate Settings")]
    public int plateIndex;
    public bool isCorrectPlate = true;

    [Header("Animations")]
    public AnimationClip activationAnimation;
    public AnimationClip rightStepAnimation;
    public AnimationClip wrongStepAnimation;

    private PressurePlatePuzzle puzzleController;
    private Animator animator;

    public static PressurePlate Instance;

    void Awake()
    {
        Instance = this;
    }

    public void Initialize(PressurePlatePuzzle controller)
    {
        puzzleController = controller;
        animator = GetComponent<Animator>();

        if (animator != null)
        {
            animator.enabled = false;
        }
    }

    public void PlayActivationAnimation()
    {
        if (animator != null && activationAnimation != null)
        {
            animator.enabled = true;
            animator.Play(activationAnimation.name);
        }
    }

    public void PlayRightStepAnimation()
    {
        if (animator != null && rightStepAnimation != null)
        {
            animator.enabled = true;
            animator.Play(rightStepAnimation.name);
        }
    }

    public void PlayWrongStepAnimation()
    {
        if (animator != null && wrongStepAnimation != null)
        {
            animator.enabled = true;
            animator.Play(wrongStepAnimation.name);
        }
    }

    private void OnTriggerEnter2D(Collider2D other)
    {
        if (other.CompareTag("Player"))
        {
            if (puzzleController != null)
            {
                puzzleController.OnPlateStepped(plateIndex, isCorrectPlate);
            }
        }
    }
}

--- Путь к файлу: .\Assets\Game\Scripts\PlatesMiniGame\PressurePlatePuzzle.cs ---

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PressurePlatePuzzle : MonoBehaviour
{
    [Header("Puzzle Settings")]
    public List<PressurePlate> puzzlePlates = new List<PressurePlate>();
    public float sequenceDelay = 1f;
    public Transform playerStartPosition;

    [Header("Trigger Zone")]
    public GameObject triggerZone;

    [Header("False Plates Settings")]
    public GameObject falsePlatesParent;
    public List<FalsePlate> falsePlates = new List<FalsePlate>();

    [Header("Camera Settings")]
    public Transform puzzleCameraPosition;
    public float cameraMoveSpeed = 5f;

    private Camera mainCamera;
    private MonoBehaviour cameraFollowScript;
    private Vector3 cameraStartPosition;
    private bool isCameraMovingToPuzzle = false;
    private bool isCameraMovingBack = false;

    private bool isSequencePlaying = false;
    private bool isPuzzleActive = false;
    private int currentStep = 0;
    private PlayerMovement playerMovement;
    private Transform playerTransform;
    private Coroutine cameraReturnCoroutine;

    public static PressurePlatePuzzle Instance;

    void Awake()
    {
        Instance = this;
    }

    void Start()
    {
        playerMovement = FindObjectOfType<PlayerMovement>();

        GameObject player = GameObject.FindGameObjectWithTag("Player");
        if (player != null)
        {
            playerTransform = player.transform;
        }

        mainCamera = Camera.main;
        if (mainCamera != null)
        {
            cameraFollowScript = mainCamera.GetComponent<MonoBehaviour>();
        }

        foreach (PressurePlate plate in puzzlePlates)
        {
            plate.Initialize(this);
        }

        if (falsePlatesParent != null && falsePlates.Count == 0)
        {
            FindFalsePlatesAutomatically();
        }

        foreach (FalsePlate falsePlate in falsePlates)
        {
            falsePlate.Initialize(playerStartPosition);
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.E) && IsPlayerInTriggerZone() && !isSequencePlaying && !isPuzzleActive)
        {
            StartPuzzleSequence();
        }

        if (isCameraMovingToPuzzle && puzzleCameraPosition != null)
        {
            MoveCameraToPuzzle();
        }

        if (isCameraMovingBack && playerTransform != null)
        {
            MoveCameraBackToPlayer();
        }
    }

    void MoveCameraToPuzzle()
    {
        Vector3 targetPos = puzzleCameraPosition.position;
        mainCamera.transform.position = Vector3.MoveTowards(
            mainCamera.transform.position,
            targetPos,
            cameraMoveSpeed * Time.deltaTime
        );

        if (Vector3.Distance(mainCamera.transform.position, targetPos) < 0.01f)
        {
            mainCamera.transform.position = targetPos;
            isCameraMovingToPuzzle = false;

            StartCoroutine(PlayPlateSequence());
        }
    }

    void MoveCameraBackToPlayer()
    {
        if (playerTransform == null) return;

        Vector3 targetPos = new Vector3(
            playerTransform.position.x,
            playerTransform.position.y,
            mainCamera.transform.position.z
        );

        mainCamera.transform.position = Vector3.MoveTowards(
            mainCamera.transform.position,
            targetPos,
            cameraMoveSpeed * Time.deltaTime
        );

        if (Vector3.Distance(mainCamera.transform.position, targetPos) < 0.01f)
        {
            isCameraMovingBack = false;

            if (cameraFollowScript != null)
            {
                cameraFollowScript.enabled = true;
            }
        }
    }

    private bool IsPlayerInTriggerZone()
    {
        if (triggerZone == null || playerTransform == null) return false;

        Collider2D triggerCollider = triggerZone.GetComponent<Collider2D>();
        if (triggerCollider != null)
        {
            return triggerCollider.OverlapPoint(playerTransform.position);
        }
        return false;
    }

    private void FindFalsePlatesAutomatically()
    {
        FalsePlate[] foundPlates = falsePlatesParent.GetComponentsInChildren<FalsePlate>();
        falsePlates.AddRange(foundPlates);
    }

    private void StartPuzzleSequence()
    {
        isSequencePlaying = true;
        isPuzzleActive = true;
        currentStep = 0;

        cameraStartPosition = mainCamera.transform.position;

        if (cameraFollowScript != null)
        {
            cameraFollowScript.enabled = false;
        }

        isCameraMovingToPuzzle = true;
        isCameraMovingBack = false;

        if (playerMovement != null)
        {
            playerMovement.enabled = false;
        }
    }

    private IEnumerator PlayPlateSequence()
    {
        yield return new WaitForSeconds(0.5f);

        for (int i = 0; i < puzzlePlates.Count; i++)
        {
            float delayForThisPlate = sequenceDelay * i;
            StartCoroutine(PlayPlateAnimationWithDelay(i, delayForThisPlate));
        }

        float totalSequenceTime = sequenceDelay * puzzlePlates.Count;
        yield return new WaitForSeconds(totalSequenceTime + 0.5f);

        StartCameraReturn();

        if (playerMovement != null)
        {
            playerMovement.enabled = true;
        }
        isSequencePlaying = false;
    }

    private IEnumerator PlayPlateAnimationWithDelay(int plateIndex, float delay)
    {
        yield return new WaitForSeconds(delay);
        puzzlePlates[plateIndex].PlayActivationAnimation();
    }

    public void OnPlateStepped(int plateIndex, bool isCorrectStep)
    {
        if (!isPuzzleActive)
        {
            ReturnPlayerToStart();
            PlayAllWrongStepAnimations();
            ResetPuzzle();
            return;
        }

        if (isSequencePlaying)
        {
            return;
        }

        if (isCorrectStep)
        {
            if (plateIndex == currentStep)
            {
                puzzlePlates[plateIndex].PlayRightStepAnimation();
                currentStep++;

                if (currentStep >= puzzlePlates.Count)
                {
                    PuzzleCompleted();
                }
            }
            else
            {
                ReturnPlayerToStart();
                PlayAllWrongStepAnimations();
                ResetPuzzle();
            }
        }
        else
        {
            ReturnPlayerToStart();
            PlayAllWrongStepAnimations();
            ResetPuzzle();
        }
    }

    private void ReturnPlayerToStart()
    {
        if (playerTransform != null && playerStartPosition != null)
        {
            playerTransform.position = playerStartPosition.position;
        }
    }

    private void PuzzleCompleted()
    {
        isPuzzleActive = false;
        Invoke("StartCameraReturn", 1f);
    }

    private void StartCameraReturn()
    {
        isCameraMovingBack = true;
        isCameraMovingToPuzzle = false;
    }

    private void PlayAllWrongStepAnimations()
    {
        foreach (PressurePlate plate in puzzlePlates)
        {
            plate.PlayWrongStepAnimation();
        }
    }

    public void ResetPuzzle()
    {
        PlayAllWrongStepAnimations();
        StopAllCoroutines();

        StartCameraReturn();

        if (playerMovement != null)
        {
            playerMovement.enabled = true;
        }

        isSequencePlaying = false;
        isPuzzleActive = false;
        currentStep = 0;
    }

    public bool IsPuzzleActive()
    {
        return isPuzzleActive;
    }

    public bool IsSequencePlaying()
    {
        return isSequencePlaying;
    }
}

--- Путь к файлу: .\Assets\Game\Scripts\PlatesMiniGame\PuzzleActivationZone.cs ---

using UnityEngine;

public class PuzzleActivationZone : MonoBehaviour
{
    [Header("UI Prompt")]
    public GameObject pressEPrompt;

    

    private void OnTriggerEnter2D(Collider2D other)
    {
        if (other.CompareTag("Player") && pressEPrompt != null)
        {
            pressEPrompt.SetActive(true);
        }

        
    }

    private void OnTriggerExit2D(Collider2D other)
    {
        if (other.CompareTag("Player") && pressEPrompt != null)
        {
            pressEPrompt.SetActive(false);
        }
    }
}

--- Путь к файлу: .\Assets\Game\Scripts\Quests\ActivateObject.cs ---

﻿using UnityEngine;

public class ActivateObject : MonoBehaviour
{
    public GameObject objectToActivate;

    void OnTriggerEnter2D(Collider2D other)
    {
        if (other.CompareTag("Player"))
        {
            objectToActivate.SetActive(true);
        }
    }
}


--- Путь к файлу: .\Assets\Game\Scripts\Quests\AnimationManager.cs ---

﻿using UnityEngine;
using System.Collections;

public class AnimationManager : MonoBehaviour
{
	public static AnimationManager Instance;

	void Awake()
	{
		Instance = this;
	}

	public void PlayAnimation(string animationName)
	{
		GameObject obj = GameObject.Find(animationName);
		if (obj != null)
		{
			Animator animator = obj.GetComponent<Animator>();
			if (animator != null)
			{
				animator.enabled = true;
				animator.Play(animationName);
			}
		}
	}

	public void PlayMultipleAnimations(string[] animationNames)
	{
		StartCoroutine(PlayAnimationsSequentially(animationNames));
	}

	private IEnumerator PlayAnimationsSequentially(string[] animationNames)
	{
		foreach (string animationName in animationNames)
		{
			PlayAnimation(animationName);
			yield return new WaitForSeconds(0.1f);
		}
	}
}

--- Путь к файлу: .\Assets\Game\Scripts\Quests\TriggerManager.cs ---

﻿using UnityEngine;

public class TriggerManager : MonoBehaviour
{
	public static TriggerManager Instance;

	void Awake()
	{
		Instance = this;
	}

	public void ActivateTrigger(string triggerName)
	{
		GameObject trigger = GameObject.Find(triggerName);
		if (trigger != null)
		{
			Collider2D collider = trigger.GetComponent<Collider2D>();
			if (collider != null) 
			{
				collider.enabled = true;
			}
		}
	}

	public void DeactivateObject(string objectName)
	{
		GameObject obj = GameObject.Find(objectName);
		if (obj != null)
		{
			obj.SetActive(false);
		}
	}
}

--- Путь к файлу: .\Assets\Game\Scripts\SudokuMiniGame\DraggableNumber.cs ---

﻿using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class DraggableNumber : MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler
{
	public int numberValue;
	private CanvasGroup canvasGroup;
	private Vector3 startPosition;

	void Start()
	{
		canvasGroup = GetComponent<CanvasGroup>();
		if (canvasGroup == null)
			canvasGroup = gameObject.AddComponent<CanvasGroup>();
        
		numberValue = int.Parse(GetComponentInChildren<Text>().text);
	}

	public void OnBeginDrag(PointerEventData eventData)
	{
		canvasGroup.alpha = 0.6f;
		canvasGroup.blocksRaycasts = false;
		startPosition = transform.position;
	}

	public void OnDrag(PointerEventData eventData)
	{
		transform.position = eventData.position;
	}

	public void OnEndDrag(PointerEventData eventData)
	{
		canvasGroup.alpha = 1f;
		canvasGroup.blocksRaycasts = true;
		transform.position = startPosition;
	}
}

--- Путь к файлу: .\Assets\Game\Scripts\SudokuMiniGame\GameManager.cs ---

﻿using UnityEngine;
using UnityEngine.UI;
using System.Collections;

public class GameManager : MonoBehaviour
{
    [Header("Settings")]
    public int gridSize = 3;
    public int targetSum = 15;

    [Header("Initial Values")]
    public string initialGrid = "000000000";

    [Header("Prefabs")]
    public GameObject cellPrefab;
    public GameObject numberPrefab;

    [Header("UI")]
    public Transform gridParent;
    public Transform numbersPanel;
    public Text targetText;
    public Image statusIndicator;
    public Button resetButton;
    public GameObject gamePanel;

    public AnimationClip treeAnimation;
    public GameObject treeObject;

    private Animator treeAnimator;

    private TableCell[,] gridCells;
    private MonoBehaviour playerController;

    public static GameManager Instance;

    void Awake()
    {
        Instance = this;
        
        gamePanel.SetActive(false);
        playerController = FindObjectOfType<PlayerMovement>();

        if (treeObject != null)
        {
            treeAnimator = treeObject.GetComponent<Animator>();

            if (treeAnimator != null)
            {
                treeAnimator.enabled = false;
            }
        }


    }
    public void StartMiniGame()
    {
        if(playerController != null)
        {
            playerController.enabled = false;
        }

        if (resetButton != null)
        {
            resetButton.onClick.AddListener(ResetGrid);
        }

        gamePanel.SetActive(true);
        CreateGrid();
        CreateNumbers();
        SetupInitialValues();
        targetText.text = $"object.targetposition = {targetSum}";
    }

    void CreateGrid()
    {
        foreach (Transform child in gridParent)
            Destroy(child.gameObject);

        GridLayoutGroup gridLayout = gridParent.GetComponent<GridLayoutGroup>();
        if (gridLayout == null)
            gridLayout = gridParent.gameObject.AddComponent<GridLayoutGroup>();

        gridLayout.cellSize = new Vector2(80, 80);
        gridLayout.spacing = new Vector2(5, 5);
        gridLayout.constraint = GridLayoutGroup.Constraint.FixedColumnCount;
        gridLayout.constraintCount = gridSize;

        gridCells = new TableCell[gridSize, gridSize];

        for (int i = 0; i < gridSize * gridSize; i++)
        {
            GameObject cell = Instantiate(cellPrefab, gridParent);
            TableCell tableCell = cell.GetComponent<TableCell>();

            int row = i / gridSize;
            int col = i % gridSize;
            gridCells[row, col] = tableCell;
        }
    }

    void CreateNumbers()
    {
        foreach (Transform child in numbersPanel)
            Destroy(child.gameObject);

        for (int i = 1; i <= 9; i++)
        {
            GameObject number = Instantiate(numberPrefab, numbersPanel);
            number.GetComponentInChildren<Text>().text = i.ToString();
        }
    }

    void SetupInitialValues()
    {
        for (int i = 0; i < gridSize * gridSize && i < initialGrid.Length; i++)
        {
            int row = i / gridSize;
            int col = i % gridSize;
            int value = int.Parse(initialGrid[i].ToString());

            if (gridCells[row, col] != null)
            {
                if (value > 0)
                {
                    gridCells[row, col].GetComponentInChildren<Text>().text = value.ToString();
                    gridCells[row, col].currentValue = value;
                    gridCells[row, col].isLocked = true;
                }
                else
                {
                    gridCells[row, col].GetComponentInChildren<Text>().text = "";
                    gridCells[row, col].currentValue = 0;
                    gridCells[row, col].isLocked = false;
                }
            }
        }
        statusIndicator.color = Color.red;
    }

    public void ResetGrid()
    {
        SetupInitialValues();
    }

    public void CheckSolution()
    {
        bool isSolved = true;

        for (int row = 0; row < gridSize; row++)
        {
            int rowSum = 0;
            for (int col = 0; col < gridSize; col++)
            {
                if (gridCells[row, col] != null)
                {
                    rowSum += gridCells[row, col].currentValue;
                }
            }
            if (rowSum != targetSum)
            {
                isSolved = false;
                break;
            }
        }

        if (isSolved)
        {
            for (int col = 0; col < gridSize; col++)
            {
                int colSum = 0;
                for (int row = 0; row < gridSize; row++)
                {
                    if (gridCells[row, col] != null)
                    {
                        colSum += gridCells[row, col].currentValue;
                    }
                }
                if (colSum != targetSum)
                {
                    isSolved = false;
                    break;
                }
            }
        }

        if (isSolved)
        {
            statusIndicator.color = Color.green;
            Invoke("EndMiniGame", 1.5f);
        }
        else
        {
            statusIndicator.color = Color.red;
        }
    }

    void EndMiniGame()
    {
        if (playerController != null)
        {
            playerController.enabled = true;
        }

        gamePanel.SetActive(false);

        if (treeAnimator != null && treeAnimation != null)
        {
            treeAnimator.enabled = true;
            treeAnimator.Play(treeAnimation.name);
        }
    }

}

--- Путь к файлу: .\Assets\Game\Scripts\SudokuMiniGame\SudokuMiniGameTrigger.cs ---

using UnityEngine;

public class SudokuMiniGameTrigger : MonoBehaviour
{
    [Header("  ")]
    public bool workOnlyOnce = false;
    public bool startOnEnter = true;
    public bool requirePressE = false;

    bool inRange = false;
    bool alreadyUsed = false;

    void OnTriggerEnter2D(Collider2D other)
    {
        if (alreadyUsed && workOnlyOnce) return;
        if (other.CompareTag("Player"))
        {
            inRange = true;
            if (startOnEnter && !requirePressE) StartGame();
            else if (requirePressE) UIInteractPrompt.Instance.Show(" E");

        }
    }

    void OnTriggerExit2D(Collider2D other)
    {
        if (other.CompareTag("Player"))
        {
            inRange = false;
            UIInteractPrompt.Instance.Hide();
        }
    }

    void Update()
    {
        if(inRange && requirePressE && Input.GetKeyDown(KeyCode.E))
        {
            UIInteractPrompt.Instance.Hide();
            StartGame();
        }
    }

    void StartGame()
    {
        if (workOnlyOnce)
        {
            alreadyUsed = true;
            inRange = false;
        }

        GameManager.Instance.StartMiniGame();
    }
}


--- Путь к файлу: .\Assets\Game\Scripts\SudokuMiniGame\TableCell.cs ---

﻿using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;

public class TableCell : MonoBehaviour, IDropHandler
{
    private Text numberText;
    public int currentValue;
    public bool isLocked = false; 

    void Start()
    {
        numberText = GetComponentInChildren<Text>();
    }

    public void OnDrop(PointerEventData eventData)
    {
        if (isLocked) return;

        GameObject draggedNumber = eventData.pointerDrag;
        if (draggedNumber == null) return;

        DraggableNumber draggable = draggedNumber.GetComponent<DraggableNumber>();
        if (draggable != null)
        {
            numberText.text = draggable.numberValue.ToString();
            currentValue = draggable.numberValue;
            FindObjectOfType<GameManager>().CheckSolution();
        }
    }
}

--- Путь к файлу: .\Assets\Game\Scripts\UI\CutSceneTrigger.cs ---

using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Video;

public class CutSceneTrigger : MonoBehaviour
{
    public Canvas canvas;
    public VideoPlayer videoPlayer;

    private MonoBehaviour playerController;
    private bool used = false;

    private void Start()
    {
        playerController = FindObjectOfType<PlayerMovement>();
    }

    private void OnTriggerEnter2D(Collider2D other)
    {
        if (used) return;
        if (!other.CompareTag("Player")) return;

        used = true;
        canvas.gameObject.SetActive(true);

        if (playerController != null)
            playerController.enabled = false;

        videoPlayer.Play();
        videoPlayer.loopPointReached += OnVideoFinished;
    }

    private void OnVideoFinished(VideoPlayer vp)
    {
        canvas.enabled = false;

        if (playerController != null)
            playerController.enabled = true;
    }
}



--- Путь к файлу: .\Assets\Game\Scripts\UI\MenuManager.cs ---

using UnityEngine;
using UnityEngine.UI;
using UnityEngine.SceneManagement;

public class MenuManager : MonoBehaviour
{
    [Header(" ")]
    public GameObject mainMenuPanel;
    public Button continueButton;
    public Button newGameButton;
    public Button settingsButton;
    public Button exitButton;

    [Header(" ")]
    public GameObject settingsPanel;
    public Button backButton;

    [Header("")]
    public string gameSceneName = "GameScene";

    void Start()
    {
        mainMenuPanel.SetActive(true);
        settingsPanel.SetActive(false);

        continueButton.onClick.AddListener(OnContinueButton);
        newGameButton.onClick.AddListener(OnNewGameButton);
        settingsButton.onClick.AddListener(OnSettingsButton);
        exitButton.onClick.AddListener(OnExitButton);

        backButton.onClick.AddListener(OnBackButton);

        UpdateContinueButton();
    }

    void UpdateContinueButton()
    {
        bool hasSave = SaveSystem.HasSaveData();
        continueButton.gameObject.SetActive(hasSave);
    }

    public void OnContinueButton()
    {
        if (SaveSystem.HasSaveData())
        {
            SceneManager.LoadScene(gameSceneName);
        }
        else
        {
            UpdateContinueButton();
        }
    }

    public void OnNewGameButton()
    {
        SaveSystem.DeleteSave();
        SceneManager.LoadScene(gameSceneName);
    }

    public void OnSettingsButton()
    {
        mainMenuPanel.SetActive(false);
        settingsPanel.SetActive(true);
    }

    public void OnBackButton()
    {
        mainMenuPanel.SetActive(true);
        settingsPanel.SetActive(false);
    }

    public void OnExitButton()
    {

        #if UNITY_EDITOR
        UnityEditor.EditorApplication.isPlaying = false;
        #else

        Application.Quit();
        #endif
    }
}

--- Путь к файлу: .\Assets\Game\Scripts\UI\PanelController.cs ---

using UnityEngine;
using UnityEngine.SceneManagement;
public class PanelController : MonoBehaviour
{
    [Header("")]
    public GameObject panel;
    public string sceneName;

    [Header(" ")]
    public bool workOnlyOnce = false;
    private string playerTag = "Player";

    [Header(" ")]
    public bool disablePlayerControl = true;

    public bool goToMenu = false;

    private PlayerMovement playerController;
    private bool alreadyTriggered = false;

    void Start()
    {
        playerController = FindObjectOfType<PlayerMovement>();

        if (panel != null)
            panel.SetActive(false);
    }

    private void OnTriggerEnter2D(Collider2D other)
    {
        if (other.CompareTag(playerTag) && (!workOnlyOnce || !alreadyTriggered))
        {
            if (panel != null)
                panel.SetActive(true);

            if (disablePlayerControl && playerController != null)
                playerController.enabled = false;

            if (goToMenu)
            {
                Invoke("LoadMenu", 5f);
            }

            alreadyTriggered = true;
        }
    }

    public void LoadMenu()
    {
        SceneManager.LoadScene(sceneName);
    }

    public void HidePanel()
    {
        if (panel != null)
            panel.SetActive(false);

        if (disablePlayerControl && playerController != null)
            playerController.enabled = true;
    }

    public void ResetTrigger()
    {
        alreadyTriggered = false;
    }
}

--- Путь к файлу: .\Assets\Game\Scripts\UI\PauseManager.cs ---

using UnityEngine;
using UnityEngine.UI;

public class PauseManager : MonoBehaviour
{
    [Header("")]
    public GameObject pausePanel;
    public GameObject settingsPanel;

    [Header(" ")]
    public Button settingsButton;
    public Button continueButton;
    public Button menuButton;

    [Header("   ")]
    public Button backButton;

    private bool isPaused = false;

    void Start()
    {
        pausePanel.SetActive(false);
        settingsPanel.SetActive(false);

        settingsButton.onClick.AddListener(OpenSettings);
        continueButton.onClick.AddListener(ContinueGame);
        menuButton.onClick.AddListener(GoToMainMenu);
        backButton.onClick.AddListener(CloseSettings);
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            if (isPaused)
            {
                if (settingsPanel.activeSelf)
                {
                    CloseSettings();
                }
                else
                {
                    ContinueGame();
                }
            }
            else
            {
                PauseGame();
            }
        }
    }

    void PauseGame()
    {
        isPaused = true;
        Time.timeScale = 0f;

        pausePanel.SetActive(true);
        settingsPanel.SetActive(false);

        Debug.Log("  ");
    }

    void ContinueGame()
    {
        isPaused = false;
        Time.timeScale = 1f;

        pausePanel.SetActive(false);
        settingsPanel.SetActive(false);

        Debug.Log(" ");
    }

    void OpenSettings()
    {
        pausePanel.SetActive(false);
        settingsPanel.SetActive(true);
    }

    void CloseSettings()
    {
        settingsPanel.SetActive(false);
        pausePanel.SetActive(true);
    }

    void GoToMainMenu()
    {
        Time.timeScale = 1f;
        UnityEngine.SceneManagement.SceneManager.LoadScene("MainMenu");
    }
}

--- Путь к файлу: .\Assets\Game\Scripts\UI\SettingsManager.cs ---

using UnityEngine;
using UnityEngine.UI;

public class SettingsManager : MonoBehaviour
{
    [Header(" ")]
    public Slider volumeSlider;

    [Header("UI")]
    public GameObject settingsPanel;
    public Button backButton;

    private Dropdown screenModeDropdown;

    void Start()
    {
        screenModeDropdown = settingsPanel.GetComponentInChildren<Dropdown>();

        if (volumeSlider != null)
        {
            volumeSlider.value = PlayerPrefs.GetFloat("MasterVolume", 1f);
            volumeSlider.onValueChanged.AddListener(SetMasterVolume);
        }

        if (screenModeDropdown != null)
        {
            screenModeDropdown.value = Screen.fullScreen ? 0 : 1;
            screenModeDropdown.onValueChanged.AddListener(SetFullscreen);
        }

        if (backButton != null)
            backButton.onClick.AddListener(CloseSettings);
    }

    public void SetMasterVolume(float volume)
    {
        AudioListener.volume = volume;
        PlayerPrefs.SetFloat("MasterVolume", volume);
    }

    public void SetFullscreen(int isFullscreen)
    {
        bool fullscreen = (isFullscreen == 0);
        Screen.fullScreen = fullscreen;
    }

    public void CloseSettings()
    {
        PlayerPrefs.Save();
        if (settingsPanel != null)
            settingsPanel.SetActive(false);
    }

    public void OpenSettings()
    {
        if (settingsPanel != null)
            settingsPanel.SetActive(true);
    }
}

--- Путь к файлу: .\Assets\Ink\Demos\Basic Demo\Scripts\BasicInkExample.cs ---

﻿using System;
using Ink.Runtime;
using UnityEngine;
using UnityEngine.UI;

// This is a super bare bones example of how to play and display a ink story in Unity.
public class BasicInkExample : MonoBehaviour {
    public static event Action<Story> OnCreateStory;
	
    void Awake () {
		// Remove the default message
		RemoveChildren();
		StartStory();
	}

	// Creates a new Story object with the compiled story which we can then play!
	void StartStory () {
		story = new Story (inkJSONAsset.text);
		if(OnCreateStory != null) OnCreateStory(story);
		RefreshView();
	}
	
	// This is the main function called every time the story changes. It does a few things:
	// Destroys all the old content and choices.
	// Continues over all the lines of text, then displays all the choices. If there are no choices, the story is finished!
	void RefreshView () {
		// Remove all the UI on screen
		RemoveChildren ();
		
		// Read all the content until we can't continue any more
		while (story.canContinue) {
			// Continue gets the next line of the story
			string text = story.Continue ();
			// This removes any white space from the text.
			text = text.Trim();
			// Display the text on screen!
			CreateContentView(text);
		}

		// Display all the choices, if there are any!
		if(story.currentChoices.Count > 0) {
			for (int i = 0; i < story.currentChoices.Count; i++) {
				Choice choice = story.currentChoices [i];
				Button button = CreateChoiceView (choice.text.Trim ());
				// Tell the button what to do when we press it
				button.onClick.AddListener (delegate {
					OnClickChoiceButton (choice);
				});
			}
		}
		// If we've read all the content and there's no choices, the story is finished!
		else {
			Button choice = CreateChoiceView("End of story.\nRestart?");
			choice.onClick.AddListener(delegate{
				StartStory();
			});
		}
	}

	// When we click the choice button, tell the story to choose that choice!
	void OnClickChoiceButton (Choice choice) {
		story.ChooseChoiceIndex (choice.index);
		RefreshView();
	}

	// Creates a textbox showing the the line of text
	void CreateContentView (string text) {
		Text storyText = Instantiate (textPrefab) as Text;
		storyText.text = text;
		storyText.transform.SetParent (canvas.transform, false);
	}

	// Creates a button showing the choice text
	Button CreateChoiceView (string text) {
		// Creates the button from a prefab
		Button choice = Instantiate (buttonPrefab) as Button;
		choice.transform.SetParent (canvas.transform, false);
		
		// Gets the text from the button prefab
		Text choiceText = choice.GetComponentInChildren<Text> ();
		choiceText.text = text;

		// Make the button expand to fit the text
		HorizontalLayoutGroup layoutGroup = choice.GetComponent <HorizontalLayoutGroup> ();
		layoutGroup.childForceExpandHeight = false;

		return choice;
	}

	// Destroys all the children of this gameobject (all the UI)
	void RemoveChildren () {
		int childCount = canvas.transform.childCount;
		for (int i = childCount - 1; i >= 0; --i) {
			Destroy (canvas.transform.GetChild (i).gameObject);
		}
	}

	[SerializeField]
	private TextAsset inkJSONAsset = null;
	public Story story;

	[SerializeField]
	private Canvas canvas = null;

	// UI Prefabs
	[SerializeField]
	private Text textPrefab = null;
	[SerializeField]
	private Button buttonPrefab = null;
}


--- Путь к файлу: .\Assets\Ink\Demos\Basic Demo\Scripts\QuitGameOnKeypress.cs ---

﻿using UnityEngine;

public class QuitGameOnKeypress : MonoBehaviour {
	
	public KeyCode key = KeyCode.Escape;
	
	void Update () {
		if(Input.GetKeyDown(key)) Application.Quit();
	}
}

--- Путь к файлу: .\Assets\Ink\Demos\Basic Demo\Scripts\Editor\BasicInkExampleEditor.cs ---

﻿using Ink.Runtime;
using Ink.UnityIntegration;
using UnityEditor;
using UnityEngine;

[CustomEditor(typeof(BasicInkExample))]
[InitializeOnLoad]
public class BasicInkExampleEditor : Editor {
    static bool storyExpanded;
    static BasicInkExampleEditor () {
        BasicInkExample.OnCreateStory += OnCreateStory;
    }

    static void OnCreateStory (Story story) {
        // If you'd like NOT to automatically show the window and attach (your teammates may appreciate it!) then replace "true" with "false" here. 
        InkPlayerWindow window = InkPlayerWindow.GetWindow(true);
        if(window != null) InkPlayerWindow.Attach(story);
    }
	public override void OnInspectorGUI () {
		Repaint();
		base.OnInspectorGUI ();
		var realTarget = target as BasicInkExample;
		var story = realTarget.story;
		InkPlayerWindow.DrawStoryPropertyField(story, ref storyExpanded, new GUIContent("Story"));
	}
}


--- Путь к файлу: .\Assets\Ink\Editor\Core\InkDefineSymbols.cs ---

using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEditor.Build;

namespace Ink.UnityIntegration {
    // This class adds define symbols for the ink runtime and editor. Handy for conditional compilation.
    public class InkDefineSymbols : IActiveBuildTargetChanged {
        public const string inkRuntimeDefine = "INK_RUNTIME";
        public const string inkEditorDefine = "INK_EDITOR";
        static readonly string[] inkDefines = {inkRuntimeDefine, inkEditorDefine};
        
        const char DEFINE_SEPARATOR = ';';
        
        public int callbackOrder => 0;
        public void OnActiveBuildTargetChanged(BuildTarget previousTarget, BuildTarget newTarget) {
            AddGlobalDefine();
        }
			
        // Adds the default define symbols to the active build target if they're not already present. 
        public static void AddGlobalDefine() {
            Add(BuildPipeline.GetBuildTargetGroup(EditorUserBuildSettings.activeBuildTarget), inkDefines);
        }

        // Removes the default define symbols from the active build target if they're present. 
        public static void RemoveGlobalDefine() {
            Remove(BuildPipeline.GetBuildTargetGroup(EditorUserBuildSettings.activeBuildTarget), inkDefines);
        }
			
        // Checks if all the default define symbols are present. 
        public static bool HasGlobalDefines() {
            return Exists(BuildPipeline.GetBuildTargetGroup(EditorUserBuildSettings.activeBuildTarget), inkDefines);
        }
			
			
        static void Add(BuildTargetGroup buildTargetGroup, params string[] defines) {
            var allDefines = new List<string>();
            string definesStr = PlayerSettings.GetScriptingDefineSymbolsForGroup(buildTargetGroup);
            allDefines = definesStr.Split(DEFINE_SEPARATOR).ToList();
            allDefines.AddRange(defines.Except(allDefines));
            PlayerSettings.SetScriptingDefineSymbolsForGroup(buildTargetGroup, string.Join(DEFINE_SEPARATOR.ToString(), allDefines.ToArray()));
        }
				
				
        static void Remove(BuildTargetGroup buildTargetGroup, params string[] defines) {
            string definesStr = PlayerSettings.GetScriptingDefineSymbolsForGroup(buildTargetGroup);
            var existingDefines = definesStr.Split(DEFINE_SEPARATOR).ToList();
            var newDefines = existingDefines.Except(defines);
            PlayerSettings.SetScriptingDefineSymbolsForGroup(buildTargetGroup, string.Join(DEFINE_SEPARATOR.ToString(), newDefines.ToArray()));
        }

        static bool Exists(BuildTargetGroup buildTargetGroup, params string[] defines) {
            string definesStr = PlayerSettings.GetScriptingDefineSymbolsForGroup(BuildTargetGroup.Standalone);
            var existingDefines = definesStr.Split(DEFINE_SEPARATOR).ToList();
            return existingDefines.Contains("INK_RUNTIME") && existingDefines.Contains("INK_EDITOR");
        }
        
        // This code works but it throws errors that can't be caught for non-installed build target groups. Instead I've switched to adding them when the active build target changes 
        // foreach (BuildTargetGroup buildTargetGroup in (BuildTargetGroup[]) Enum.GetValues(typeof(BuildTargetGroup))) {
        // if(BuildPipeline.IsBuildTargetSupported(buildTargetGroup, BuildTarget.NoTarget))
        // Add(BuildPipeline.GetBuildTargetGroup(buildTargetGroup), inkDefines);
        // }

    }
}

--- Путь к файлу: .\Assets\Ink\Editor\Core\InkEditorUtils.cs ---

﻿using UnityEngine;
using UnityEditor;
using System;
using System.IO;
using System.Text;
using System.Linq;
using Ink.Runtime;
using UnityEditor.ProjectWindowCallback;
using UnityEditor.Callbacks;
using Path = System.IO.Path;

namespace Ink.UnityIntegration {
	[InitializeOnLoad]
	public static class InkEditorUtils {
		class CreateInkAssetAction : EndNameEditAction {
			public override void Action(int instanceId, string pathName, string resourceFile) {
				var text = "";
				if(File.Exists(resourceFile)) {
					StreamReader streamReader = new StreamReader(resourceFile);
					text = streamReader.ReadToEnd();
					streamReader.Close();
				}
				var assetPath = CreateScriptAsset(pathName, text);
				var asset = AssetDatabase.LoadAssetAtPath<UnityEngine.Object>(assetPath);
				ProjectWindowUtil.ShowCreatedAsset(asset);
			}
		}
		public const string inkFileExtension = ".ink";
		const string lastCompileTimeKey = "InkIntegrationLastCompileTime";

		private static Texture2D _inkLogoIcon;

		static InkEditorUtils() {
			var isFirstLaunch = SessionState.GetBool("InkIsFirstUnityLaunch", true);
			if (isFirstLaunch) {
				SessionState.SetBool("InkIsFirstUnityLaunch", false);
				if(InkSettings.instance.automaticallyAddDefineSymbols)
					InkDefineSymbols.AddGlobalDefine();
			}
		}

		public static Texture2D inkLogoIcon {
			get {
				if(_inkLogoIcon == null) {
					_inkLogoIcon = Resources.Load<Texture2D>("InkLogoIcon");
				}
				return _inkLogoIcon;
			}
		}

		[MenuItem("Assets/Rebuild Ink Library", false, 200)]
		public static void RebuildLibrary() {
			InkLibrary.Rebuild();
		}

		[MenuItem("Assets/Recompile Ink", false, 201)]
		public static void RecompileAll() {
			var filesToRecompile = InkLibrary.FilesCompiledByRecompileAll().ToArray();
			string logString = filesToRecompile.Any() ? 
				"Recompile All will compile "+string.Join(", ", filesToRecompile.Select(x => Path.GetFileName(x.filePath)).ToArray()) :
				"No valid ink found. Note that only files with 'Compile Automatic' checked are compiled if not set to compile all files automatically in InkSettings file.";
			Debug.Log(logString);
			InkCompiler.CompileInk(filesToRecompile);
		}

        public static void RecompileAllImmediately() {
            var filesToRecompile = InkLibrary.FilesCompiledByRecompileAll().ToArray();
            string logString = filesToRecompile.Any() ? 
                                   "Recompile All Immediately will compile "+string.Join(", ", filesToRecompile.Select(x => Path.GetFileName(x.filePath)).ToArray()) :
                                   "No valid ink found. Note that only files with 'Compile Automatic' checked are compiled if not set to compile all files automatically in InkSettings file.";
            Debug.Log(logString);
            InkCompiler.CompileInk(filesToRecompile, true, null);
        }



		[MenuItem("Assets/Create/Ink", false, 120)]
		public static void CreateNewInkFileAtSelectedPathWithTemplateAndStartNameEditing () {
			string fileName = "New Ink.ink";
			string filePath = AssetDatabase.GenerateUniqueAssetPath(Path.Combine(GetSelectedPathOrFallback(), fileName));
			CreateNewInkFileAtPathWithTemplateAndStartNameEditing(filePath, InkSettings.instance.templateFilePath);
		}
		
		public static void CreateNewInkFileAtPathWithTemplateAndStartNameEditing (string filePath, string templateFileLocation) {
			if(Path.GetExtension(filePath) != inkFileExtension) filePath += inkFileExtension;
			ProjectWindowUtil.StartNameEditingIfProjectWindowExists(0, ScriptableObject.CreateInstance<CreateInkAssetAction>(), filePath, InkBrowserIcons.inkFileIcon, templateFileLocation);
		}

		public static DefaultAsset CreateNewInkFileAtPath (string filePath, string text) {
			if(Path.GetExtension(filePath) != inkFileExtension) filePath += inkFileExtension;
			var assetPath = CreateScriptAsset(filePath, text);
			return AssetDatabase.LoadAssetAtPath<DefaultAsset>(assetPath);
		}
		
		static string CreateScriptAsset(string pathName, string text) {
			string fullPath = Path.GetFullPath(pathName);
			fullPath = fullPath.Replace('\\', '/');
			var assetRelativePath = fullPath;
			if(fullPath.StartsWith(Application.dataPath)) {
				assetRelativePath = fullPath.Substring(Application.dataPath.Length-6); 
			}
			var directoryPath = Path.GetDirectoryName(fullPath);
			if(!Directory.Exists(directoryPath))
				Directory.CreateDirectory(directoryPath);
			UTF8Encoding encoding = new UTF8Encoding(true, false);
			StreamWriter streamWriter = null;
			streamWriter = new StreamWriter(fullPath, false, encoding);
			streamWriter.Write(text);
			streamWriter.Close();
			AssetDatabase.ImportAsset(assetRelativePath);
			return assetRelativePath;
		}



		private static string GetSelectedPathOrFallback() {
			string path = "Assets";
			foreach (UnityEngine.Object obj in Selection.GetFiltered(typeof(UnityEngine.Object), SelectionMode.Assets)) {
				path = AssetDatabase.GetAssetPath(obj);
				if (!string.IsNullOrEmpty(path) && File.Exists(path)) {
					path = Path.GetDirectoryName(path);
					break;
				}
			}
			return path;
		}

		

		[MenuItem("Help/Ink/About")]
		public static void OpenAbout() {
			Application.OpenURL("https://github.com/inkle/ink#ink");
		}

		[MenuItem("Help/Ink/Writing Tutorial...")]
		public static void OpenWritingDocumentation() {
			Application.OpenURL("https://github.com/inkle/ink/blob/master/Documentation/WritingWithInk.md");
		}
		
        [MenuItem("Help/Ink/API Documentation...")]
		public static void OpenAPIDocumentation() {
			Application.OpenURL("https://github.com/inkle/ink/blob/master/Documentation/RunningYourInk.md");
		}

		[MenuItem("Help/Ink/Discord (Community + Support...")]
		public static void OpenDiscord() {
			Application.OpenURL("https://discord.gg/inkle");
		}

		[MenuItem("Help/Ink/Donate...")]
		public static void Donate() {
			Application.OpenURL("https://www.patreon.com/inkle");
		}

		[PostProcessBuildAttribute(-1)]
		public static void OnPostprocessBuild(BuildTarget target, string pathToBuiltProject) {
			if(!Debug.isDebugBuild) {
				var color = EditorGUIUtility.isProSkin ? "#3498db" : "blue";
				Debug.Log("<color="+color+">Thanks for using ink, and best of luck with your release!\nIf you're doing well, please help fund the project via Patreon https://www.patreon.com/inkle</color>");
			}
		}

		public static TextAsset CreateStoryStateTextFile (string jsonStoryState, string defaultPath = "Assets/Ink", string defaultName = "storyState") {
			string name = AssetDatabase.GenerateUniqueAssetPath(Path.Combine(defaultPath, defaultName+".json"));
			if(!string.IsNullOrEmpty(defaultPath)) name = name.Substring(defaultPath.Length+1);
			string fullPathName = EditorUtility.SaveFilePanel("Save Story State", defaultPath, name, "json");
			if(fullPathName == "") 
				return null;
			using (StreamWriter outfile = new StreamWriter(fullPathName)) {
				outfile.Write(jsonStoryState);
			}
			
			if(fullPathName.StartsWith(Application.dataPath)) {
				string relativePath = AbsoluteToUnityRelativePath(fullPathName);
				AssetDatabase.ImportAsset(relativePath);
				TextAsset textAsset = AssetDatabase.LoadAssetAtPath<TextAsset>(relativePath);
				return textAsset;
			}
			else return null;
		}

		public static bool StoryContainsVariables (Story story) {
			return story.variablesState.GetEnumerator().MoveNext();
		}

		public static bool CheckStoryIsValid (string storyJSON, out Exception exception) {
			try {
				new Story(storyJSON);
			} catch (Exception ex) {
				exception = ex;
				return false;
			}
			exception = null;
			return true;
		}

		public static bool CheckStoryIsValid (string storyJSON, out Story story) {
			try {
				story = new Story(storyJSON);
			} catch {
				story = null;
				return false;
			}
			return true;
		}

		public static bool CheckStoryIsValid (string storyJSON, out Exception exception, out Story story) {
			try {
				story = new Story(storyJSON);
			} catch (Exception ex) {
				exception = ex;
				story = null;
				return false;
			}
			exception = null;
			return true;
		}

		public static bool CheckStoryStateIsValid (string storyJSON, string storyStateJSON) {
			Story story;
			if(CheckStoryIsValid(storyJSON, out story)) {
				try {
					story.state.LoadJson(storyStateJSON);
				} catch {
					return false;
				}
			}
			return true;
		}
		
		// Returns a sanitized version of the supplied string by:
		//    - swapping MS Windows-style file separators with Unix/Mac style file separators.
		// If null is provided, null is returned.
		public static string SanitizePathString(string path) {
			if (path == null) {
				return null;
			}
			return path.Replace('\\', '/');
		}
		
		// Combines two file paths and returns that path.  Unlike C#'s native Paths.Combine, regardless of operating 
		// system this method will always return a path which uses forward slashes ('/' characters) exclusively to ensure
		// equality checks on path strings return equalities as expected.
		public static string CombinePaths(string firstPath, string secondPath) {
            Debug.Assert(firstPath != null);
            Debug.Assert(secondPath != null);
			return SanitizePathString(firstPath+"/"+secondPath);
		}

		public static string AbsoluteToUnityRelativePath(string fullPath) {
			return SanitizePathString(fullPath.Substring(Application.dataPath.Length-6));
		}

		public static string UnityRelativeToAbsolutePath(string filePath) {
			return InkEditorUtils.CombinePaths(Application.dataPath, filePath.Substring(7));
		}

		/// <summary>
		/// Draws a property field for a story using GUILayout, allowing you to attach stories to the player window for debugging.
		/// </summary>
		/// <param name="story">Story.</param>
		/// <param name="label">Label.</param>
		public static void DrawStoryPropertyField (Story story, GUIContent label) {
			Debug.LogWarning("DrawStoryPropertyField has been moved from InkEditorUtils to InkPlayerWindow");
		}

		/// <summary>
		/// Draws a property field for a story using GUI, allowing you to attach stories to the player window for debugging.
		/// </summary>
		/// <param name="position">Position.</param>
		/// <param name="story">Story.</param>
		/// <param name="label">Label.</param>
		public static void DrawStoryPropertyField (Rect position, Story story, GUIContent label) {
			Debug.LogWarning("DrawStoryPropertyField has been moved from InkEditorUtils to InkPlayerWindow");
		}
		
		/// <summary>
		/// Checks to see if the given path is an ink file or not, regardless of extension.
		/// </summary>
		/// <param name="path">The path to check.</param>
		/// <returns>True if it's an ink file, otherwise false.</returns>
		public static bool IsInkFile(string path) {
			if (string.IsNullOrEmpty(path)) return false;
			string extension = Path.GetExtension(path);
			if (extension == InkEditorUtils.inkFileExtension) {
				return true;
			} else if (String.IsNullOrEmpty(extension)) {
				if (!File.Exists(path)) return false;
				if (File.GetAttributes(path).HasFlag(FileAttributes.Directory)) return false;
				// This check exists only in the case of ink files that lack the .ink extension.
				// We support this mostly for legacy reasons - Inky didn't used to add .ink by default which made a this relatively common issue.
				// This function needs to be speedy but getting all the ink file paths is a bit slow, so I'd like to remove support for missing extensions in the future.
				return InkLibrary.instance.inkLibrary.Exists(f => f.filePath == path);
			} else return false;
		}



		/// <summary>
		/// Opens an ink file in the associated editor at the correct line number.
		/// TODO - If the editor is inky, this code should load the master file, but immediately show the correct child file at the correct line.
		/// </summary>
		public static void OpenInEditor (InkFile inkFile, InkCompilerLog log) {
			var targetFilePath = log.GetAbsoluteFilePath(inkFile);
			// EditorUtility.OpenWithDefaultApp(targetFilePath);
			AssetDatabase.OpenAsset(inkFile.inkAsset, log.lineNumber);
			// Unity.CodeEditor.CodeEditor.OSOpenFile();
#if UNITY_2019_1_OR_NEWER

			// This function replaces OpenFileAtLineExternal, but I guess it's totally internal and can't be accessed.
			// CodeEditorUtility.Editor.Current.OpenProject(targetFilePath, lineNumber);
			// #pragma warning disable
			// UnityEditorInternal.InternalEditorUtility.OpenFileAtLineExternal(targetFilePath, log.lineNumber);
			// #pragma warning restore
#else
			UnityEditorInternal.InternalEditorUtility.OpenFileAtLineExternal(targetFilePath, log.lineNumber);
#endif
		}
		/// <summary>
		/// Opens an ink file in the associated editor at the correct line number.
		/// TODO - If the editor is inky, this code should load the master file, but immediately show the correct child file at the correct line.
		/// </summary>
		public static void OpenInEditor (string masterFilePath, string subFilePath, int lineNumber) {
			if(!string.IsNullOrEmpty(subFilePath) && Path.GetFileName(masterFilePath) != subFilePath) {
				Debug.LogWarning("Tried to open an ink file ("+subFilePath+") at line "+lineNumber+" but the file is an include file. This is not currently implemented. The master ink file will be opened at line 0 instead.");
				lineNumber = 0;
			}
			#if UNITY_2019_1_OR_NEWER
			// This function replaces OpenFileAtLineExternal, but I guess it's totally internal and can't be accessed.
			// CodeEditorUtility.Editor.Current.OpenProject(masterFilePath, lineNumber);
			#pragma warning disable
			UnityEditorInternal.InternalEditorUtility.OpenFileAtLineExternal(masterFilePath, lineNumber);
			#pragma warning restore
			#else
			UnityEditorInternal.InternalEditorUtility.OpenFileAtLineExternal(masterFilePath, lineNumber);
			#endif
		}




		public static string FormatJson(string json) {
			const string INDENT_STRING = "	";

			int indentation = 0;
			int quoteCount = 0;
			var result = 
				from ch in json
				let quotes = ch == '"' ? quoteCount++ : quoteCount
				let lineBreak = ch == ',' && quotes % 2 == 0 ? ch + Environment.NewLine +  String.Concat(Enumerable.Repeat(INDENT_STRING, indentation)) : null
				let openChar = ch == '{' || ch == '[' ? ch + Environment.NewLine + String.Concat(Enumerable.Repeat(INDENT_STRING, ++indentation)) : ch.ToString()
				let closeChar = ch == '}' || ch == ']' ? Environment.NewLine + String.Concat(Enumerable.Repeat(INDENT_STRING, --indentation)) + ch : ch.ToString()
				select lineBreak == null    
							? openChar.Length > 1 
								? openChar 
								: closeChar
							: lineBreak;

			return String.Concat(result);
		}



		// If this plugin is installed as a package, returns info about it.
		public static UnityEditor.PackageManager.PackageInfo GetPackageInfo() {
			var packageAssetPath = "Packages/com.inkle.ink-unity-integration";
			if (AssetDatabase.IsValidFolder(packageAssetPath)) return UnityEditor.PackageManager.PackageInfo.FindForAssetPath(packageAssetPath);
			else return null;
		}
		
		// Gets the root directory of this plugin, enabling us to find assets within it.
		// Less efficent if not installed as a package because the location/folder name is not known.
		public static string FindAbsolutePluginDirectory() {
			var packageInfo = GetPackageInfo();
			if (packageInfo != null) {
				return packageInfo.resolvedPath;
			} else {
				// Find the InkLibs folder. We assume that it exists in the top level of the plugin folder. We use this folder because it has a fairly unique name and is essential for the plugin to function.
				string[] guids = AssetDatabase.FindAssets("t:DefaultAsset", new[] {"Assets"}).Where(g => AssetDatabase.GUIDToAssetPath(g).EndsWith("/InkLibs")).ToArray();
				if (guids.Length > 0) {
					var assetPathOfInkLibsFolder = AssetDatabase.GUIDToAssetPath(guids[0]);
					var rootPluginFolder = assetPathOfInkLibsFolder.Substring(0, assetPathOfInkLibsFolder.Length - "/InkLibs".Length);
					return Path.GetFullPath(Path.Combine(Application.dataPath, "..", rootPluginFolder));
				}
			}
			return null; // If no folder is found
		}
	}
}

--- Путь к файлу: .\Assets\Ink\Editor\Core\Compiler\InkCompiler.cs ---

﻿using UnityEngine;
using UnityEditor;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Threading;
using Debug = UnityEngine.Debug;

namespace Ink.UnityIntegration {
	// Ink Compiler handles the compilation of Ink Files, storing and logging todos, warnings and errors.
	// It manages a queue of items, ensuring that each file is completed in sequence.
	
	// Ink compilation is handled automatically when ink files change (via InkPostProcessor), but you can also manually trigger compilation.
	// The simplest usage is InkCompiler.CompileInk(inkFile). 
	// You can also specify if the compilation should be immediate or async, and provide a callback for when the queue completes.
	// Logs are fired when compilation begins and completes.

	// To ensure that compilation always completes reliably, this class also manages delaying entering play mode and cancels builds kicked off while mid-compile.
	
	// InkCompiler is designed as a ScriptableObject and is saved to the Library folder so that the queue persists across compilation.
	// The way we currently handle threads isn't great. I'd love for a member of the community to find a better way to do it!
	#if UNITY_2020_1_OR_NEWER
    [FilePath("Library/InkCompiler.asset", FilePathAttribute.Location.ProjectFolder)]
	public class InkCompiler : ScriptableSingleton<InkCompiler> {
    #else
	public class InkCompiler : ScriptableObject {
    #endif
		#region Legacy ScriptableSingleton
        #if !UNITY_2020_1_OR_NEWER
		public static bool created {
			get {
				return (_instance != (UnityEngine.Object) null);
			}
		}
		private static InkCompiler _instance;
		public static InkCompiler instance {
			get {
				if(!created)
                	LoadOrCreateInstance();
				return _instance;
			} private set {
				if(_instance == value) return;
				_instance = value;
            }
		}
        
		static string absoluteSavePath {
			get {
				return System.IO.Path.GetFullPath(System.IO.Path.Combine(System.IO.Directory.GetCurrentDirectory(),"Library","InkCompiler.asset"));
			}
		}
		public static void LoadOrCreateInstance () {
			InternalEditorUtility.LoadSerializedFileAndForget(absoluteSavePath);
			if(created) {
				if(InkEditorUtils.isFirstCompile) {
					ClearCompilationStacks();
				}
			} else {
				instance = ScriptableObject.CreateInstance<InkCompiler>();
				instance.hideFlags = HideFlags.HideAndDontSave;
			}
		}
		public void Save (bool saveAsText) {
			InternalEditorUtility.SaveToSerializedFileAndForget((UnityEngine.Object[]) new InkCompiler[1] {this}, absoluteSavePath, saveAsText);
		}

		protected InkCompiler () {
			if (created)
				Debug.LogError((object) "ScriptableSingleton already exists. Did you query the singleton in a constructor?");
			else {
				instance = this;
			}
		}
        #endif
		#endregion


		#region Public Facing
		// If any items are queued, compiling, or complete!
		// If any items are in the queue, one is guaranteed to be compiling (or should begin to or complete imminently).
		public static bool executingCompilationStack {
			get {
				return instance.compilationStack.Count > 0;
			}
		}

		// This runs once when the compilation stack completes.
		public delegate void OnCompleteInkCompliationStackEvent (InkFile[] inkFiles);
		public static event OnCompleteInkCompliationStackEvent OnCompileInk;

		
		[Serializable]
		public enum CompilationStackItemState {
			// Default state, item is about to be queued for compilation
			Queued,
			
			// Item is now owned by the thread pool and being compiled
			Compiling,
			
			// Compilation has finished, item to be processed for errors and result handled
			Complete,
		}

		
		public static void CompileInk (params InkFile[] inkFiles) {
            CompileInk(inkFiles, false, null);
        }
		public static void CompileInk (InkFile[] inkFiles, bool immediate, Action onComplete = null) {
			if(inkFiles == null || inkFiles.Length == 0) return;
			#if UNITY_2019_4_OR_NEWER
			if(!disallowedAutoRefresh) {
				disallowedAutoRefresh = true;
				try {
					AssetDatabase.DisallowAutoRefresh();
				} catch (Exception e) {
					Debug.LogWarning("Failed DisallowAutoRefresh "+e);
				}
			}
			#endif
            
			InkLibrary.Validate();
            if(onComplete != null) onCompleteActions.Add(onComplete);
			StringBuilder filesCompiledLog = new StringBuilder("Files compiled:");
			foreach (var inkFile in inkFiles) filesCompiledLog.AppendLine().Append(inkFile.filePath);
			
			StringBuilder outputLog = new StringBuilder ();
			outputLog.Append ("Ink compilation started at ");
			outputLog.AppendLine (DateTime.Now.ToLongTimeString ());
			outputLog.Append (filesCompiledLog.ToString());
			Debug.Log(outputLog);
			
			foreach(var inkFile in inkFiles) {
				CompileInkInternal (inkFile, immediate);
			}
		}


		public static void SetBuildBlocked () {
			buildBlocked = true;
		}


        public static void AddToPendingCompilationStack (string filePath) {
			if(!instance.pendingCompilationStack.Contains(filePath)) {
				instance.pendingCompilationStack.Add(filePath);
				instance.Save(true);
			}
		}

        public static void RemoveFromPendingCompilationStack (InkFile inkFile) {
            bool anyChange = false;
			anyChange = instance.pendingCompilationStack.Remove(inkFile.filePath) || anyChange;
            foreach(var includeFile in inkFile.includesInkFiles) {
                anyChange = instance.pendingCompilationStack.Remove(includeFile.filePath) || anyChange;
            }
			if(anyChange)
				instance.Save(true);
        }

		public static bool AnyOfStateInCompilationStack (CompilationStackItemState state) {
			foreach(var compilationStackItem in instance.compilationStack) {
				if(compilationStackItem.state == state) 
					return true;
			}
			return false;
		}
		public static int CountOfStateInCompilationStack (CompilationStackItemState state) {
			int count = 0;
			foreach(var compilationStackItem in instance.compilationStack) {
				if(compilationStackItem.state == state) 
					count++;
			}
			return count;
		}
		static CompilationStackItem GetCurrentlyCompilingFile () {
			foreach(var compilationStackItem in instance.compilationStack) {
				if(compilationStackItem.state == CompilationStackItemState.Compiling) {
					return compilationStackItem;
				}
			}
			return null;
		}

		public static bool IsInkFileOnCompilationStack (InkFile inkFile) {
			foreach(var compilationStackItem in instance.compilationStack) {
				if(compilationStackItem.inkFile == inkFile) 
					return true;
			}
			return false;
		}

		// Find all the master ink files in a list of assets given by path.
		public static List<InkFile> GetUniqueMasterInkFilesToCompile (List<string> importedInkAssets) {
			List<InkFile> masterInkFiles = new List<InkFile>();
			foreach (var importedAssetPath in importedInkAssets) {
                foreach(var masterInkFile in GetMasterFilesIncludingInkAssetPath(importedAssetPath)) {
					if (!masterInkFiles.Contains(masterInkFile) && InkSettings.instance.ShouldCompileInkFileAutomatically(masterInkFile)) {
						masterInkFiles.Add(masterInkFile);
					}
				}
            }
			return masterInkFiles;
			
			// An ink file might actually have several owners! Return them all.
			IEnumerable<InkFile> GetMasterFilesIncludingInkAssetPath (string importedAssetPath) {
				InkFile inkFile = InkLibrary.GetInkFileWithPath(importedAssetPath);
				// Trying to catch a rare (and not especially important) bug that seems to happen occasionally when opening a project
				// It's probably this - I've noticed it before in another context.
				Debug.Assert(InkSettings.instance != null, "No ink settings file. This is a bug. For now you should be able to fix this via Assets > Rebuild Ink Library");
				// I've caught it here before
				Debug.Assert(inkFile != null, "No internal InkFile reference at path "+importedAssetPath+". This is a bug. For now you can fix this via Assets > Rebuild Ink Library");
				Debug.Assert(inkFile != null);
				return inkFile.masterInkFilesIncludingSelf;
			}
		}
		#endregion


		#region Static Private Variables
		// If we just blocked a build because of an ink compile
		static bool buildBlocked = false;
		// If we just blocked entering play mode because of an ink compile
		static bool playModeBlocked = false;


		// Track if we've currently locked compilation of Unity C# Scripts
		static bool hasLockedUnityCompilation = false;
		
		// When compiling we call AssetDatabase.DisallowAutoRefresh. 
		// We NEED to remember to re-allow it or unity stops registering file changes!
		// The issue is that you need to pair calls perfectly, and you can't even use a try-catch to get around it.
		// So - we cache if we've disabled auto refresh here, since this persists across plays.
		static bool disallowedAutoRefresh {
			get => SessionState.GetBool("InkLibraryDisallowedAutoRefresh", false);
			set => SessionState.SetBool("InkLibraryDisallowedAutoRefresh", value);
		}

        // Actions that are passed into the CompileInk function, to run and then clear when we complete the compilation stack.
		// To recieve an event each time the stack completes, see OnCompileInk.
        static List<Action> onCompleteActions = new List<Action>();
		
		// Thread lock
		static bool compileThreadActive {
			get {
				lock(_compileThreadActiveLock) {
					return _compileThreadActive;
				}
			}
			set {
				lock(_compileThreadActiveLock) {
					_compileThreadActive = value;
				}
			}
		}
		static bool _compileThreadActive;
		static object _compileThreadActiveLock = new object();
		#endregion

		#if UNITY_2020_2_OR_NEWER
		// ID for the Unity Progress API, which shows progress of the compile in the bottom right of Unity.
		static int compileProgressID;
		#endif
		
		#region Serialized Private Variables
		// If InkSettings' delayInPlayMode option is true, dirty files are added here when they're changed in play mode
		// This ensures they're remembered when you exit play mode and can be compiled
		// TODO - It might be safer for this to track the DefaultAsset for the ink file, rather than the path?
		[SerializeField]
		List<string> pendingCompilationStack = new List<string>();

		// The state of files currently being compiled.
		[SerializeField]
		List<InkCompiler.CompilationStackItem> compilationStack = new List<InkCompiler.CompilationStackItem>();
		#endregion
		
		[System.Serializable]
		class CompilationStackItem {
			public CompilationStackItemState state = CompilationStackItemState.Queued;
			public bool immediate;
			public InkFile inkFile;
			public string compiledJson;
			public string inkAbsoluteFilePath;
			public string jsonAbsoluteFilePath;
			public List<InkCompilerLog> logOutput = new List<InkCompilerLog>();
			public List<string> unhandledErrorOutput = new List<string>();
			public DateTime startTime;
			public DateTime endTime;

			public float timeTaken {
				get {
					if(state == CompilationStackItemState.Complete) return (float)(endTime - startTime).TotalSeconds;
					else return (float)(DateTime.Now - startTime).TotalSeconds;
				}
			}

			public CompilationStackItem () {}
			
			// Sets errors, warnings and todos to the ink file, and logs them to the console.
			public void SetOutputLog () {
				inkFile.errors.Clear();
				inkFile.warnings.Clear();
				inkFile.todos.Clear();

				foreach(var childInkFile in inkFile.includesInkFiles) {
					childInkFile.unhandledCompileErrors.Clear();
					childInkFile.errors.Clear();
					childInkFile.warnings.Clear();
					childInkFile.todos.Clear();
				}

				foreach(var output in logOutput) {
					if(output.type == ErrorType.Error) {
						inkFile.errors.Add(output);
						Debug.LogError("Ink "+output.type+" for "+Path.GetFileName(inkFile.filePath)+": "+output.content + " (at "+output.relativeFilePath+":"+output.lineNumber+")", inkFile.inkAsset);
					} else if (output.type == ErrorType.Warning) {
						inkFile.warnings.Add(output);
						Debug.LogWarning("Ink "+output.type+" for "+Path.GetFileName(inkFile.filePath)+": "+output.content + " (at "+output.relativeFilePath+" "+output.lineNumber+")", inkFile.inkAsset);
					} else if (output.type == ErrorType.Author) {
						inkFile.todos.Add(output);
						if(InkSettings.instance.printInkLogsInConsoleOnCompile)
							Debug.Log("Ink Log for "+Path.GetFileName(inkFile.filePath)+": "+output.content + " (at "+output.relativeFilePath+" "+output.lineNumber+")", inkFile.inkAsset);
					}
				}
			}
		}


		#region Init, Update, Saving
        // Ensure we save the InkCompiler state when we save assets.
        class AssetSaver : UnityEditor.AssetModificationProcessor {
            static string[] OnWillSaveAssets(string[] paths) {
                InkCompiler.instance.Save(true);
                return paths;
            }
        }

		// This is called when Unity recompiles. 
		[InitializeOnLoadMethod]
		static void OnProjectLoadedInEditor() {
			#if UNITY_2017_1_OR_NEWER
			EditorApplication.playModeStateChanged += OnPlayModeChange;
			#else
			EditorApplication.playmodeStateChanged += LegacyOnPlayModeChange;
			#endif
			EditorApplication.update += Update;
            // I really don't know if this can fire, since it assumes that it compiled so can't have been locked. But safety first!
            EditorApplication.UnlockReloadAssemblies();
			#if UNITY_2019_4_OR_NEWER
			// This one, on the other hand, seems to actually occur sometimes - presumably because c# compiles at the same time as the ink.
			if(disallowedAutoRefresh) {
				disallowedAutoRefresh = false;
				try {
					AssetDatabase.AllowAutoRefresh();
				} catch (Exception e) {
					Debug.LogWarning("Failed AllowAutoRefresh "+e);
				}
			}
			#endif
		}
		
		// Update loop, using the EditorApplication.update callback.
		private static void Update () {
            #if UNITY_2020_1_OR_NEWER
            // If we're not compiling but have locked C# compilation then now is the time to reset
			if (!executingCompilationStack && hasLockedUnityCompilation) {
				hasLockedUnityCompilation = false;
				EditorApplication.UnlockReloadAssemblies();
			}
			#else
            // If we're not compiling but have locked C# compilation then now is the time to reset
			if ((!InkLibrary.created || !compiling) && hasLockedUnityCompilation) {
				hasLockedUnityCompilation = false;
				EditorApplication.UnlockReloadAssemblies();
			}
			if(!InkLibrary.created) 
				return;
            #endif

			// If we're working through the stack. This is true as soon as an item is added to the stack.
			if(executingCompilationStack) {
				// Check for timeouts, in case of an unhandled bug with this system/the ink compiler!
				for (int i = instance.compilationStack.Count - 1; i >= 0; i--) {
					var compilingFile = instance.compilationStack [i];
					if (compilingFile.state == CompilationStackItemState.Compiling) {
						if (compilingFile.timeTaken > InkSettings.instance.compileTimeout) {
							// TODO - Cancel the thread if it's still going. Not critical, since its kinda fine if it compiles a bit later, but it's not clear.
							compileThreadActive = false;
							RemoveCompilingFile(i);
							Debug.LogError("Ink Compiler timed out for "+compilingFile.inkAbsoluteFilePath+".\nCompilation should never take more than a few seconds, but for large projects or slow computers you may want to increase the timeout time in the InkSettings file.\nIf this persists there may be another issue; or else check an ink file exists at this path and try Assets/Recompile Ink, else please report as a bug with the following error log at this address: https://github.com/inkle/ink/issues\nError log:\n"+string.Join("\n",compilingFile.unhandledErrorOutput.ToArray()));
							TryCompileNextFileInStack();
						}
					}
				}

				// When all files have compiled, run the complete function.
				if(!AnyOfStateInCompilationStack(CompilationStackItemState.Compiling)) {
					if(!AnyOfStateInCompilationStack(CompilationStackItemState.Queued)) {
						OnCompleteCompilationStack();
					} else {
						// We used to avoid calling this here in favour of calling it CompileInkThreaded but it seems that it doesn't run when called there, for some reason.
						// If someone can make this work please let me know!
						TryCompileNextFileInStack();
					}
				}
				// When the current item being compiled using threads has finished, we set compileThreadActive to false.
				// Here we then set the compiling file's state from Compiling to Complete.
				// This roundabout way of doing things ensures that all CompilationStackItem code runs entirely outside of the thread.  
				else if(!compileThreadActive) {
					for (int i = instance.compilationStack.Count - 1; i >= 0; i--) {
						var compilingFile = instance.compilationStack [i];
						if (compilingFile.state == CompilationStackItemState.Compiling) {
							CompleteCompilingFile(compilingFile);
							break;
						}
					}
				}
			}


			// We don't show a progress bar on Linux (there appeared to be a Unity bug on an earlier version), so skip this step there.
			#if !UNITY_EDITOR_LINUX
			UpdateProgressBar();
			#endif
		}
		#endregion
		

		#region Compilation

		// Move files from the pendingCompilationStack to the compilationStack
		static void CompilePendingFiles () {
			InkLibrary.CreateOrReadUpdatedInkFiles (instance.pendingCompilationStack);
			foreach (var pendingMasterFile in GetUniqueMasterInkFilesToCompile(instance.pendingCompilationStack))
				CompileInk(pendingMasterFile);
		}

		/// <summary>
		/// Starts a System.Process that compiles a master ink file, creating a playable JSON file that can be parsed by the Ink.Story class
		/// </summary>
		/// <param name="inkFile">Ink file.</param>
		private static void CompileInkInternal (InkFile inkFile, bool immediate) {
			if(inkFile == null) {
				Debug.LogError("Tried to compile ink file but input was null.");
				return;
			}
			if(!inkFile.isMaster)
				Debug.LogWarning("Compiling InkFile which is an include. Any file created is likely to be invalid. Did you mean to call CompileInk on inkFile.master?");

			// If we've not yet locked C# compilation do so now
			if (!hasLockedUnityCompilation)
			{
				hasLockedUnityCompilation = true;
				EditorApplication.LockReloadAssemblies();
			}
			
            RemoveFromPendingCompilationStack(inkFile);
			if(IsInkFileOnCompilationStack(inkFile)) {
				UnityEngine.Debug.LogWarning("Tried compiling ink file, but file is already compiling. "+inkFile.filePath);
				return;
			}

			string inputPath = InkEditorUtils.CombinePaths(inkFile.absoluteFolderPath, Path.GetFileName(inkFile.filePath));
			Debug.Assert(inkFile.absoluteFilePath == inputPath);

			CompilationStackItem pendingFile = new CompilationStackItem
			{
				inkFile = InkLibrary.GetInkFileWithAbsolutePath(inputPath),
				inkAbsoluteFilePath = inputPath,
				jsonAbsoluteFilePath = inkFile.absoluteJSONPath,
				state = CompilationStackItemState.Queued,
				immediate = immediate
			};
			
			if(instance.compilationStack.Count == 0) OnBeginCompilationStack();
			instance.compilationStack.Add(pendingFile);
			instance.Save(true);
			
			TryCompileNextFileInStack();
		}

		private static void TryCompileNextFileInStack () {
			if(!executingCompilationStack) return;
			if(AnyOfStateInCompilationStack(CompilationStackItemState.Compiling)) return;
			
			// Find the next file to compile!
			CompilationStackItem fileToCompile = null;
			foreach(var compilationItem in instance.compilationStack) {
				if(compilationItem.state == CompilationStackItemState.Queued) {
					fileToCompile = compilationItem;
					break;
				}
			}

			// If a file was found, compile it according to its settings.
			if(fileToCompile != null) {
				BeginCompilingFile(fileToCompile);
				if(fileToCompile.immediate) {
					CompileInkThreaded(fileToCompile);
					CompleteCompilingFile(fileToCompile);
				} else {
					if(EditorApplication.isCompiling) Debug.LogWarning("Was compiling scripts when ink compilation started! This seems to cause the thread to cancel and complete, but the work isn't done. It may cause a timeout.");
					compileThreadActive = true;
					ThreadPool.QueueUserWorkItem(CompileInkThreaded, fileToCompile);
					// CompleteCompilingFile is called in Update when compileThreadActive becomes false.
				}
			}
		}
	
		// Removes a file from the compilation stack.
        static void RemoveCompilingFile (int index) {
            instance.compilationStack.RemoveAt(index);
            instance.Save(true);
            // Progress bar prevents delayCall callback from firing in Linux Editor, locking the
            // compilation until it times out. Let's just not show progress bars in Linux Editor    
            #if !UNITY_EDITOR_LINUX
            if (instance.compilationStack.Count == 0) EditorUtility.ClearProgressBar();
            #endif
        }

		// Marks a CompilationStackItem as Compiling
		private static void BeginCompilingFile(CompilationStackItem item) {
			if(item.state != CompilationStackItemState.Queued) {
				Debug.LogError("Cannot begin compiling ink file because it is "+item.state+"! This is most likely a threading bug. Please report this!");
				return;
			}
			item.state = CompilationStackItemState.Compiling;
			item.startTime = DateTime.Now;
			#if UNITY_2020_2_OR_NEWER
			Progress.SetStepLabel(compileProgressID, item.inkFile.filePath);
			Progress.Report(compileProgressID, instance.compilationStack.IndexOf(item), instance.compilationStack.Count);
			#endif
		}

		// Marks a CompilationStackItem as Complete
		private static void CompleteCompilingFile(CompilationStackItem item) {
			if(item.state != CompilationStackItemState.Compiling) {
				Debug.LogError("Cannot complete compiling ink file because it is "+item.state+"! This is most likely a threading bug. Please report this!");
				return;
			}
			item.state = CompilationStackItemState.Complete;
			item.endTime = DateTime.Now;
			if (item.timeTaken > InkSettings.instance.compileTimeout * 0.6f)
				Debug.LogWarning ("Compilation for "+Path.GetFileName(item.inkFile.filePath)+" took over 60% of the time required to timeout the compiler. Consider increasing the compile timeout on the InkSettings file.");
			
			// If there's nothing left to compile, we can mark the stack as done!
			if(!AnyOfStateInCompilationStack(CompilationStackItemState.Compiling) && !AnyOfStateInCompilationStack(CompilationStackItemState.Queued))
				OnCompleteCompilationStack();
		}

		// Runs a new instance of Ink.Compiler, performing the actual compilation process!
		// Can be run from a thread or syncronously.
		// Ink is not threadsafe, and so this function should never be run twice simultaneously.
		// For this reason, this function doesn't set CompilationStackItem.state.
		private static void CompileInkThreaded(object itemObj) {
			CompilationStackItem item = (CompilationStackItem) itemObj;
			if(item.state != CompilationStackItemState.Compiling) Debug.LogError("File passed to CompileInkThreaded is not in Compiling state.");

			var inputString = File.ReadAllText(item.inkAbsoluteFilePath);
			var compiler = new Compiler(inputString, new Compiler.Options
			{
				countAllVisits = true,
				fileHandler = new UnityInkFileHandler(Path.GetDirectoryName(item.inkAbsoluteFilePath)),
				errorHandler = (string message, ErrorType type) => {
					InkCompilerLog log;
					if(InkCompilerLog.TryParse(message, out log)) {
						if(string.IsNullOrEmpty(log.relativeFilePath)) log.relativeFilePath = Path.GetFileName(item.inkAbsoluteFilePath);
						item.logOutput.Add(log);
					} else {
						Debug.LogWarning("Couldn't parse log "+message);
					}
				}
			});

			try {
				var compiledStory = compiler.Compile();
				if (compiledStory != null)
					item.compiledJson = compiledStory.ToJson();
			} catch (SystemException e) {
				item.unhandledErrorOutput.Add(string.Format(
					"Ink Compiler threw exception \nError: {0}\n---- Trace ----\n{1}\n--------\n", e.Message,
					e.StackTrace));
			}

			// This MUST be the very last thing to occur in this function!
			compileThreadActive = false;
		}

		// When the compilation stack first gains an item
		private static void OnBeginCompilationStack () {
			#if UNITY_2020_2_OR_NEWER
			compileProgressID = Progress.Start("Compiling Ink", null, Progress.Options.None, -1);
			#endif
		}

		// When all files in stack have been compiled. 
		// This is called via update because Process events run in another thread.
		// It's now also called via CompleteCompilingFile, which enables immediate mode compliation to run synchronously!
		private static void OnCompleteCompilationStack () {
			if(AnyOfStateInCompilationStack(CompilationStackItemState.Queued)) {
				Debug.LogError("OnCompleteCompilationStack was called, but a file is now in the queue!");
				return;
			}
			if(AnyOfStateInCompilationStack(CompilationStackItemState.Compiling)) {
				Debug.LogError("OnCompleteCompilationStack was called, but a file is now compiling!");
				return;
			}
            // Clone and clear the list. This is a surefire way to ensure the list is cleared in case of unhandled errors in this code.
            // A Try-catch would be better but I'm debugging blind as I write this and the nuclear option will definitely work!
            List<CompilationStackItem> compilationStack = new List<CompilationStackItem>(instance.compilationStack);
			instance.compilationStack.Clear();
			instance.Save(true);



            // Create and import compiled files
			AssetDatabase.StartAssetEditing();
			foreach (var compilingFile in compilationStack) {
				// Complete status is also set when an error occured, in these cases 'compiledJson' will be null so there's no import to process
				if (compilingFile.compiledJson == null) continue;
				
				// Write new compiled data to the file system
				File.WriteAllText(compilingFile.jsonAbsoluteFilePath, compilingFile.compiledJson, Encoding.UTF8);
                if(compilingFile.inkFile.inkAsset != null) AssetDatabase.ImportAsset(compilingFile.inkFile.jsonPath);
			}
			AssetDatabase.StopAssetEditing();


			// Sets output info for each InkFile (todos, warnings and errors); produces and fires the post-compliation log
			bool errorsFound = false;
			StringBuilder filesCompiledLog = new StringBuilder("Files compiled:");
			foreach (var compilingFile in compilationStack) {
				if(compilingFile.inkFile.inkAsset != null) {
                    // Load and store a reference to the compiled file
                    compilingFile.inkFile.FindCompiledJSONAsset();
                    
                    filesCompiledLog.AppendLine().Append(compilingFile.inkFile.filePath);
                    filesCompiledLog.Append(string.Format(" ({0}s)", compilingFile.timeTaken));
                    if(compilingFile.unhandledErrorOutput.Count > 0) {
                        filesCompiledLog.Append(" (With unhandled error)");
                        StringBuilder errorLog = new StringBuilder ();
                        errorLog.Append ("Unhandled error(s) occurred compiling Ink file ");
                        errorLog.Append ("'");
                        errorLog.Append (compilingFile.inkFile.filePath);
                        errorLog.Append ("'");
                        errorLog.AppendLine ("! You may be able to resolve your issue by using Edit > Rebuild Ink Library.");
                        errorLog.AppendLine ("Please report following error(s) as a bug:");
                        foreach (var error in compilingFile.unhandledErrorOutput)
                            errorLog.AppendLine (error);
                        Debug.LogError(errorLog);
                        compilingFile.inkFile.unhandledCompileErrors = compilingFile.unhandledErrorOutput;
                        errorsFound = true;
                    } else {
                        compilingFile.SetOutputLog();
                        bool errorsInEntireStory = false;
                        bool warningsInEntireStory = false;
                        foreach(var inkFile in compilingFile.inkFile.includesInkFiles) {
                            if(inkFile.hasErrors) {
                                errorsInEntireStory = true;
                            }
                            if(inkFile.hasWarnings) {
                                warningsInEntireStory = true;
                            }
                        }
                        if(errorsInEntireStory) {
                            filesCompiledLog.Append(" (With error)");
                            errorsFound = true;
                        }
                        if(warningsInEntireStory) {
                            filesCompiledLog.Append(" (With warning)");
                        }
                    }
                } else {
                    filesCompiledLog.AppendLine().Append(compilingFile.inkAbsoluteFilePath);
                    filesCompiledLog.Append(" (With post-compile missing file error)");
                    Debug.LogError("Ink file at "+compilingFile.inkAbsoluteFilePath+" was not found after compilation");
                }
			}

			StringBuilder outputLog = new StringBuilder ();
			if(errorsFound) {
				outputLog.Append ("Ink compilation completed with errors at ");
				outputLog.AppendLine (DateTime.Now.ToLongTimeString ());
				outputLog.Append (filesCompiledLog.ToString());
				Debug.LogError(outputLog);
			} else {
				outputLog.Append ("Ink compilation completed at ");
				outputLog.AppendLine (DateTime.Now.ToLongTimeString ());
				outputLog.Append (filesCompiledLog.ToString());
				Debug.Log(outputLog);
			}


			// Clean up locks and progress bars
			#if UNITY_2020_2_OR_NEWER
			Progress.Remove(compileProgressID);
			compileProgressID = -1;
			#endif
			
			#if !UNITY_EDITOR_LINUX
			EditorUtility.ClearProgressBar();
			#endif
			
			#if UNITY_2019_4_OR_NEWER
			if(disallowedAutoRefresh) {
				disallowedAutoRefresh = false;
				try {
					AssetDatabase.AllowAutoRefresh();
				} catch (Exception e) {
					Debug.LogWarning("Failed AllowAutoRefresh "+e);
				}
			}
			#endif

            // This is now allowed, if compiled manually. I've left this code commented out because at some point we might want to track what caused a file to compile. 
            // if(EditorApplication.isPlayingOrWillChangePlaymode && InkSettings.instance.delayInPlayMode) {
			// 	Debug.LogError("Ink just finished recompiling while in play mode. This should never happen when InkSettings.instance.delayInPlayMode is true!");
			// }
            
            buildBlocked = false;


			// Fires completion events
            foreach(var onCompleteAction in onCompleteActions) {
                if(onCompleteAction != null) onCompleteAction();
            }
            onCompleteActions.Clear();
			
			if (OnCompileInk != null) {
				InkFile[] inkFilesCompiled = new InkFile[compilationStack.Count];
				for (int i = 0; i < compilationStack.Count; i++) {
					inkFilesCompiled[i] = compilationStack[i].inkFile;
				}
				if(OnCompileInk != null) OnCompileInk (inkFilesCompiled);
			}


			// If we wanted to enter play mode but were blocked because of ink compliation, enter play mode now.
			if(playModeBlocked) {
                playModeBlocked = false;
				if(!errorsFound) {
					// Delaying gives the editor a frame to clear the progress bar.
					EditorApplication.delayCall += () => {
						Debug.Log("Compilation completed, entering play mode.");
						EditorApplication.isPlaying = true;
					};
				} else {
					Debug.LogWarning("Play mode not entered after ink compilation because ink had errors.");
				}
			}
			
		}
		#endregion

		
		#region Progress Bar
		static void UpdateProgressBar () {
			if(instance.compilationStack.Count == 0) return;
			if(buildBlocked || playModeBlocked || EditorApplication.isPlaying) ShowProgressBar();
			else EditorUtility.ClearProgressBar();
		}

		public static void ShowProgressBar () {
			int numCompiling = CountOfStateInCompilationStack(CompilationStackItemState.Compiling);
			var compilingFile = GetCurrentlyCompilingFile();
			string message = "";
			if(compilingFile == null) message += "Compiling...";
			else message += "Compiling "+compilingFile.inkFile.inkAsset.name+" for "+compilingFile.timeTaken+"s";
			message += "\n.Ink File "+(instance.compilationStack.Count-numCompiling)+" of "+instance.compilationStack.Count+".";
			if(playModeBlocked) message += " Will enter play mode when complete.";
			EditorUtility.DisplayProgressBar("Compiling Ink...", message, GetEstimatedCompilationProgress());
		}

		public static float GetEstimatedCompilationProgress () {
			if(!executingCompilationStack) return 1;
			float progress = 0;
			foreach (var compilingFile in instance.compilationStack) {
				if (compilingFile.state == CompilationStackItemState.Compiling)
					progress += compilingFile.timeTaken / InkSettings.instance.compileTimeout;
				if (compilingFile.state == CompilationStackItemState.Complete)
					progress += 1;
			}
			progress /= instance.compilationStack.Count;
			return progress;
		}
		#endregion


		#region Prevent entering Play Mode while mid-compile
		#if UNITY_2017_1_OR_NEWER
		static void OnPlayModeChange (PlayModeStateChange mode) {
			if(mode == PlayModeStateChange.EnteredEditMode && instance.pendingCompilationStack.Count > 0)
				CompilePendingFiles();
			if(mode == PlayModeStateChange.ExitingEditMode && executingCompilationStack)
				BlockPlayMode();
			if(mode == PlayModeStateChange.EnteredPlayMode && executingCompilationStack)
				EnteredPlayModeWhenCompiling();
		}
		#else
		static void LegacyOnPlayModeChange () {
			if(!EditorApplication.isPlayingOrWillChangePlaymode && EditorApplication.isPlaying && instance.pendingCompilationStack.Count > 0) 
				CompilePendingFiles();
			if(EditorApplication.isPlayingOrWillChangePlaymode && !EditorApplication.isPlaying && compiling)
				BlockPlayMode();
			if(EditorApplication.isPlayingOrWillChangePlaymode && EditorApplication.isPlaying && compiling)
				EnteredPlayModeWhenCompiling();
		}
		#endif

		static void BlockPlayMode () {
			EditorApplication.isPlaying = false;
			var percentage = String.Format("{0:P0}.", GetEstimatedCompilationProgress());
			Debug.LogWarning("Delayed entering play mode because Ink is still compiling ("+percentage+"). Will enter play mode on completion.");
			playModeBlocked = true;
		}

		static void EnteredPlayModeWhenCompiling () {
			Debug.LogError("Entered Play Mode while Ink was still compiling! Your story will not be up to date. Recommend exiting and re-entering play mode.\nWe normally delay entering play mode when compiling, so you've found an edge case!");
		}
		#endregion
	}
}

--- Путь к файлу: .\Assets\Ink\Editor\Core\Compiler\UnityInkFileHandler.cs ---

﻿using Ink;
using System.IO;

// Utility class for the ink compiler, used to work out how to find include files and their contents
public class UnityInkFileHandler : IFileHandler {
    private readonly string rootDirectory;

    public UnityInkFileHandler(string rootDirectory)
    {
        this.rootDirectory = rootDirectory;
    }
    
    public string ResolveInkFilename(string includeName)
    {
        // Convert to Unix style, and then use FileInfo.FullName to parse any ..\
        return new FileInfo(Path.Combine(rootDirectory, includeName).Replace('\\', '/')).FullName;
    }

    public string LoadInkFileContents(string fullFilename)
    {
        return File.ReadAllText(fullFilename);
    }
}

--- Путь к файлу: .\Assets\Ink\Editor\Core\Compiler\Auto Compiler\InkPostProcessor.cs ---

﻿// Automatically creates JSON files from an ink placed within the Assets/Ink folder.
using UnityEngine;
using UnityEditor;
using System.IO;
using Debug = UnityEngine.Debug;
using System.Collections.Generic;
using System.Linq;

namespace Ink.UnityIntegration {
	
	public class InkPostProcessor : AssetPostprocessor {
		// Several assets moved at the same time can cause unity to call OnPostprocessAllAssets several times as a result of moving additional files, or simply due to minor time differences.
		// This queue tells the compiler which files to recompile after moves have completed.
		// Not a perfect solution - If Unity doesn't move all the files in the same attempt you can expect some error messages to appear on compile.
		private static List<string> queuedMovedInkFileAssets = new List<string>();
		
		// We should make this a stack, similar to GUI.BeginDisabledGroup.
		public static bool disabled = false;
		// I'd like to make this a public facing setting sometime. Options are async or immediate.
		public static bool compileImmediatelyOnImport = false;
		// Recompiles any ink files as a result of an ink file (re)import
		private static void OnPostprocessAllAssets (string[] importedAssets, string[] deletedAssets, string[] movedAssets, string[] movedFromAssetPaths) {
			if(disabled) return;
			if(deletedAssets.Length > 0) {
				OnDeleteAssets(deletedAssets);
			}
			if(movedAssets.Length > 0) {
				OnMoveAssets(movedAssets);
			}
			if(importedAssets.Length > 0) {
				// Assets that are renamed are both moved and imported. We do all the work in OnMoveAssets, so do nothing here.
				var importedAssetsThatWerentRenames = importedAssets.Except(movedAssets).ToArray();
				OnImportAssets(importedAssetsThatWerentRenames);
			}
            #if !UNITY_2020_1_OR_NEWER
			if(InkLibrary.created)
            #endif
            InkLibrary.Clean();
		}

		private static void OnDeleteAssets (string[] deletedAssets) {
			bool deletedInk = false;
			foreach (var deletedAssetPath in deletedAssets) {
				if(InkEditorUtils.IsInkFile(deletedAssetPath)) {
					deletedInk = true;
					break;
				}
			}
			if(!deletedInk)
				return;

//			bool alsoDeleteJSON = false;
//			alsoDeleteJSON = EditorUtility.DisplayDialog("Deleting .ink file", "Also delete the JSON file associated with the deleted .ink file?", "Yes", "No"));
			List<InkFile> masterFilesAffected = new List<InkFile>();
			for (int i = InkLibrary.instance.inkLibrary.Count - 1; i >= 0; i--) {
				var inkFile = InkLibrary.instance.inkLibrary[i];
				// If this file was deleted...
				if(inkFile.inkAsset == null) {
					// Mark the master files to be recompiled (note that those files might also have been deleted)
					if(!inkFile.isMaster) {
						foreach(var masterInkAsset in inkFile.masterInkAssets) {
							if(masterInkAsset != null) {
								var masterInkFile = InkLibrary.GetInkFileWithFile(masterInkAsset);
								if(!masterFilesAffected.Contains(masterInkFile))
									masterFilesAffected.Add(masterInkFile);
							}
						}
					}
					// Delete the associated json file
					if(InkSettings.instance.handleJSONFilesAutomatically) {
                        var assetPath = AssetDatabase.GetAssetPath(inkFile.jsonAsset);
						if(assetPath != null && assetPath != string.Empty) {
                            AssetDatabase.DeleteAsset(assetPath);
                        }
                    }
					// Finally, remove it from the ink library
					InkLibrary.RemoveAt(i);
				}
			}

			// After deleting files, we might have broken some include references, so we rebuild them. There's probably a faster way to do this, or we could probably just remove any null references, but this is a bit more robust.
			InkLibrary.RebuildInkFileConnections();
			
			foreach(var masterInkFile in masterFilesAffected) {
				if(InkSettings.instance.ShouldCompileInkFileAutomatically(masterInkFile)) {
					InkCompiler.CompileInk(masterInkFile);
				}
			}
		}

		private static void OnMoveAssets (string[] movedAssets) {
			if (!InkSettings.instance.handleJSONFilesAutomatically) 
				return;
			
			List<string> validMovedAssets = new List<string>();
			for (var i = 0; i < movedAssets.Length; i++) {
				if(!InkEditorUtils.IsInkFile(movedAssets[i]))
					continue;
				validMovedAssets.Add(movedAssets[i]);
				queuedMovedInkFileAssets.Add(movedAssets[i]);

			}
			// Move compiled JSON files.
			// This can cause Unity to postprocess assets again.
			foreach(var inkFilePath in validMovedAssets) {
				InkFile inkFile = InkLibrary.GetInkFileWithPath(inkFilePath);
				if(inkFile == null) continue;
				if(inkFile.jsonAsset == null) continue;

				string jsonAssetPath = AssetDatabase.GetAssetPath(inkFile.jsonAsset);
				
				string movedAssetDir = Path.GetDirectoryName(inkFilePath);
				string movedAssetFile = Path.GetFileName(inkFilePath);
				string newPath = InkEditorUtils.CombinePaths(movedAssetDir, Path.GetFileNameWithoutExtension(movedAssetFile)) + ".json";

				// On moving an ink file, we either recompile it, creating a new json file in the correct location, or we move the json file.
				if(InkSettings.instance.ShouldCompileInkFileAutomatically(inkFile)) {
					// We have to delay this, or it doesn't properly inform unity (there's no version of "ImportAsset" for delete); I guess it doesn't want OnPostprocessAllAssets to fire recursively.
					EditorApplication.delayCall += () => {
						AssetDatabase.DeleteAsset(jsonAssetPath);
						AssetDatabase.Refresh();
					};
				} else {
					if (string.IsNullOrEmpty(AssetDatabase.ValidateMoveAsset(jsonAssetPath, newPath))) {
						Debug.Assert(newPath==inkFile.jsonPath);
						EditorApplication.delayCall += () => {
							AssetDatabase.MoveAsset(jsonAssetPath, newPath);
							AssetDatabase.ImportAsset(newPath);
							AssetDatabase.Refresh();
							inkFile.FindCompiledJSONAsset();
						};
						// Debug.Log(jsonAssetPath+" to "+newPath);
					} else {
						// This will fire if the JSON file is also moved with the ink - in this case the json file will be in movedAssets.
						// Debug.Log($"Failed to move asset from path '{jsonAssetPath}' to '{newPath}'.");
					}
				}
			}
			// Check if no JSON assets were moved (as a result of none needing to move, or this function being called as a result of JSON files being moved)
			if(queuedMovedInkFileAssets.Count > 0) {
				List<InkFile> filesToCompile = new List<InkFile>();

				// Add the old master file to the files to be recompiled
				foreach(var inkFilePath in queuedMovedInkFileAssets) {
					InkFile inkFile = InkLibrary.GetInkFileWithPath(inkFilePath);
					if(inkFile == null) continue;
					foreach(var masterInkFile in inkFile.masterInkFilesIncludingSelf) {
						if(InkSettings.instance.ShouldCompileInkFileAutomatically(masterInkFile) && !filesToCompile.Contains(masterInkFile))
							filesToCompile.Add(masterInkFile);
					}
				}

				InkLibrary.RebuildInkFileConnections();

                // If rebuilding connections caused a file that was previously considered a master file to no longer be, then we remove it.
				for (int i = filesToCompile.Count - 1; i >= 0; i--)
                    if(!filesToCompile[i].isMaster) 
						filesToCompile.RemoveAt(i);

				// Add the new file to be recompiled
				foreach(var inkFilePath in queuedMovedInkFileAssets) {
					InkFile inkFile = InkLibrary.GetInkFileWithPath(inkFilePath);
					if(inkFile == null) continue;

					foreach(var masterInkFile in inkFile.masterInkFilesIncludingSelf) {
						if(InkSettings.instance.ShouldCompileInkFileAutomatically(masterInkFile) && !filesToCompile.Contains(masterInkFile))
							filesToCompile.Add(masterInkFile);
					}
				}

				queuedMovedInkFileAssets.Clear();
				

				// Compile any ink files that are deemed master files a rebuild
				InkCompiler.CompileInk(filesToCompile.ToArray(), compileImmediatelyOnImport);
			}
		}

		private static void OnImportAssets (string[] importedAssets) {
			List<string> importedInkAssets = new List<string>();
			string inklecateFileLocation = null;
			foreach (var importedAssetPath in importedAssets) {
				if(InkEditorUtils.IsInkFile(importedAssetPath))
					importedInkAssets.Add(importedAssetPath);
				else if (Path.GetFileName(importedAssetPath) == "inklecate" && Path.GetExtension(importedAssetPath) == "")
					inklecateFileLocation = importedAssetPath;
			}
			if(importedInkAssets.Count > 0)
				PostprocessInkFiles(importedInkAssets);
			if(inklecateFileLocation != null)
				PostprocessInklecate(inklecateFileLocation);
		}

		private static void PostprocessInklecate (string inklecateFileLocation) {
			// This should probably only recompile files marked to compile automatically, but it's such a rare case, and one where you probably do want to compile.
			// To fix, one day!
			Debug.Log("Inklecate updated. Recompiling all Ink files...");
			InkEditorUtils.RecompileAll();
		}

		private static void PostprocessInkFiles (List<string> importedInkAssets) {
			if(EditorApplication.isPlaying && InkSettings.instance.delayInPlayMode) {
				foreach(var fileToImport in importedInkAssets) {
					InkCompiler.AddToPendingCompilationStack(fileToImport);
				}
			} else {
				InkLibrary.CreateOrReadUpdatedInkFiles (importedInkAssets);
				InkCompiler.CompileInk(InkCompiler.GetUniqueMasterInkFilesToCompile (importedInkAssets).ToArray());
			}
		}
	}
}

--- Путь к файлу: .\Assets\Ink\Editor\Core\Ink Library\InkCompilerLog.cs ---

using System.Text.RegularExpressions;
using Debug = UnityEngine.Debug;

namespace Ink.UnityIntegration
{
    [System.Serializable]
	public class InkCompilerLog {
		public Ink.ErrorType type;
		public string content;
		public string relativeFilePath;
		public int lineNumber;

		public InkCompilerLog (Ink.ErrorType type, string content, string relativeFilePath, int lineNumber = -1) {
			this.type = type;
			this.content = content;
			this.relativeFilePath = relativeFilePath;
			this.lineNumber = lineNumber;
		}

		public string GetAbsoluteFilePath (InkFile masterInkFile) {
			Debug.Log(masterInkFile.absoluteFolderPath);
			Debug.Log(relativeFilePath);
			return System.IO.Path.Combine(masterInkFile.absoluteFolderPath, relativeFilePath);
		}

		public static bool TryParse (string rawLog, out InkCompilerLog log) {
			var match = _errorRegex.Match(rawLog);
			if (match.Success) {
				Ink.ErrorType errorType = Ink.ErrorType.Author;
				string relativeFilePath = null;
				int lineNo = -1;
				string message = null;
				
				var errorTypeCapture = match.Groups["errorType"];
				if( errorTypeCapture != null ) {
					var errorTypeStr = errorTypeCapture.Value;
					if(errorTypeStr == "AUTHOR" || errorTypeStr == "TODO") errorType = Ink.ErrorType.Author;
					else if(errorTypeStr == "WARNING") errorType = Ink.ErrorType.Warning;
					else if(errorTypeStr == "ERROR") errorType = Ink.ErrorType.Error;
					else Debug.LogWarning("Could not parse error type from "+errorTypeStr);
				}
				
				var filenameCapture = match.Groups["filename"];
				if (filenameCapture != null)
					relativeFilePath = filenameCapture.Value;
				
				var lineNoCapture = match.Groups["lineNo"];
				if (lineNoCapture != null)
					lineNo = int.Parse (lineNoCapture.Value);
				
				var messageCapture = match.Groups["message"];
				if (messageCapture != null)
					message = messageCapture.Value.Trim();
				log = new InkCompilerLog(errorType, message, relativeFilePath, lineNo);
				return true;
			} else {
				Debug.LogWarning("Could not parse InkFileLog from log: "+rawLog);
				log = null;
				return false;
			}
		}
		private static Regex _errorRegex = new Regex(@"(?<errorType>ERROR|WARNING|TODO):(?:\s(?:'(?<filename>[^']*)'\s)?line (?<lineNo>\d+):)?(?<message>.*)");
	}
}

--- Путь к файлу: .\Assets\Ink\Editor\Core\Ink Library\InkFile.cs ---

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using UnityEditor;
using UnityEngine;

namespace Ink.UnityIntegration {
	// Helper class for ink files that maintains INCLUDE connections between ink files
	[Serializable]
	public class InkFile {
		// Master files are those that can be compiled
		public bool isMaster => !isIncludeFile || isMarkedToCompileAsMasterFile;
		// Typically master files are simply those that aren't INCLUDED by another file, but they can also be marked to master files.
		public bool isMarkedToCompileAsMasterFile => InkSettings.instance.includeFilesToCompileAsMasterFiles.Contains(inkAsset);
		public bool compileAutomatically => InkSettings.instance.filesToCompileAutomatically.Contains(inkAsset);
		// A reference to the ink file
		public DefaultAsset inkAsset;

        //specify json destination folder (if None, default to same folder as ink file)
        public DefaultAsset jsonAssetDirectory;

		// The compiled json file. Use this to start a story.
		public TextAsset jsonAsset;

		// The file path relative to the Assets folder (Assets/Ink/Story.ink)
		public string filePath {
			get {
				if(inkAsset == null) 
					return null;

				return InkEditorUtils.SanitizePathString(AssetDatabase.GetAssetPath(inkAsset));
			}
		}

		// The full file path (C:/Users/Inkle/HeavensVault/Assets/Ink/Story.ink)
		public string absoluteFilePath {
			get {
				if(inkAsset == null) 
					return null;
				return InkEditorUtils.UnityRelativeToAbsolutePath(filePath);
			}
		}

		public string absoluteFolderPath => InkEditorUtils.SanitizePathString(Path.GetDirectoryName(absoluteFilePath));

		// The path of any compiled json file. Relative to assets folder.
        public string jsonPath {
			get {
                var _filePath = filePath;
                Debug.Assert(!string.IsNullOrEmpty(_filePath), "File path for ink file is null! The ink library requires rebuilding. Asset: "+inkAsset);

                DefaultAsset jsonFolder = jsonAssetDirectory;
                if (jsonFolder == null) // no path specified for this specific file
                {
                    if(InkSettings.instance.defaultJsonAssetPath != null) 
                    {
                        // use default path in InkSettings
                        jsonFolder = InkSettings.instance.defaultJsonAssetPath;
                    }

                    if (jsonFolder == null)
                    {
                        //fallback to same folder as .ink file
                        jsonFolder = AssetDatabase.LoadAssetAtPath<DefaultAsset>(Path.GetDirectoryName(_filePath));
                    }
                }

                Debug.Assert(jsonFolder != null, "JSON folder not found for ink file at path. File Path: "+_filePath+". Asset: "+inkAsset);

                string _jsonPath = AssetDatabase.GetAssetPath(jsonFolder);
                Debug.Assert(Directory.Exists(_jsonPath), "JSON folder path is not a directory! Json Path: "+_jsonPath+". Asset: "+inkAsset);
                string strJsonAssetPath = InkEditorUtils.CombinePaths(_jsonPath, Path.GetFileNameWithoutExtension(_filePath)) + ".json";
                return strJsonAssetPath;
			}
		}

		public string absoluteJSONPath {
			get {
				if(inkAsset == null) 
					return null;
				return InkEditorUtils.UnityRelativeToAbsolutePath(jsonPath);
			}
		}






		// Fatal unhandled errors that should be reported as compiler bugs.
		public List<string> unhandledCompileErrors = new List<string>();
		public bool hasUnhandledCompileErrors => unhandledCompileErrors.Count > 0;

		public List<string> recursiveIncludeErrorPaths = new List<string>();
		public bool hasRecursiveIncludeErrorPaths => recursiveIncludeErrorPaths.Count > 0;

		// Fatal errors caused by errors in the user's ink script.
		public List<InkCompilerLog> errors = new List<InkCompilerLog>();
		public bool hasErrors => errors.Count > 0;

		public List<InkCompilerLog> warnings = new List<InkCompilerLog>();
		public bool hasWarnings => warnings.Count > 0;

		public List<InkCompilerLog> todos = new List<InkCompilerLog>();
		public bool hasTodos => todos.Count > 0;

		public bool requiresCompile {
			get {
				if(!isMaster) return false;
				return jsonAsset == null || hasUnhandledCompileErrors || lastEditDate > lastCompileDate;
			}
		}

		/// <summary>
		/// Gets the last compile date of the story.
		/// </summary>
		/// <value>The last compile date of the story.</value>
		public DateTime lastCompileDate {
			get {
				if(isMaster) {
					if(jsonAsset == null)
						return default;
				
					string fullJSONFilePath = InkEditorUtils.UnityRelativeToAbsolutePath(AssetDatabase.GetAssetPath(jsonAsset));
					return File.GetLastWriteTime(fullJSONFilePath);
				} else {
					return default;
				}
			}
		}

		/// <summary>
		/// Gets the last edit date of the file.
		/// </summary>
		/// <value>The last edit date of the file.</value>
		public DateTime lastEditDate => File.GetLastWriteTime(absoluteFilePath);

		public List<DefaultAsset> masterInkAssets = new List<DefaultAsset>();
		public IEnumerable<InkFile> masterInkFiles {
			get {
				foreach(var masterInkAsset in masterInkAssets) {
					yield return InkLibrary.GetInkFileWithFile(masterInkAsset);
				}
			}
		}
		public IEnumerable<InkFile> masterInkFilesIncludingSelf {
			get {
				// A file can be both a master file AND be included by many other files. Return all the master files fitting this description.
				if(isMaster) yield return this;
				foreach(var masterInkFile in masterInkFiles) {
					yield return masterInkFile;
				}
			}
		}

		// Is this ink file included by another ink file?
		public bool isIncludeFile => masterInkAssets.Count > 0;


		// The files referenced by this file via the INCLUDE keyword
		// We cache the paths of the files to be included for performance, giving us more freedom to refresh the actual includes list without needing to parse all the text.
		public List<string> localIncludePaths = new List<string>();
		// The asset references for the included files. Unlike localIncludePaths this contains include files
		public List<DefaultAsset> includes = new List<DefaultAsset>();
		// The InkFiles of the includes of this file
		public List<InkFile> includesInkFiles {
			get {
				List<InkFile> _includesInkFiles = new List<InkFile>();
				foreach(var child in includes) {
					if(child == null) {
						Debug.LogError("Error compiling ink: Ink file include in "+filePath+" is null.", inkAsset);
						continue;
					}
					_includesInkFiles.Add(InkLibrary.GetInkFileWithFile(child));
				}
				return _includesInkFiles;
			}
		}
	    




		public InkFile (DefaultAsset inkAsset) {
			Debug.Assert(inkAsset != null);
			this.inkAsset = inkAsset;
			
			ParseContent();
			// Should we run FindCompiledJSONAsset here?
		}

		public void FindCompiledJSONAsset () {
            Debug.Assert(inkAsset != null);
            jsonAsset = AssetDatabase.LoadAssetAtPath<TextAsset>(jsonPath);
		}

		public void ClearAllHierarchyConnections() {
			masterInkAssets.Clear();
			includes.Clear();
		}

		


		


		// Returns the contents of the .ink file.
		public string GetFileContents () {
			if(inkAsset == null) {
				Debug.LogWarning("Ink file asset is null! Rebuild library using Assets > Rebuild Ink Library");
				return "";
			}
			return File.ReadAllText(absoluteFilePath);
		}

		// Parses the ink file and caches any information we may want to access without incurring a performance cost.
		// Currently this only scans for includePaths, which are later used by InkLibrary.RebuildInkFileConnections.
		public void ParseContent () {
			localIncludePaths.Clear();
			localIncludePaths.AddRange(InkIncludeParser.ParseIncludes(GetFileContents()));
		}

		public static class InkIncludeParser {
			static Regex _includeRegex;
			static Regex includeRegex {
				get {
					if(_includeRegex == null) {
						_includeRegex = new Regex (@"^\s*INCLUDE\s+([^\r\n]+)\r*$", RegexOptions.Multiline);
					}
					return _includeRegex;
				}
			}
	        public static IEnumerable<string> ParseIncludes (string inkContents) {
	            return FindIncludes (EliminateComments(inkContents));
	        }

	        static string EliminateComments(string inkStr) {
	            var sb = new StringBuilder ();
	            int idx = 0;
	            while(idx < inkStr.Length) {
	                var commentStarterIdx = inkStr.IndexOf ('/', idx);
	                // Final string?
	                if (commentStarterIdx == -1 || commentStarterIdx >= inkStr.Length-2 ) {
	                    sb.Append (inkStr.Substring (idx, inkStr.Length - idx));
	                    break;
	                }
	                sb.Append (inkStr.Substring (idx, commentStarterIdx - idx));
	                var commentStarter = inkStr.Substring (commentStarterIdx, 2);
	                if (commentStarter == "//" || commentStarter == "/*") {
	                    int endOfCommentIdx = -1;
	                    // Single line comments
	                    if (commentStarter == "//") {
	                        endOfCommentIdx = inkStr.IndexOf ('\n', commentStarterIdx);
	                        if (endOfCommentIdx == -1)
	                            endOfCommentIdx = inkStr.Length;
	                        else if (inkStr [endOfCommentIdx - 1] == '\r')
	                            endOfCommentIdx = endOfCommentIdx - 1;
	                    } 
	                    // Block comments
	                    else if (commentStarter == "/*") {
	                        endOfCommentIdx = inkStr.IndexOf ("*/", idx);
	                        if (endOfCommentIdx == -1)
	                            endOfCommentIdx = inkStr.Length;
	                        else
	                            endOfCommentIdx += 2;
	                        // If there are *any* newlines, we should add one in here,
	                        // so that lines are spit up correctly
	                        if (inkStr.IndexOf ('\n', commentStarterIdx, endOfCommentIdx - commentStarterIdx) != -1)
	                            sb.Append ("\n");
	                    }
	                    // Skip over comment
	                    if (endOfCommentIdx > -1)
	                        idx = endOfCommentIdx;
	                } 
	                // Normal slash we need, not a comment
	                else {
	                    sb.Append ("/");
	                    idx = commentStarterIdx + 1;
	                }
	            }
	            return sb.ToString ();
	        }
	        static IEnumerable<string> FindIncludes(string str) {
	            MatchCollection matches = includeRegex.Matches(str);
	            foreach (Match match in matches)
	            {
	                var capture = match.Groups [1].Captures [0];
	                yield return capture.Value;
	            }
	        }
		}

		
		public override string ToString () {
			return $"[InkFile: filePath={filePath}]";
		} 
	}
}

--- Путь к файлу: .\Assets\Ink\Editor\Core\Ink Library\InkLibrary.cs ---

using UnityEngine;
using UnityEditor;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Debug = UnityEngine.Debug;

/// <summary>
/// Holds a reference to an InkFile object for every .ink file detected in the Assets folder.
/// Provides helper functions to easily obtain these files.
/// </summary>
namespace Ink.UnityIntegration {
    #if UNITY_2020_1_OR_NEWER
    [FilePath("Library/asset", FilePathAttribute.Location.ProjectFolder)]
	public class InkLibrary : ScriptableSingleton<InkLibrary>, IEnumerable<InkFile> {
    #else
	public class InkLibrary : ScriptableObject, IEnumerable<InkFile> {
    #endif
        // Ink version. This should really come from the core ink code.
		public static System.Version inkVersionCurrent = new System.Version(1,2,0);
		public static System.Version unityIntegrationVersionCurrent = new System.Version(1,2,1);

		static string absoluteSavePath {
			get {
				return System.IO.Path.GetFullPath(System.IO.Path.Combine(System.IO.Directory.GetCurrentDirectory(),"Library","asset"));
			}
		}
		
		#if !UNITY_2020_1_OR_NEWER
		public static bool created {
			get {
				// If it's null, there's no InkLibrary loaded
				return (_instance != (Object) null);
			}
		}
		private static InkLibrary _instance;
		public static InkLibrary instance {
			get {
				if(!created)
                	LoadOrCreateInstance();
				return _instance;
			} private set {
				if(_instance == value) return;
				_instance = value;
            }
		}
        
		
		// This occurs on recompile, creation and load (note that data has not necessarily been loaded at this point!)
		protected InkLibrary () {
			if (created)
				Debug.LogError((object) "ScriptableSingleton already exists. Did you query the singleton in a constructor?");
			else {
				instance = this;
			}
		}

		public static void LoadOrCreateInstance () {
			InternalEditorUtility.LoadSerializedFileAndForget(absoluteSavePath);
			if(created) {
				if(InkEditorUtils.isFirstCompile) {
					Validate();
				}
			} else {
				instance = ScriptableObject.CreateInstance<InkLibrary>();
				instance.hideFlags = HideFlags.HideAndDontSave;
				Rebuild();
			}
		}
		
		public void Save (bool saveAsText) {
			if(!created) return;			
			InternalEditorUtility.SaveToSerializedFileAndForget((Object[]) new InkLibrary[1] {instance}, absoluteSavePath, saveAsText);
		}

		static void EnsureCreated () {
			if(!created) LoadOrCreateInstance();
		}
        #endif
        
        public class AssetSaver : UnityEditor.AssetModificationProcessor {
            static string[] OnWillSaveAssets(string[] paths) {
                instance.Save(true);
                return paths;
            }
        }

		public List<InkFile> inkLibrary = new List<InkFile>();
		Dictionary<DefaultAsset, InkFile> inkLibraryDictionary = new Dictionary<DefaultAsset, InkFile>();
		
        public int Count {
            get {
                return inkLibrary.Count;
            }
        }
        public InkFile this[int key] {
            get {
                return inkLibrary[key];
            } set {
                inkLibrary[key] = value;
            }
        }
        IEnumerator<InkFile> IEnumerable<InkFile>.GetEnumerator() {
            return inkLibrary.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator() {
            return inkLibrary.GetEnumerator();
        }

		void OnValidate () {
            BuildLookupDictionary();
            // This is experimental! I'd like to see if it fixes the issue where assets have not yet been imported.
            EditorApplication.delayCall += () => {
                Validate();
            };
        }

        static void BuildLookupDictionary () {
            instance.inkLibraryDictionary.Clear();
			foreach(var inkFile in instance.inkLibrary) {
                instance.inkLibraryDictionary.Add(inkFile.inkAsset, inkFile);
            }
        }
        
		/// <summary>
		/// Checks if the library is corrupt and rebuilds if necessary. Returns true if the library was valid
		/// </summary>
        public static bool Validate () {
            if(RequiresRebuild()) {
                Rebuild();
                Debug.LogWarning("InkLibrary was invalid and has been rebuilt. This can occur if files are moved/deleted while the editor is closed. You can ignore this warning.");
				return false;
            } else {
				return true;
			}
        }
        
		/// <summary>
		/// Checks if the library is corrupt and requires a Rebuild. 
        /// This can happen when asset IDs change, causing the wrong file to be referenced.
        /// This occassionally occurs from source control.
        /// This is a fairly performant check.
		/// </summary>
        static bool RequiresRebuild () {
            #if !UNITY_2020_1_OR_NEWER
			EnsureCreated();
            #endif
			foreach(var inkFile in instance.inkLibrary) {
                if(inkFile == null) {
                    return true;
                }
                if(inkFile.inkAsset == null) {
                    // This can occur when the asset has not yet been imported!
                    return true;
                }
                if(!instance.inkLibraryDictionary.ContainsKey(inkFile.inkAsset)) {
                    return true;
                }
                foreach(var include in inkFile.includes) {
                    if(include == null) {
                        return true;
                    }
                    if(!instance.inkLibraryDictionary.ContainsKey(include)) {
                        return true;
                    }
                } 
            }
            return false;
        }

		/// <summary>
		/// Removes and null references in the library
		/// </summary>
		public static bool Clean () {
            bool wasDirty = false;
			for (int i = instance.Count - 1; i >= 0; i--) {
				InkFile inkFile = instance[i];
				if (inkFile.inkAsset == null) {
					RemoveAt(i);
                    wasDirty = true;
                }
			}
            return wasDirty;
		}

        static void Add (InkFile inkFile) {
            instance.inkLibrary.Add(inkFile);
			SortInkLibrary();
			instance.inkLibraryDictionary.Add(inkFile.inkAsset, inkFile);
        }
        public static void RemoveAt (int index) {
            var inkFile = instance.inkLibrary[index];
            instance.inkLibrary.RemoveAt(index);
            instance.inkLibraryDictionary.Remove(inkFile.inkAsset);
        }
		static void SortInkLibrary () {
            instance.inkLibrary = instance.inkLibrary.OrderBy(x => x.filePath).ToList();
		}

		/// <summary>
		/// Updates the ink library. Executed whenever an ink file is changed by InkToJSONPostProcessor
		/// Can be called manually, but incurs a performance cost.
		/// </summary>
		public static void Rebuild () {
			// Disable the asset post processor in case any assetdatabase functions called as a result of this would cause further operations.
			InkPostProcessor.disabled = true;
			
            // Clear the old data
            instance.inkLibrary.Clear();
            instance.inkLibraryDictionary.Clear();

			// Reset the asset name
			instance.name = "Ink Library "+unityIntegrationVersionCurrent.ToString();
            
			// Add any new file connections (if any are found it replaces the old library entirely)
			string[] inkFilePaths = GetAllInkFilePaths();
			bool inkLibraryChanged = false;
			List<InkFile> newInkLibrary = new List<InkFile>(inkFilePaths.Length);
			for (int i = 0; i < inkFilePaths.Length; i++) {
				InkFile inkFile = GetInkFileWithAbsolutePath(inkFilePaths [i]);
				// If the ink library doesn't have a representation for this file, then make one 
                if(inkFile == null) {
					inkLibraryChanged = true;
					string localAssetPath = InkEditorUtils.AbsoluteToUnityRelativePath(inkFilePaths [i]);
					DefaultAsset inkFileAsset = AssetDatabase.LoadAssetAtPath<DefaultAsset>(localAssetPath);
					// If the ink file can't be found, it might not yet have been imported. We try to manually import it to fix this.
					if(inkFileAsset == null) {
						AssetDatabase.ImportAsset(localAssetPath);
						inkFileAsset = AssetDatabase.LoadAssetAtPath<DefaultAsset>(localAssetPath);
						if(inkFileAsset == null) {
                            // If this occurs as a result assets not having been imported before OnValidate => Validate we should return immediately and set a flag to true.
                            // If an asset import is detected immediately after this via InkPostProcessor, then this rebuild may (will?) have been unnecessary anyway.
                            // At time of writing (11/05/21) I've not done this and am locally toying with EditorApplication.delayCall in OnValidate.
							Debug.LogWarning("Ink File Asset not found at "+localAssetPath+". This can occur if the .meta file has not yet been created. This issue should resolve itself, but if unexpected errors occur, rebuild Ink Library using Assets > Recompile Ink");
							continue;
						}
					}
					inkFile = new InkFile(inkFileAsset);
				}
                newInkLibrary.Add(inkFile);
			}
			if(inkLibraryChanged) {
				instance.inkLibrary = newInkLibrary;
				SortInkLibrary();
			}
            BuildLookupDictionary();

			RebuildInkFileConnections();

			foreach (InkFile inkFile in instance.inkLibrary) inkFile.FindCompiledJSONAsset();

			// if(InkSettings.instance.handleJSONFilesAutomatically) DeleteUnwantedCompiledJSONAssets();
			
			instance.Save(true);
			
			// Re-enable the ink asset post processor
			InkPostProcessor.disabled = false;
			Debug.Log("Ink Library was rebuilt.\n"+instance.inkLibrary.Count+" ink files are currently tracked.");
		}

		// To be used when adding .ink files. 
		// This process is typically handled by CreateOrReadUpdatedInkFiles, called from InkPostProcessor; but it may be desired to remove/disable the post processor.
		// In those cases, this is the correct way to ensure the ink library correctly processes the file.
		public static InkFile AddNewInkFile (DefaultAsset asset) {
			Debug.Assert(asset != null);
			// First, check if we've already got it in the library!
			foreach(var _inkFile in instance)
				if(_inkFile.inkAsset == asset)
					return _inkFile;
			// If not
			var inkFile = new InkFile(asset);
			inkFile.FindCompiledJSONAsset();
			Add(inkFile);
			RebuildInkFileConnections();
			return inkFile;
		}

		// This is called from InkPostProcessor after ink file(s) has been added/changed.
		public static void CreateOrReadUpdatedInkFiles (List<string> importedInkAssets) {
            for (int i = 0; i < importedInkAssets.Count; i++) {
                string importedAssetPath = importedInkAssets[i];
                InkFile inkFile = GetInkFileWithPath(importedAssetPath);
				if(inkFile == null) {
					DefaultAsset asset = AssetDatabase.LoadAssetAtPath<DefaultAsset>(importedAssetPath);
					if(asset == null) {
						// This file wasn't found! This is a rare bug. We remove the file from the list in this case, preventing it from causing further bugs.
						importedInkAssets.RemoveAt(i);
						i--;
						Debug.LogWarning("InkLibrary failed to load ink file at "+importedAssetPath+". It has been removed from the list of files. You can ignore this warning.");
					} else {
						// New file; create and add InkFile to represent it. Content is read in InkFile constructor.
						inkFile = new InkFile(asset);
						inkFile.FindCompiledJSONAsset();
						Add(inkFile);
					}
				} else {
					// Read content
					inkFile.ParseContent();
				}
			}
			// Now we've updated all the include paths for the ink library we can create master/child references between them.
			RebuildInkFileConnections();
		}

        // Finds absolute file paths of all the ink files in Application.dataPath
		private static string[] GetAllInkFilePaths () {
			string[] inkFilePaths = Directory.GetFiles(Application.dataPath, "*.ink", SearchOption.AllDirectories);
			for (int i = 0; i < inkFilePaths.Length; i++) {
				inkFilePaths [i] = InkEditorUtils.SanitizePathString(inkFilePaths [i]);
			}
			return inkFilePaths;
		}

		// All the master files
		public static IEnumerable<InkFile> GetMasterInkFiles () {
			if(instance.inkLibrary == null) yield break;
			foreach (InkFile inkFile in instance.inkLibrary) {
				if(inkFile.isMaster) 
					yield return inkFile;
			}
		}

		public static IEnumerable<InkFile> GetInkFilesMarkedToCompileAsMasterFiles () {
			if(instance.inkLibrary == null) yield break;
			foreach (InkFile inkFile in instance.inkLibrary) {
				if(inkFile.isMaster) 
					yield return inkFile;
			}
		}

		// All the master files which are dirty and are set to compile
		public static IEnumerable<InkFile> GetFilesRequiringRecompile () {
			foreach(InkFile inkFile in GetInkFilesMarkedToCompileAsMasterFiles ()) {
				if(InkSettings.instance.ShouldCompileInkFileAutomatically(inkFile) && inkFile.requiresCompile) 
					yield return inkFile;
			}
		}

		// All the master files which are set to compile
		public static IEnumerable<InkFile> FilesCompiledByRecompileAll () {
			foreach(InkFile inkFile in GetInkFilesMarkedToCompileAsMasterFiles ()) {
				if(InkSettings.instance.ShouldCompileInkFileAutomatically(inkFile)) 
					yield return inkFile;
			}
		}

		/// <summary>
		/// Gets the ink file from the .ink file reference.
		/// </summary>
		/// <returns>The ink file with path.</returns>
		/// <param name="file">File asset.</param>
		/// <param name="addIfMissing">Adds the file if missing from inkLibrary.</param>
		public static InkFile GetInkFileWithFile (DefaultAsset file, bool addIfMissing = false) {
			if(instance.inkLibrary == null) return null;
			
			if (!file) {
				Debug.LogError("Can't add null file.");
				return null;
			}

            if(instance.inkLibraryDictionary == null) {
				Debug.LogWarning("GetInkFileWithFile: inkLibraryDictionary was null! This should never occur, but is handled following a user reported bug. If this has never been seen long after 12/08/2020, it can be safely removed");
				BuildLookupDictionary();
			}
			foreach(InkFile inkFile in instance.inkLibrary) {
				if(inkFile.inkAsset == file) {
					return inkFile;
				}
			}

			var missingFileHasProperFileExtension = Path.GetExtension(AssetDatabase.GetAssetPath(file)) == InkEditorUtils.inkFileExtension;
			if (addIfMissing) {
				InkFile newFile = new InkFile(file);
				instance.inkLibrary.Add(newFile);
				if(missingFileHasProperFileExtension) Debug.Log(file + " missing from ink library. Adding it now.");
				else Debug.LogWarning("File "+file + " is missing the .ink extension, but is believed to be an ink file. All ink files should use the .ink file extension! A common effect of this is forcing the InkLibrary to rebuild unexpectedly when the file is detected as an include of another file.");
				return newFile;
			}

			System.Text.StringBuilder listOfFiles = new System.Text.StringBuilder();
			foreach(InkFile inkFile in instance.inkLibrary) {
				listOfFiles.AppendLine(inkFile.ToString());
			}
			if(missingFileHasProperFileExtension) Debug.LogWarning (file + " missing from ink library. Please rebuild.\nFiles in Library:\n"+listOfFiles);
			else Debug.LogWarning (file + " is missing from ink library. It is also missing the .ink file extension. All ink files should use the .ink file extension! \nFiles in Library:\n"+listOfFiles);
			return null;
		}

		/// <summary>
		/// Gets the ink file with path relative to Assets folder, for example: "Assets/Ink/myStory.ink".
		/// </summary>
		/// <returns>The ink file with path.</returns>
		/// <param name="path">Path.</param>
		public static InkFile GetInkFileWithPath (string path) {
			if(instance.inkLibrary == null) return null;
			foreach(InkFile inkFile in instance.inkLibrary) {
				if(inkFile.filePath == path) {
					return inkFile;
				}
			}
			return null;
		}

		/// <summary>
		/// Gets the ink file with absolute path.
		/// </summary>
		/// <returns>The ink file with path.</returns>
		/// <param name="path">Path.</param>
		public static InkFile GetInkFileWithAbsolutePath (string absolutePath) {
			if(instance.inkLibrary == null) return null;
			foreach(InkFile inkFile in instance.inkLibrary) {
				if(inkFile.absoluteFilePath == absolutePath) {
					return inkFile;
				}
			}
			return null;
		}

		public static InkFile GetInkFileWithJSONFile (TextAsset inkJSONAsset) {
			if(instance.inkLibrary == null) return null;
			foreach(InkFile inkFile in instance.inkLibrary) {
				if(inkFile.jsonAsset == inkJSONAsset) {
					return inkFile;
				}
			}
			return null;
		}

		/// <summary>
		/// Rebuilds which files are master files and the connections between the files.
		/// INCLUDE is always relative to the master file. This means that every file should be assumed to be a master file until proven otherwise.
		/// </summary>
		/// We might consider updating this to allow rebuilding connections for specific files, since the most common case this is called is when a single file changes.
		/// The upside is that we wouldn't trigger warnings/errors that this function throws, for unrelated files. It's a bit risky so I've not done it yet.
		public static void RebuildInkFileConnections () {
			// Resets the connections between files
			foreach (InkFile inkFile in instance.inkLibrary) {
				inkFile.recursiveIncludeErrorPaths.Clear();
				inkFile.ClearAllHierarchyConnections();
			}
			
			
			// A dictionary which contains a list of all the ink files that INCLUDE a given ink file.
			// Once this is done we can determine which files are master files, and then assert that any INCLUDED files actually exist.
			Dictionary<InkFile, List<InkFile>> includedFileOwnerDictionary = new Dictionary<InkFile, List<InkFile>>();
			Dictionary<InkFile, List<InkFile>> recursiveIncludeLogs = new Dictionary<InkFile, List<InkFile>>();
			// Traverses each file to any file paths referenced using INCLUDE, using the original file as the source path when dealing with nested INCLUDES. 
			// Since not all of the files are guaranteed to be master files, we don't assert that the files actually exist at this time.
			foreach (InkFile inkFile in instance.inkLibrary) {
				BuildIncludeHierarchyAsIfMasterFile(inkFile, inkFile, recursiveIncludeLogs);
				// Recurse ink file includes for a (potential) master ink file, adding them to the file's list of includes if they exist
				static void BuildIncludeHierarchyAsIfMasterFile(InkFile potentialMasterInkFile, InkFile currentInkFile, Dictionary<InkFile, List<InkFile>> recursiveIncludeLogs) {
					if(currentInkFile.localIncludePaths.Count == 0) 
						return;
					foreach (var includePath in currentInkFile.localIncludePaths) {
						var includedFile = FindIncludedFile(potentialMasterInkFile.filePath, includePath);
						// Assets may not actually exist.
						// A typical and expected example is when an included file in a subfolder from it's master file has an INCLUDE, since file paths are always relative to the master file. 
						if (includedFile != null) {
							// We probably only need to show this error for files that are later proved to be master files
							if (potentialMasterInkFile == includedFile || potentialMasterInkFile.includes.Contains(includedFile.inkAsset)) {
								if(!recursiveIncludeLogs.ContainsKey(potentialMasterInkFile)) recursiveIncludeLogs.Add(potentialMasterInkFile, new List<InkFile>());
								recursiveIncludeLogs[potentialMasterInkFile].Add(currentInkFile); 
								continue;
							}
							Debug.Assert(includedFile.inkAsset != null);
							potentialMasterInkFile.includes.Add(includedFile.inkAsset);
							BuildIncludeHierarchyAsIfMasterFile(potentialMasterInkFile, includedFile, recursiveIncludeLogs);
						}
					}
					
					static InkFile FindIncludedFile(string masterFilePath, string includePath) {
						string localIncludePath = InkEditorUtils.CombinePaths(Path.GetDirectoryName(masterFilePath), includePath);
						// This enables parsing ..\ and the like. Can we use Path.GetFullPath instead?
						var fullIncludePath = new FileInfo(localIncludePath).FullName;
						localIncludePath = InkEditorUtils.AbsoluteToUnityRelativePath(fullIncludePath);
						DefaultAsset includedInkFileAsset = AssetDatabase.LoadAssetAtPath<DefaultAsset>(localIncludePath);
						if(includedInkFileAsset != null) {
							return GetInkFileWithFile(includedInkFileAsset);
						}
						return null;
					}
				}
				
				foreach (var includedFile in inkFile.includes) {
					var includedInkFile = GetInkFileWithFile(includedFile);
					if(!includedFileOwnerDictionary.ContainsKey(includedInkFile)) includedFileOwnerDictionary.Add(includedInkFile, new List<InkFile>());
					includedFileOwnerDictionary[includedInkFile].Add(inkFile);
				}
			}
			
			// Now we've established which files are INCLUDED we can tidy up by detecting and removing non-master files.
			// It's not a master file then we remove all references to it as a master file in the includedFileOwnerDictionary.
			// We don't clear the includes list for those files (even though referenced files may be null), because the user may mark isMarkedToCompileAsMasterFile true at a later date.
			foreach (InkFile inkFile in instance.inkLibrary) {
				var isMasterFile = !includedFileOwnerDictionary.ContainsKey(inkFile) || includedFileOwnerDictionary[inkFile].Count == 0 || inkFile.isMarkedToCompileAsMasterFile;
				if (!isMasterFile) {
					foreach (var includedFileOwners in includedFileOwnerDictionary) {
						if(includedFileOwners.Key != inkFile) includedFileOwners.Value.Remove(inkFile);
					}
				}
			}
			
			// Master ink files and includedFileOwnerDictionary are now valid collections denoting master files and their includes. The final step is to add the masters in any included files.
			foreach (InkFile inkFile in instance.inkLibrary) {
				if (!includedFileOwnerDictionary.ContainsKey(inkFile) || includedFileOwnerDictionary[inkFile].Count == 0 || inkFile.isMarkedToCompileAsMasterFile) {
					foreach (var includedFile in inkFile.includes) {
						var includedInkFile = GetInkFileWithFile(includedFile);
						includedInkFile.masterInkAssets.Add(inkFile.inkAsset);
					}

				}
			}
			
			// Error logs for any master files that wanted to add recursive includes
			foreach (var recursiveIncludeLog in recursiveIncludeLogs) {
				if (recursiveIncludeLog.Key.isMaster) {
					recursiveIncludeLog.Key.recursiveIncludeErrorPaths.AddRange(recursiveIncludeLog.Value.Select(x => x.filePath));
					var files = string.Join("\n", recursiveIncludeLog.Key.recursiveIncludeErrorPaths);
					Debug.LogError("Recursive INCLUDE found in "+recursiveIncludeLog.Key.filePath+" at "+(recursiveIncludeLog.Value.Count == 1 ? "file:\n" : "files:\n")+files);
				}
			}
		}
		
		// Deletes any JSON ink assets that aren't expected to exist because their ink files aren't expected to be compiled
		public static void DeleteUnwantedCompiledJSONAssets() {
			foreach (InkFile inkFile in instance.inkLibrary) {
				if(!inkFile.isMaster && inkFile.jsonAsset != null) {
					AssetDatabase.DeleteAsset(AssetDatabase.GetAssetPath(inkFile.jsonAsset));
					inkFile.jsonAsset = null;
				}
			}
		}
	}
}

--- Путь к файлу: .\Assets\Ink\Editor\Core\Ink Settings\InkSettings.cs ---

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using Debug = UnityEngine.Debug;

/// <summary>
/// Holds a reference to an InkFile object for every .ink file detected in the Assets folder.
/// Provides helper functions to easily obtain these files.
/// ScriptableSingleton doesn't reload when the backing file changes, which means if you pull changes via source control you need to make unity recompile before it'll load the change.
/// </summary>
namespace Ink.UnityIntegration {
    // #if UNITY_2020_1_OR_NEWER
    // [FilePath("ProjectSettings/InkSettings.asset", FilePathAttribute.Location.ProjectFolder)]
	// public class InkSettings : ScriptableSingleton<InkSettings> {
    // #else
	public class InkSettings : ScriptableObject {
    // #endif
        // #if !UNITY_2020_1_OR_NEWER
		public static bool created {
			get {
                // If it's null, there's just no InkSettings asset in the project
                return _instance != null;
            }
		}
		static string absoluteSavePath {
			get {
				return System.IO.Path.GetFullPath(System.IO.Path.Combine(Application.dataPath,"..","ProjectSettings","InkSettings.asset"));

			}
		}
		public static void SaveStatic (bool saveAsText) {
			UnityEditorInternal.InternalEditorUtility.SaveToSerializedFileAndForget(new[] { instance }, absoluteSavePath, saveAsText);
		}
        public void Save (bool saveAsText) {
			UnityEditorInternal.InternalEditorUtility.SaveToSerializedFileAndForget((UnityEngine.Object[]) new InkSettings[1] {this}, absoluteSavePath, saveAsText);
		}

		private static InkSettings _instance;
		public static InkSettings instance {
			get {
				if(_instance == null) {
					Object[] objects = UnityEditorInternal.InternalEditorUtility.LoadSerializedFileAndForget(absoluteSavePath);
					if (objects != null && objects.Length > 0) {
						instance = objects[0] as InkSettings;
					} else {
						instance = ScriptableObject.CreateInstance<InkSettings>();
						instance.Save(true);
					}
					// Oh gosh Unity never unloads ScriptableObjects once created! This fixes it but is more of an expensive call than I like.
					// I've commented this out in favour of a callback approach - see OnEnable. Left this for posterity in case we need to return to this. 
					// foreach (var settings in Resources.FindObjectsOfTypeAll<InkSettings>()) {
					// 	if(settings == instance) continue;
					// 	DestroyImmediate(settings);
					// }
				}
				return _instance;
			} private set {
                if(_instance == value) return;
				_instance = value;
			}
		}
		// #endif

		public DefaultAsset templateFile;
		public string templateFilePath {
			get {
				if(templateFile == null) return "";
				else return AssetDatabase.GetAssetPath(templateFile);
			}
		}


        public DefaultAsset defaultJsonAssetPath;
		[UnityEngine.Serialization.FormerlySerializedAs("compileAutomatically")]
        public bool compileAllFilesAutomatically = true;
        public List<DefaultAsset> includeFilesToCompileAsMasterFiles = new List<DefaultAsset>();
        public List<DefaultAsset> filesToCompileAutomatically = new List<DefaultAsset>();
		public bool delayInPlayMode = true;
		public bool handleJSONFilesAutomatically = true;

		public int compileTimeout = 30;
		
		public bool printInkLogsInConsoleOnCompile;
		
		public bool suppressStartupWindow;
		
		public bool automaticallyAddDefineSymbols = true;

		#if UNITY_EDITOR && !UNITY_2018_1_OR_NEWER
		[MenuItem("Edit/Project Settings/Ink", false, 500)]
		public static void SelectFromProjectSettings() {
			Selection.activeObject = instance;
		}
		#elif UNITY_EDITOR && UNITY_2018_1_OR_NEWER
		public static SerializedObject GetSerializedSettings() {
			return new SerializedObject(instance);
		}
		#endif
        
		public bool ShouldCompileInkFileAutomatically (InkFile inkFile) {
			return compileAllFilesAutomatically || (inkFile.isMaster && filesToCompileAutomatically.Contains(inkFile.inkAsset));
		}

		
		void OnEnable () {
			// Oh gosh Unity never unloads ScriptableObjects once created! We destroy these objects before we recompile so there's only ever one in memory at once.
			AssemblyReloadEvents.beforeAssemblyReload += () => {
				DestroyImmediate(this);
			};
			// Validate the includeFilesToCompileAsMasterFiles list.
            for (int i = includeFilesToCompileAsMasterFiles.Count - 1; i >= 0; i--) {
                if(includeFilesToCompileAsMasterFiles[i] == null) {
					includeFilesToCompileAsMasterFiles.RemoveAt(i);
					Debug.LogError("REMOVE "+includeFilesToCompileAsMasterFiles.Count);
				}
            }
			// Validate the filesToCompileAutomatically list.
            for (int i = filesToCompileAutomatically.Count - 1; i >= 0; i--) {
                if(filesToCompileAutomatically[i] == null) {
					filesToCompileAutomatically.RemoveAt(i);
				}
            }
		}
	}	
}


--- Путь к файлу: .\Assets\Ink\Editor\Core\Ink Settings\InkSettingsEditor.cs ---

﻿using UnityEngine;
using UnityEditor;
using System.Collections.Generic;

namespace Ink.UnityIntegration {

	[CustomEditor(typeof(InkSettings))]
	public class InkSettingsEditor : Editor {

		#pragma warning disable
		protected InkSettings data;
		
		public void OnEnable() {
			data = (InkSettings) target;
		}
		
		public override void OnInspectorGUI() {
			serializedObject.Update();

			DrawSettings(serializedObject);

			if (GUI.changed && target != null) {
				EditorUtility.SetDirty(target);
				((InkSettings) target).Save(true);
			}
			serializedObject.ApplyModifiedProperties();
	    }

		#if UNITY_2018_1_OR_NEWER
		[SettingsProvider]
		public static SettingsProvider CreateInkSettingsProvider() {
			// First parameter is the path in the Settings window.
			// Second parameter is the scope of this setting: it only appears in the Project Settings window.
			var provider = new SettingsProvider("Project/Ink", SettingsScope.Project) {
				// By default the last token of the path is used as display name if no label is provided.
				label = "Ink",
				// Create the SettingsProvider and initialize its drawing (IMGUI) function in place:
				guiHandler = (searchContext) => {
                    // Drawing the SO makes them disabled, and I have no idea why. Drawing manually until fixed.
					// var settings = InkSettings.GetSerializedSettings();
					DrawSettings(InkSettings.instance);
				},

				// Populate the search keywords to enable smart search filtering and label highlighting:
				// keywords = new HashSet<string>(new[] { "Number", "Some String" })
			};
			return provider;
		}
		#endif

        static void DrawSettings (InkSettings settings) {
	        EditorGUI.BeginChangeCheck();
	        
	        EditorGUI.indentLevel++;
			DrawVersions();
			EditorGUILayout.Separator();

			var cachedLabelWidth = EditorGUIUtility.labelWidth;
			EditorGUIUtility.labelWidth = 260;

			EditorGUILayout.LabelField(new GUIContent("Settings"), EditorStyles.boldLabel);
			if(settings.templateFile == null) 
				DrawTemplateMissingWarning();
			settings.templateFile = (DefaultAsset)EditorGUILayout.ObjectField(new GUIContent("Ink Template", "Optional. The default content of files created via Assets > Create > Ink."), settings.templateFile, typeof(DefaultAsset));
      
			settings.defaultJsonAssetPath = (DefaultAsset)EditorGUILayout.ObjectField(new GUIContent("New JSON Path", "By default, story JSON files are placed next to the ink. Drag a folder here to place new JSON files there instead."), settings.defaultJsonAssetPath, typeof(DefaultAsset));
            settings.compileAllFilesAutomatically = EditorGUILayout.Toggle(new GUIContent("Compile All Ink Automatically", "When disabled, automatic compilation can be enabled on a per-story basis via the inspector for a master story file. This can be helpful when you have several stories in a single project."), settings.compileAllFilesAutomatically);
            settings.delayInPlayMode = EditorGUILayout.Toggle(new GUIContent("Delay compilation if in Play Mode", "When enabled, ink compilation is delayed if in play mode. Files will be compiled on re-entering edit mode."), settings.delayInPlayMode);
            settings.printInkLogsInConsoleOnCompile = EditorGUILayout.Toggle(new GUIContent("Print ink TODOs in console on compile", "When enabled, ink lines starting with TODO are printed in the console."), settings.printInkLogsInConsoleOnCompile);
            settings.handleJSONFilesAutomatically = EditorGUILayout.Toggle(new GUIContent("Handle JSON Automatically", "Whether JSON files are moved, renamed and deleted along with their ink files."), settings.handleJSONFilesAutomatically);
			settings.compileTimeout = EditorGUILayout.IntField(new GUIContent("Compile Timeout", "The max time the compiler will attempt to compile for in case of unhanded errors. You may need to increase this for very large ink projects."), settings.compileTimeout);
			settings.suppressStartupWindow = EditorGUILayout.Toggle(new GUIContent("Suppress Startup Window", "Prevent the \"what's new\" (the one that appears if you click the \"Show changelog\" button above) appearing when the version of this plugin has changed and Unity is opened. This can be useful for CI/CD pipelines, where auto-launching editor windows can fail to load due to a Unity bug."), settings.suppressStartupWindow);
			settings.automaticallyAddDefineSymbols = EditorGUILayout.Toggle(new GUIContent("Add define symbols", "If true, automatically adds INK_EDITOR and INK_RUNTIME to the define symbols in the build settings. This is handy for conditional code."), settings.automaticallyAddDefineSymbols);
			//// DrawDefineManagerButtons();
			
			EditorGUILayout.Separator();
			DrawRequestButton();

			EditorGUIUtility.labelWidth = cachedLabelWidth;
			EditorGUI.indentLevel--;
			
			if (EditorGUI.EndChangeCheck()) {
				if (settings.automaticallyAddDefineSymbols) InkDefineSymbols.AddGlobalDefine();
				else InkDefineSymbols.RemoveGlobalDefine();
				
				EditorUtility.SetDirty(settings);
				settings.Save(true);
			}
		}
        
		static void DrawSettings (SerializedObject settings) {
			DrawVersions();
			EditorGUILayout.Separator();

			var cachedLabelWidth = EditorGUIUtility.labelWidth;
			EditorGUIUtility.labelWidth = 260;
			EditorGUI.BeginChangeCheck();

			EditorGUILayout.LabelField(new GUIContent("Settings"), EditorStyles.boldLabel);
			if(settings.FindProperty("templateFile").objectReferenceValue == null) 
				DrawTemplateMissingWarning();
			
			EditorGUILayout.PropertyField(settings.FindProperty("templateFile"), new GUIContent("Ink Template", "Optional. The default content of files created via Assets > Create > Ink."));
			EditorGUILayout.PropertyField(settings.FindProperty("defaultJsonAssetPath"), new GUIContent("New JSON Path", "By default, story JSON files are placed next to the ink. Drag a folder here to place new JSON files there instead."));
            EditorGUILayout.PropertyField(settings.FindProperty("compileAllFilesAutomatically"), new GUIContent("Compile All Ink Automatically", "When disabled, automatic compilation can be enabled on a per-story basis via the inspector for a master story file. This can be helpful when you have several stories in a single project."));
            EditorGUILayout.PropertyField(settings.FindProperty("delayInPlayMode"), new GUIContent("Delay compilation if in Play Mode", "When enabled, ink compilation is delayed if in play mode. Files will be compiled on re-entering edit mode."));
            EditorGUILayout.PropertyField(settings.FindProperty("printInkLogsInConsoleOnCompile"), new GUIContent("Print ink TODOs in console on compile", "When enabled, ink lines starting with TODO are printed in the console."));
            EditorGUILayout.PropertyField(settings.FindProperty("handleJSONFilesAutomatically"), new GUIContent("Handle JSON Automatically", "Whether JSON files are moved, renamed and deleted along with their ink files."));
			EditorGUILayout.PropertyField(settings.FindProperty("compileTimeout"), new GUIContent("Compile Timeout", "The max time the compiler will attempt to compile for in case of unhanded errors. You may need to increase this for very large ink projects."));
			EditorGUILayout.PropertyField(settings.FindProperty("suppressStartupWindow"), new GUIContent("Suppress Startup Window", "Prevent the \"what's new\" (the one that appears if you click the \"Show changelog\" button above) appearing when the version of this plugin has changed and Unity is opened. This can be useful for CI/CD pipelines, where auto-launching editor windows can fail to load due to a Unity bug."));
            EditorGUILayout.PropertyField(settings.FindProperty("automaticallyAddDefineSymbols"), new GUIContent("Add define symbols", "If true, automatically adds INK_EDITOR and INK_RUNTIME to the define symbols in the build settings. This is handy for conditional code."));
			//DrawDefineManagerButtons();
			
			EditorGUIUtility.labelWidth = cachedLabelWidth;
			
			EditorGUILayout.Separator();
			DrawRequestButton();
            
			if(EditorGUI.EndChangeCheck()) {
	            if (settings.FindProperty("automaticallyAddDefineSymbols").boolValue) InkDefineSymbols.AddGlobalDefine();
	            else InkDefineSymbols.RemoveGlobalDefine();
	            
				settings.ApplyModifiedProperties();
            }
		}


		static void DrawVersions () {
			EditorGUILayout.LabelField(new GUIContent("Version Info"), EditorStyles.boldLabel);
			EditorGUI.BeginDisabledGroup(true);
			EditorGUILayout.TextField(new GUIContent("Plugin version", "The version of the Ink Unity Integration package."), InkLibrary.unityIntegrationVersionCurrent.ToString());
			EditorGUILayout.TextField(new GUIContent("Ink version", "The version of ink that is included by the Unity package, used to compile and play ink files."), InkLibrary.inkVersionCurrent.ToString());
			EditorGUILayout.TextField(new GUIContent("Ink story format version", "Significant changes to the Ink runtime are recorded by the story format version.\nCompatibility between different versions is limited; see comments at Ink.Runtime.Story.inkVersionCurrent for more details."), Ink.Runtime.Story.inkVersionCurrent.ToString());
			EditorGUILayout.TextField(new GUIContent("Ink save format version", "Version of the ink save/load system.\nCompatibility between different versions is limited; see comments at Ink.Runtime.StoryState.kInkSaveStateVersion for more details."), Ink.Runtime.StoryState.kInkSaveStateVersion.ToString());
			EditorGUI.EndDisabledGroup();
			if (GUILayout.Button("Show changelog", GUILayout.Width(140))) {
				InkUnityIntegrationStartupWindow.ShowWindow();
			}
		}

		static void DrawDefineManagerButtons() {
			EditorGUILayout.LabelField(new GUIContent("Defines"), EditorStyles.boldLabel);
			var hasDefines = InkDefineSymbols.HasGlobalDefines();
			EditorGUILayout.HelpBox("Adds INK_RUNTIME and INK_EDITOR #defines to the project for the current Build Target.", MessageType.Info);
			EditorGUI.BeginDisabledGroup(hasDefines);
			if (GUILayout.Button(new GUIContent("Add Global Define", "Adds INK_RUNTIME and INK_EDITOR defines to your ProjectSettings for the current Build Target."))) {
				InkDefineSymbols.AddGlobalDefine();
			}
			EditorGUI.EndDisabledGroup();
			EditorGUI.BeginDisabledGroup(!hasDefines);
			if (GUILayout.Button(new GUIContent("Remove Global Define", "Removes INK_RUNTIME and INK_EDITOR defines from your ProjectSettings for the current Build Target."))) {
				InkDefineSymbols.RemoveGlobalDefine();
			}
			EditorGUI.EndDisabledGroup();
		}
		
		static void DrawRequestButton() {
			EditorGUILayout.LabelField(new GUIContent("Support + Requests"), EditorStyles.boldLabel);
			
			EditorGUILayout.LabelField("Is there a setting you'd like? Or a feature you'd like to request?");
			// EditorGUILayout.BeginVertical(GUILayout.Width(220));
			EditorGUILayout.BeginHorizontal();
            if(GUILayout.Button("Reach us on Discord", GUILayout.Width(220))) {
                Application.OpenURL("https://discord.gg/inkle");
            }
            if(GUILayout.Button("Submit an issue on GitHub", GUILayout.Width(220))) {
                Application.OpenURL("https://github.com/inkle/ink-unity-integration/issues/new");
            }
			EditorGUILayout.EndHorizontal();
			// EditorGUILayout.EndVertical();
		}

		static void DrawTemplateMissingWarning () {
			EditorGUILayout.HelpBox("Template not found. Ink files created via Assets > Create > Ink will be blank.", MessageType.Info);
		}
	}
}

--- Путь к файлу: .\Assets\Ink\Editor\Tools\Build Validation\InkPreBuildValidationCheck.cs ---

﻿using UnityEngine;
using UnityEditor;
using UnityEditor.Build;
using System.Text;
using Ink.UnityIntegration;
using System.Linq;
#if UNITY_2018_1_OR_NEWER
using UnityEditor.Build.Reporting;
#endif

class InkPreBuildValidationCheck : 
#if UNITY_2018_1_OR_NEWER
IPreprocessBuildWithReport
#else
IPreprocessBuild
#endif
{
	public int callbackOrder { get { return 0; } }
	
    #if UNITY_2018_1_OR_NEWER
    public void OnPreprocessBuild(BuildReport report) {
        PreprocessValidationStep();
    }
    #else
    public void OnPreprocessBuild(BuildTarget target, string path) {
		PreprocessValidationStep();
	}
    #endif

    static void PreprocessValidationStep () {
        // If we're compiling, we've throw an error to cancel the build. Exit out immediately.
        if(!AssertNotCompiling()) return;
        EnsureInkIsCompiled();
    }
    
    // Prevent building if ink is currently compiling. 
    // Ideally we'd force it to complete instantly. 
    // It seems you can do this with WaitHandle.WaitAll but I'm out of my depth!
    // Info here - https://stackoverflow.com/questions/540078/wait-for-pooled-threads-to-complete
    static bool AssertNotCompiling () {
        if(InkCompiler.executingCompilationStack) {
            StringBuilder sb = new StringBuilder("Ink is currently compiling!");
            var errorString = sb.ToString();
            InkCompiler.SetBuildBlocked();
            if(UnityEditor.EditorUtility.DisplayDialog("Ink Build Error!", errorString, "Ok")) {
                Debug.LogError(errorString);
            }
            return false;
        }
        return true;
    }
    
    // Immediately compile any files that aren't compiled and should be.
    static void EnsureInkIsCompiled () {
        var filesToRecompile = InkLibrary.GetFilesRequiringRecompile();
        if(filesToRecompile.Any()) {
            if(InkSettings.instance.compileAllFilesAutomatically) {
                InkCompiler.CompileInk(filesToRecompile.ToArray(), true, null);
            }
        }
    }
}

--- Путь к файлу: .\Assets\Ink\Editor\Tools\File Icons\InkBrowserIcons.cs ---

﻿using System.IO;
using UnityEditor;
using UnityEngine;

/* 
* This script allows you to set custom icons for folders in project browser.
* Recommended icon sizes - small: 16x16 px, large: 64x64 px;
*/

namespace Ink.UnityIntegration {
	[InitializeOnLoad]
	public class InkBrowserIcons {
		private static bool isRetina {
			get {
				float unityVersion = float.Parse(Application.unityVersion.Substring (0, 3));
				return Application.platform == RuntimePlatform.OSXEditor && unityVersion >= 5.4f;
			}
		}
	    private const float largeIconSize = 64f;

		private static Texture2D _inkFileIcon;
		public static Texture2D inkFileIcon {
			get {
				if(_inkFileIcon == null) {
					if(isRetina) {
						_inkFileIcon = Resources.Load<Texture2D>("InkFileIcon-retina");
					} else {
						_inkFileIcon = Resources.Load<Texture2D>("InkFileIcon");
					}
				}
				return _inkFileIcon;
			}
		}
		private static Texture2D _inkFileIconLarge;
		public static Texture2D inkFileIconLarge {
			get {
				if(_inkFileIconLarge == null) {
					_inkFileIconLarge = Resources.Load<Texture2D>("InkFileIcon-large");
				}
				return _inkFileIconLarge;
			}
		}
		private static Texture2D _errorIcon;
		public static Texture2D errorIcon {
			get {
				if(_errorIcon == null) {
					_errorIcon = Resources.Load<Texture2D>("InkErrorIcon");
				}
				return _errorIcon;
			}
		}
		private static Texture2D _warningIcon;
		public static Texture2D warningIcon {
			get {
				if(_warningIcon == null) {
					_warningIcon = Resources.Load<Texture2D>("InkWarningIcon");
				}
				return _warningIcon;
			}
		}
		private static Texture2D _todoIcon;
		public static Texture2D todoIcon {
			get {
				if(_todoIcon == null) {
					_todoIcon = Resources.Load<Texture2D>("InkTodoIcon");
				}
				return _todoIcon;
			}
		}
		private static Texture2D _manualIcon;
		public static Texture2D manualIcon {
			get {
				if(_manualIcon == null) {
					_manualIcon = Resources.Load<Texture2D>("InkCompileManualIcon");
				}
				return _manualIcon;
			}
		}
		private static Texture2D _childIcon;
		public static Texture2D childIcon {
			get {
				if(_childIcon == null) {
					_childIcon = Resources.Load<Texture2D>("InkChildIcon");
				}
				return _childIcon;
			}
		}
		private static Texture2D _childIconLarge;
		public static Texture2D childIconLarge {
			get {
				if(_childIconLarge == null) {
					_childIconLarge = Resources.Load<Texture2D>("InkChildIcon-Large");
				}
				return _childIconLarge;
			}
		}
		private static Texture2D _unknownFileIcon;
		public static Texture2D unknownFileIcon {
			get {
				if(_unknownFileIcon == null) {
					_unknownFileIcon = Resources.Load<Texture2D>("InkUnknownFileIcon");
				}
				return _unknownFileIcon;
			}
		}

	    static InkBrowserIcons() {
			EditorApplication.projectWindowItemOnGUI += OnDrawProjectWindowItem;
	    }

	    static void OnDrawProjectWindowItem(string guid, Rect rect) {
	        string path = AssetDatabase.GUIDToAssetPath(guid);
			if (InkEditorUtils.IsInkFile(path)) {
				DefaultAsset asset = AssetDatabase.LoadAssetAtPath<DefaultAsset>(path);
				DrawInkFile(InkLibrary.GetInkFileWithFile(asset), rect);
			}
	    }

		static void DrawInkFile (InkFile inkFile, Rect rect) {
			bool isSmall = rect.width > rect.height;
			if (isSmall) {
				rect.width = rect.height;
			} else {
				rect.height = rect.width;
			}
			if (rect.width >= largeIconSize) {
				DrawLarge(inkFile, rect);
			} else {
				DrawSmall(inkFile, rect);
			}
	    }

		static void DrawLarge (InkFile inkFile, Rect rect) {
			var offset = (rect.width - largeIconSize) * 0.5f;
			rect = new Rect(rect.x + offset, rect.y + offset, largeIconSize, largeIconSize);
			if(inkFileIconLarge != null)
				GUI.DrawTexture(rect, inkFileIconLarge);

			Rect miniRect = new Rect(rect.center, rect.size * 0.5f);
			if(inkFile == null) {
				if(unknownFileIcon != null) {
					GUI.DrawTexture(miniRect, unknownFileIcon);
				}
			} else {
				if(inkFile.hasErrors && errorIcon != null) {
					GUI.DrawTexture(miniRect, errorIcon);
				} else if(inkFile.hasWarnings && warningIcon != null) {
					GUI.DrawTexture(miniRect, warningIcon);
				} else if(inkFile.hasTodos && todoIcon != null) {
					GUI.DrawTexture(miniRect, todoIcon);
				}
				if(inkFile.isIncludeFile && childIcon != null) {
					GUI.DrawTexture(new Rect(rect.x, rect.y, rect.width * 0.5f, rect.height * 0.5f), childIconLarge);
				}
			}
		}

		static void DrawSmall (InkFile inkFile, Rect rect) {
			if(inkFileIcon != null)
				GUI.DrawTexture(rect, inkFileIcon);

			if(inkFile == null) {
				if(unknownFileIcon != null) {
					GUI.DrawTexture(new Rect(rect.x, rect.y, unknownFileIcon.width, unknownFileIcon.height), unknownFileIcon);
				}
			} else {
				if (inkFile.isMaster) {
					if (!InkSettings.instance.ShouldCompileInkFileAutomatically(inkFile)) {
						GUI.DrawTexture(new Rect(rect.x, rect.y + rect.size.y * 0.5f, rect.size.x * 0.5f, rect.size.y * 0.5f), manualIcon);
						
					}
					
					Rect miniRect = new Rect(rect.center, rect.size * 0.5f);
					if(inkFile.hasErrors && errorIcon != null) {
						GUI.DrawTexture(miniRect, errorIcon);
					} else if(inkFile.hasWarnings && warningIcon != null) {
						GUI.DrawTexture(miniRect, warningIcon);
					} else if(inkFile.hasTodos && todoIcon != null) {
						GUI.DrawTexture(miniRect, todoIcon);
					}
				}

				if(inkFile.isIncludeFile && childIcon != null) {
					GUI.DrawTexture(new Rect(rect.x, rect.y, childIcon.width, childIcon.height), childIcon);
				}
			}
	    }
	}
}

--- Путь к файлу: .\Assets\Ink\Editor\Tools\Ink Inspector\DefaultAssetEditor.cs ---

using UnityEngine;
using UnityEditor;
using System;
using System.Collections.Generic;
using System.Reflection;

namespace Ink.UnityIntegration {
	[CustomEditor(typeof(DefaultAsset), true)]
	public class DefaultAssetEditor : Editor {

		private DefaultAssetInspector inspector;

		private void OnEnable () {
			inspector = FindObjectInspector ();
			if(inspector != null) {
				inspector.editor = this;
				inspector.serializedObject = serializedObject;
				inspector.target = target;
				inspector.OnEnable();
			}
		}

		private void OnDisable () {
			if(inspector != null)
				inspector.OnDisable();
		}

		protected override void OnHeaderGUI () {
			if(inspector != null) {
				inspector.OnHeaderGUI();
			}
			else
				base.OnHeaderGUI();
		}

		public override void OnInspectorGUI () {
			if(inspector != null) {
				GUI.enabled = true;
				inspector.OnInspectorGUI();
			}
			else
				base.OnInspectorGUI();
		}

		private DefaultAssetInspector FindObjectInspector () {
			var assembly = Assembly.GetExecutingAssembly();
			var assetPath = AssetDatabase.GetAssetPath(target);
			foreach(var type in assembly.GetTypes()) {
				if(type.IsSubclassOf(typeof(DefaultAssetInspector))) {
					DefaultAssetInspector objectInspector = (DefaultAssetInspector)Activator.CreateInstance(type);
					if(objectInspector.IsValid(assetPath)) {
						objectInspector.target = target;
						return objectInspector;
					}
				}
			}
			return null;
		}
	}
}

--- Путь к файлу: .\Assets\Ink\Editor\Tools\Ink Inspector\DefaultAssetInspector.cs ---

using UnityEngine;
using UnityEditor;

namespace Ink.UnityIntegration {
	public abstract class DefaultAssetInspector {
		// Reference to the actual editor we draw to
		public Editor editor;
		// Shortcut to the target object
		public Object target;
		// Shortcut to the serializedObject
		public SerializedObject serializedObject;

		public abstract bool IsValid(string assetPath);
		public virtual void OnEnable () {}
		public virtual void OnDisable () {}
		public virtual void OnHeaderGUI () {}
		public virtual void OnInspectorGUI() {}
	}
}

--- Путь к файлу: .\Assets\Ink\Editor\Tools\Ink Inspector\InkInspector.cs ---

using UnityEngine;
using UnityEditor;
using System;
using System.IO;
using System.Linq;
using System.Collections.Generic;
using UnityEditorInternal;
using Object = UnityEngine.Object;

namespace Ink.UnityIntegration {
	public class InkInspector : DefaultAssetInspector {

		private InkFile inkFile;
		private ReorderableList includesFileList;
		private ReorderableList mastersFileList;
		private ReorderableList errorList;
		private ReorderableList warningList;
		private ReorderableList todosList;
		private string cachedTrimmedFileContents;
		private const int maxCharacters = 16000;

		public override bool IsValid(string assetPath) {
			return Path.GetExtension(assetPath) == InkEditorUtils.inkFileExtension;
		}

		public override void OnHeaderGUI () {
			GUILayout.BeginHorizontal();
			GUILayout.Space(38f);
			GUILayout.BeginVertical();
			GUILayout.Space(19f);
			GUILayout.BeginHorizontal();

			GUILayoutUtility.GetRect(10f, 10f, 16f, 35f, EditorStyles.layerMaskField);
			GUILayout.FlexibleSpace();

			EditorGUI.BeginDisabledGroup(inkFile == null);
			if (GUILayout.Button("Open", EditorStyles.miniButton)) {
				AssetDatabase.OpenAsset(inkFile.inkAsset, 3);
				GUIUtility.ExitGUI();
			}
			EditorGUI.EndDisabledGroup();

			GUILayout.EndHorizontal();
			GUILayout.EndVertical();
			GUILayout.EndHorizontal();

			Rect lastRect = GUILayoutUtility.GetLastRect();
			Rect rect = new Rect(lastRect.x, lastRect.y, lastRect.width, lastRect.height);
			Rect iconRect = new Rect(rect.x + 6f, rect.y + 6f, 32f, 32f);
			GUI.DrawTexture(iconRect, InkBrowserIcons.inkFileIconLarge);
			Rect childIconRect = new Rect(iconRect.x, iconRect.y, 16f, 16f);
			if(inkFile == null) {
				GUI.DrawTexture(childIconRect, InkBrowserIcons.unknownFileIcon, ScaleMode.ScaleToFit);
			} else if(inkFile.isIncludeFile) {
				GUI.DrawTexture(childIconRect, InkBrowserIcons.childIconLarge, ScaleMode.ScaleToFit);
			}

			Rect titleRect = new Rect(rect.x + 44f, rect.y + 6f, rect.width - 44f - 38f - 4f, 16f);
			titleRect.yMin -= 2f;
			titleRect.yMax += 2f;
			GUI.Label(titleRect, editor.target.name, EditorStyles.largeLabel);
		}

		public override void OnEnable () {
			Rebuild();
			InkCompiler.OnCompileInk += OnCompileInk;
		}

		public override void OnDisable () {
			InkCompiler.OnCompileInk -= OnCompileInk;
		}

		void OnCompileInk (InkFile[] inkFiles) {
			// We could probably be smarter about when we rebuild - only rebuilding if the file that's shown in the inspector is in the list - but it's not frequent or expensive so it's not important!
			Rebuild();
		}

		void Rebuild () {
			cachedTrimmedFileContents = "";
			string assetPath = AssetDatabase.GetAssetPath(target);
			inkFile = InkLibrary.GetInkFileWithPath(assetPath);
			if(inkFile == null) 
				return;

			if (inkFile.includes.Count > 0) CreateIncludeList ();
			else includesFileList = null;

			if (inkFile.masterInkAssets.Count > 0) CreateMastersList ();
			else mastersFileList = null;

			errorList = CreateErrorList();
			warningList = CreateWarningList();
			todosList = CreateTodoList();
			
			cachedTrimmedFileContents = inkFile.GetFileContents();
			cachedTrimmedFileContents = cachedTrimmedFileContents.Substring(0, Mathf.Min(cachedTrimmedFileContents.Length, maxCharacters));
			if(cachedTrimmedFileContents.Length >= maxCharacters)
				cachedTrimmedFileContents += "...\n\n<...etc...>";
		}

		void CreateIncludeList () {
			List<DefaultAsset> includeTextAssets = inkFile.includes;
			includesFileList = new ReorderableList(includeTextAssets, typeof(DefaultAsset), false, true, false, false);
			includesFileList.drawHeaderCallback = (Rect rect) => {  
				EditorGUI.LabelField(rect, "Included Files");
			};
			includesFileList.drawElementCallback = (Rect rect, int index, bool isActive, bool isFocused) => {
				DefaultAsset childAssetFile = ((List<DefaultAsset>)includesFileList.list)[index];
				if(childAssetFile == null) {
					Debug.LogError("Ink file in include list is null. This should never occur. Use Assets > Recompile Ink to fix this issue.");
					EditorGUI.LabelField(rect, new GUIContent("Warning: Ink File in include list is null. Use Assets > Recompile Ink to fix this issue."));
					return;
				}
				InkFile childInkFile = InkLibrary.GetInkFileWithFile(childAssetFile);
				if(childInkFile == null) {
					Debug.LogError("Ink File for included file "+childAssetFile+" not found. This should never occur. Use Assets > Recompile Ink to fix this issue.");
					EditorGUI.LabelField(rect, new GUIContent("Warning: Ink File for included file "+childAssetFile+" not found. Use Assets > Recompile Ink to fix this issue."));
					return;
				}
				Rect iconRect = new Rect(rect.x, rect.y, 0, 16);
				if(childInkFile.hasErrors || childInkFile.hasWarnings) {
					iconRect.width = 20;
				}
				Rect objectFieldRect = new Rect(iconRect.xMax, rect.y, rect.width - iconRect.width - 80, 16);
				Rect selectRect = new Rect(objectFieldRect.xMax, rect.y, 80, 16);
				if(childInkFile.hasErrors) {
					EditorGUI.LabelField(iconRect, new GUIContent(InkBrowserIcons.errorIcon));
				} else if(childInkFile.hasWarnings) {
					EditorGUI.LabelField(iconRect, new GUIContent(InkBrowserIcons.warningIcon));
				}
				EditorGUI.BeginDisabledGroup(true);
				EditorGUI.ObjectField(objectFieldRect, childAssetFile, typeof(Object), false);
				EditorGUI.EndDisabledGroup();
				if(GUI.Button(selectRect, "Select")) {
					Selection.activeObject = childAssetFile;
				}
			};
		}
		
		void CreateMastersList () {
			List<DefaultAsset> mastersTextAssets = inkFile.masterInkAssets;
			mastersFileList = new ReorderableList(mastersTextAssets, typeof(DefaultAsset), false, true, false, false);
			mastersFileList.drawHeaderCallback = (Rect rect) => {  
				EditorGUI.LabelField(rect, "Master Files");
			};
			mastersFileList.drawElementCallback = (Rect rect, int index, bool isActive, bool isFocused) => {
				DefaultAsset masterAssetFile = ((List<DefaultAsset>)mastersFileList.list)[index];
				if(masterAssetFile == null) {
					Debug.LogError("Ink file in masters list is null. This should never occur. Use Assets > Recompile Ink to fix this issue.");
					EditorGUI.LabelField(rect, new GUIContent("Warning: Ink File in masters list is null. Use Assets > Recompile Ink to fix this issue."));
					return;
				}
				InkFile masterInkFile = InkLibrary.GetInkFileWithFile(masterAssetFile);
				if(masterInkFile == null) {
					Debug.LogError("Ink File for master file "+masterAssetFile+" not found. This should never occur. Use Assets > Recompile Ink to fix this issue.");
					EditorGUI.LabelField(rect, new GUIContent("Warning: Ink File for master file "+masterAssetFile+" not found. Use Assets > Recompile Ink to fix this issue."));
					return;
				}
				Rect iconRect = new Rect(rect.x, rect.y, 0, 16);
				if(masterInkFile.hasErrors || masterInkFile.hasWarnings) {
					iconRect.width = 20;
				}
				Rect objectFieldRect = new Rect(iconRect.xMax, rect.y, rect.width - iconRect.width - 80, 16);
				Rect selectRect = new Rect(objectFieldRect.xMax, rect.y, 80, 16);
				if(masterInkFile.hasErrors) {
					EditorGUI.LabelField(iconRect, new GUIContent(InkBrowserIcons.errorIcon));
				} else if(masterInkFile.hasWarnings) {
					EditorGUI.LabelField(iconRect, new GUIContent(InkBrowserIcons.warningIcon));
				}
				EditorGUI.BeginDisabledGroup(true);
				EditorGUI.ObjectField(objectFieldRect, masterAssetFile, typeof(Object), false);
				EditorGUI.EndDisabledGroup();
				if(GUI.Button(selectRect, "Select")) {
					Selection.activeObject = masterAssetFile;
				}

				
			// foreach(var masterInkFile in inkFile.masterInkFiles) {
			// 	EditorGUILayout.BeginHorizontal();
			// 	if(masterInkFile.hasErrors) {
			// 		GUILayout.Label(new GUIContent(InkBrowserIcons.errorIcon), GUILayout.Width(20));
			// 	} else if(masterInkFile.hasWarnings) {
			// 		GUILayout.Label(new GUIContent(InkBrowserIcons.warningIcon), GUILayout.Width(20));
			// 	}
			// 	EditorGUI.BeginDisabledGroup(true);
			// 	EditorGUILayout.ObjectField("Master Ink File", masterInkFile.inkAsset, typeof(Object), false);
			// 	EditorGUI.EndDisabledGroup();
			// 	if(GUILayout.Button("Select", GUILayout.Width(80))) {
			// 		Selection.activeObject = masterInkFile.inkAsset;
			// 	}
			// 	EditorGUILayout.EndHorizontal();
			// }
			};
		}

		ReorderableList CreateErrorList () {
			var reorderableList = new ReorderableList(inkFile.errors, typeof(string), false, true, false, false);
			reorderableList.drawHeaderCallback = (Rect rect) => {  
				EditorGUI.LabelField(rect, new GUIContent(InkBrowserIcons.errorIcon), new GUIContent("Errors"));
			};
			reorderableList.elementHeight = 26;
			reorderableList.drawElementCallback = (rect, index, isActive, isFocused) => DrawLogItem(rect, index, isActive, isFocused, (List<InkCompilerLog>)reorderableList.list);
			return reorderableList;
		}

		ReorderableList CreateWarningList () {
			var reorderableList = new ReorderableList(inkFile.warnings, typeof(string), false, true, false, false);
			reorderableList.drawHeaderCallback = (Rect rect) => {  
				EditorGUI.LabelField(rect, new GUIContent(InkBrowserIcons.warningIcon), new GUIContent("Warnings"));
			};
			reorderableList.elementHeight = 26;
			reorderableList.drawElementCallback = (rect, index, isActive, isFocused) => DrawLogItem(rect, index, isActive, isFocused, (List<InkCompilerLog>)reorderableList.list);
			return reorderableList;
		}

		ReorderableList CreateTodoList () {
			var reorderableList = new ReorderableList(inkFile.todos, typeof(string), false, true, false, false);
			reorderableList.drawHeaderCallback = (Rect rect) => {  
				EditorGUI.LabelField(rect, "To do");
			};
			reorderableList.elementHeight = 26;
			reorderableList.drawElementCallback = (rect, index, isActive, isFocused) => DrawLogItem(rect, index, isActive, isFocused, (List<InkCompilerLog>)reorderableList.list);
			return reorderableList;
		}
		
		void DrawLogItem (Rect rect, int index, bool isActive, bool isFocused, List<InkCompilerLog> logsList) {
			Rect logRect = new Rect(rect.x, rect.y, rect.width - 80, 16);
			Rect locationRect = new Rect(rect.x, rect.y+16, rect.width - 80, 10);
			Rect buttonRect = new Rect(logRect.xMax, rect.y, 80, rect.height-2);
			InkCompilerLog log = logsList[index];
			GUI.Label(logRect, log.content);
			GUI.Label(locationRect, "("+log.relativeFilePath+":"+log.lineNumber+")", filePathAndLineNumberStyle);
			string openLabel = "Open";
			if(GUI.Button(buttonRect, openLabel)) {
				InkEditorUtils.OpenInEditor(inkFile, log);
			}
		}
		static GUIStyle _filePathAndLineNumberStyle;
		static GUIStyle filePathAndLineNumberStyle {
			get {
				if(_filePathAndLineNumberStyle == null) {
					_filePathAndLineNumberStyle = new GUIStyle(EditorStyles.centeredGreyMiniLabel);
					_filePathAndLineNumberStyle.alignment = TextAnchor.MiddleLeft;
				}
				return _filePathAndLineNumberStyle;
			}
		}

		public static void DrawLayoutInkLine (InkFile inkFile, int lineNumber, string label) {
			GUILayout.BeginHorizontal();
			GUILayout.Label(label);
			string openLabel = "Open"+ (lineNumber == -1 ? "" : " ("+lineNumber+")");
			if(GUILayout.Button(openLabel, GUILayout.Width(80))) {
				InkEditorUtils.OpenInEditor(inkFile.filePath, null, lineNumber);
			}
			GUILayout.EndHorizontal();
		}

		public override void OnInspectorGUI () {
			editor.Repaint();
			serializedObject.Update();
			if(inkFile == null) {
				EditorGUILayout.HelpBox("Ink File is not in library.", MessageType.Warning);
				if(GUILayout.Button("Rebuild Library")) {
					InkLibrary.Rebuild();
					Rebuild();
				}
				return;
			}
			
			
			if(InkCompiler.IsInkFileOnCompilationStack(inkFile)) {
				EditorGUILayout.HelpBox("File is compiling...", MessageType.Info);
				return;
			}
			
			if(inkFile.isIncludeFile) {
				EditorGUI.BeginChangeCheck();
				var newCompileAsIfMaster = EditorGUILayout.Toggle(new GUIContent("Should also be Master File", "This file is included by another ink file. Typically, these files don't want to be compiled, but this option enables them to be for special purposes."), InkSettings.instance.includeFilesToCompileAsMasterFiles.Contains(inkFile.inkAsset));
				if(EditorGUI.EndChangeCheck()) {
					if(newCompileAsIfMaster) {
						InkSettings.instance.includeFilesToCompileAsMasterFiles.Add(inkFile.inkAsset);
						EditorUtility.SetDirty(InkSettings.instance);
					} else {
						InkSettings.instance.includeFilesToCompileAsMasterFiles.Remove(inkFile.inkAsset);
						EditorUtility.SetDirty(InkSettings.instance);
					}
				}
				EditorApplication.RepaintProjectWindow();
			}

			if(inkFile.isMaster) {
				EditorGUILayout.BeginVertical(EditorStyles.helpBox);
				DrawMasterFileHeader();
				
				EditorGUILayout.Space();
				
				// There's no point letting users compile when recursive INCLUDE files exist, so hide anything else while they exist!
				if(inkFile.hasRecursiveIncludeErrorPaths) {
					EditorGUILayout.HelpBox("A recursive INCLUDE connection exists in this ink file's INCLUDE hierarchy.\nThe offending INCLUDE(s) can be found at the following file(s):\n"+string.Join("\n", inkFile.recursiveIncludeErrorPaths.Select(x => "• "+x)), MessageType.Error);
				} else {
					if(inkFile.hasUnhandledCompileErrors) {
						EditorGUILayout.HelpBox("Last compiled failed", MessageType.Error);
					} if(inkFile.hasErrors) {
						EditorGUILayout.HelpBox("Last compiled had errors", MessageType.Error);
					} else if(inkFile.hasWarnings) {
						EditorGUILayout.HelpBox("Last compile had warnings", MessageType.Warning);
					} else if(inkFile.jsonAsset == null) {
						EditorGUILayout.HelpBox("Ink file has not been compiled", MessageType.Warning);
					}
					if(inkFile.requiresCompile && GUILayout.Button("Compile")) {
						InkCompiler.CompileInk(inkFile);
					}
					
					DrawCompileErrors();
					DrawErrors();
					DrawWarnings();
					DrawTODOList();
				}

				DrawIncludedFiles();
				EditorGUILayout.EndVertical();
				
				EditorGUILayout.Space();
			}

			if (inkFile.isIncludeFile) {
				EditorGUILayout.BeginVertical(EditorStyles.helpBox);
				EditorGUILayout.LabelField(new GUIContent("Include File", InkBrowserIcons.childIconLarge, "This file is included by at least one other file"), EditorStyles.boldLabel);
				DrawListOfMasterFiles();
				EditorGUILayout.EndVertical();
				
				EditorGUILayout.Space();
			}
			
			DrawFileContents ();
			

			serializedObject.ApplyModifiedProperties();
		}

		void DrawMasterFileHeader () {
			EditorGUILayout.LabelField(new GUIContent("Master File", "This file is a master file and can be compiled"), EditorStyles.boldLabel);
			
			if(inkFile.jsonAsset != null && inkFile.errors.Count == 0 && GUILayout.Button("Play")) {
				InkPlayerWindow.LoadAndPlay(inkFile.jsonAsset);
			}
			
			EditorGUILayout.Space();
			
			EditorGUI.BeginDisabledGroup(true);
			EditorGUILayout.ObjectField("JSON Asset", inkFile.jsonAsset, typeof(TextAsset), false);
			EditorGUI.EndDisabledGroup();
			DrawEditAndCompileDates(inkFile);
			if(!InkSettings.instance.compileAllFilesAutomatically) {
				EditorGUI.BeginChangeCheck();
				var newCompileAutomatically = EditorGUILayout.Toggle(new GUIContent("Compile Automatially", "If true, this file recompiles automatically when any changes are detected."), InkSettings.instance.ShouldCompileInkFileAutomatically(inkFile));
				if(EditorGUI.EndChangeCheck()) {
					if(newCompileAutomatically) {
						InkSettings.instance.filesToCompileAutomatically.Add(inkFile.inkAsset);
						EditorUtility.SetDirty(InkSettings.instance);
					} else {
						InkSettings.instance.filesToCompileAutomatically.Remove(inkFile.inkAsset);
						EditorUtility.SetDirty(InkSettings.instance);
					}
				}
				EditorApplication.RepaintProjectWindow();
			}

//				if(!checkedStoryForErrors) {
//					if(GUILayout.Button("Check for errors")) {
//						GetStoryErrors();
//					}
//				} else {
//					if(exception != null) {
//						EditorGUILayout.HelpBox("Story is invalid\n"+exception.ToString(), MessageType.Error);
//					} else {
//						EditorGUILayout.HelpBox("Story is valid", MessageType.Info);
//					}
//				}
		}
		
		void DrawListOfMasterFiles() {
			if(mastersFileList != null && mastersFileList.count > 0) {
				mastersFileList.DoLayoutList();
			}
		}

		void DrawEditAndCompileDates (InkFile masterInkFile) {
			string editAndCompileDateString = "";
			DateTime lastEditDate = inkFile.lastEditDate;
			editAndCompileDateString += "Last edit date "+lastEditDate.ToString();
			if(masterInkFile.jsonAsset != null) {
				DateTime lastCompileDate = masterInkFile.lastCompileDate;
				editAndCompileDateString += "\nLast compile date "+lastCompileDate.ToString();
				if(lastEditDate > lastCompileDate) {
                    if(EditorApplication.isPlaying && InkSettings.instance.delayInPlayMode) {
					    editAndCompileDateString += "\nWill compile on exiting play mode";
                        EditorGUILayout.HelpBox(editAndCompileDateString, MessageType.Info);
                    } else {
					    EditorGUILayout.HelpBox(editAndCompileDateString, MessageType.Warning);
                    }
				} else {
					EditorGUILayout.HelpBox(editAndCompileDateString, MessageType.None);
				}
			} else {
				EditorGUILayout.HelpBox(editAndCompileDateString, MessageType.None);
			}
		}

		void DrawIncludedFiles () {
			if(includesFileList != null && includesFileList.count > 0) {
				includesFileList.DoLayoutList();
			}
		}

		void DrawCompileErrors () {
			if(inkFile.unhandledCompileErrors.Count == 0) 
				return;
			EditorGUILayout.BeginVertical(GUI.skin.box);
			EditorGUILayout.HelpBox("Compiler bug prevented compilation of JSON file. Please help us fix it by reporting this as a bug.", MessageType.Error);
			EditorGUILayout.BeginHorizontal();
			if(GUILayout.Button("Report via Github")) {
				Application.OpenURL("https://github.com/inkle/ink-unity-integration/issues/new");
			}
			if(GUILayout.Button("Report via Email")) {
				Application.OpenURL("mailto:info@inklestudios.com");
			}
			EditorGUILayout.EndHorizontal();
			foreach(string compileError in inkFile.unhandledCompileErrors) {
				GUILayout.TextArea(compileError);
			}
			EditorGUILayout.EndVertical();
		}

		void DrawErrors () {
			if(errorList != null && errorList.count > 0) {
				errorList.DoLayoutList();
			}
		}

		void DrawWarnings () {
			if(warningList != null && warningList.count > 0) {
				warningList.DoLayoutList();
			}
		}

		void DrawTODOList () {
			if(todosList != null && todosList.count > 0) {
				todosList.DoLayoutList();
			}
		}

		void DrawFileContents () {
			float width = EditorGUIUtility.currentViewWidth-50;
			float height = EditorStyles.wordWrappedLabel.CalcHeight(new GUIContent(cachedTrimmedFileContents), width);
			EditorGUILayout.BeginVertical(EditorStyles.textArea);
			EditorGUILayout.SelectableLabel(cachedTrimmedFileContents, EditorStyles.wordWrappedLabel, GUILayout.ExpandHeight(true), GUILayout.Width(width), GUILayout.Height(height));
			EditorGUILayout.EndVertical();
		}
	}
}

--- Путь к файлу: .\Assets\Ink\Editor\Tools\Player Window\InkHistoryContentItem.cs ---

﻿using System;
using System.Collections.Generic;
using Ink.Runtime;
using UnityEngine;

namespace Ink.UnityIntegration.Debugging {
    [System.Serializable]
    public class InkHistoryContentItem {
        public enum ContentType {
            PresentedContent,
            ChooseChoice,
            PresentedChoice,
            EvaluateFunction,
            CompleteEvaluateFunction,
            ChoosePathString,
            Warning,
            Error,
            DebugNote
        }

        public string content;
        public List<string> tags;
        public ContentType contentType;
        // Creating a datetime from a long is slightly expensive (it can happen many times in a frame). To fix this we cache the result once converted. 
        [SerializeField] JsonDateTime _serializableTime;
        [NonSerialized] bool hasDeserializedTime;
        [NonSerialized] DateTime _time;
        public DateTime time {
            get {
                if (!hasDeserializedTime) {
                    _time = _serializableTime;
                    hasDeserializedTime = true;
                }
                return _time;
            } private set {
                _time = value;
                _serializableTime = value;
            }
        }

        InkHistoryContentItem (string text, ContentType contentType) {
            this.content = text;
            this.contentType = contentType;
            this.time = DateTime.Now;
        }
        InkHistoryContentItem (string text, List<string> tags, ContentType contentType) {
            this.content = text;
            this.tags = tags;
            this.contentType = contentType;
            this.time = DateTime.Now;
        }

        public static InkHistoryContentItem CreateForContent (string choiceText, List<string> tags) {
            return new InkHistoryContentItem(choiceText, tags, InkHistoryContentItem.ContentType.PresentedContent);
        }
        public static InkHistoryContentItem CreateForPresentChoice (Choice choice) {
            return new InkHistoryContentItem(choice.text.Trim(), choice.tags, InkHistoryContentItem.ContentType.PresentedChoice);
        }
        public static InkHistoryContentItem CreateForMakeChoice (Choice choice) {
            return new InkHistoryContentItem(choice.text.Trim(), choice.tags, InkHistoryContentItem.ContentType.ChooseChoice);
        }
        public static InkHistoryContentItem CreateForEvaluateFunction (string functionInfoText) {
            return new InkHistoryContentItem(functionInfoText, InkHistoryContentItem.ContentType.EvaluateFunction);
        }
        public static InkHistoryContentItem CreateForCompleteEvaluateFunction (string functionInfoText) {
            return new InkHistoryContentItem(functionInfoText, InkHistoryContentItem.ContentType.CompleteEvaluateFunction);
        }
        public static InkHistoryContentItem CreateForChoosePathString (string choosePathStringText) {
            return new InkHistoryContentItem(choosePathStringText, InkHistoryContentItem.ContentType.ChoosePathString);
        }
        public static InkHistoryContentItem CreateForWarning (string warningText) {
            return new InkHistoryContentItem(warningText, InkHistoryContentItem.ContentType.Warning);
        }
        public static InkHistoryContentItem CreateForError (string errorText) {
            return new InkHistoryContentItem(errorText, InkHistoryContentItem.ContentType.Error);
        }
        public static InkHistoryContentItem CreateForDebugNote (string noteText) {
            return new InkHistoryContentItem(noteText, InkHistoryContentItem.ContentType.DebugNote);
        }

        struct JsonDateTime {
            public long value;
            public static implicit operator DateTime(JsonDateTime jdt) {
                return DateTime.FromFileTime(jdt.value);
            }
            public static implicit operator JsonDateTime(DateTime dt) {
                JsonDateTime jdt = new JsonDateTime();
                jdt.value = dt.ToFileTime();
                return jdt;
            }
        }
    }
}

--- Путь к файлу: .\Assets\Ink\Editor\Tools\Player Window\InkPlayerWindow.cs ---

﻿using UnityEngine;
using UnityEditorInternal;
using UnityEditor;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Linq;
using Ink.Runtime;
using Ink.UnityIntegration.Debugging;

namespace Ink.UnityIntegration {

	/// <summary>
	/// Ink player window. Tests stories in an editor window.
	/// Stories may be attached at runtime. InkPlayerWindow.DrawStoryPropertyField may be used for this.
	/// </summary>
	public class InkPlayerWindow : EditorWindow {
        #region User Facing

		public static bool visible {get; private set;}
		public static bool isOpen {get; private set;}
		public static bool attached {get; private set;}

		
		// Fires when story is set. Handy if you want to perform actions on the story as soon as it's tethered.
        public static Action<Story> OnDidSetStory;

		// Overrides the action triggered by buttons that display story.currentChoices.
        public static Action<int> OnChooseChoiceIndexOverride;


		// Overrides the "Divert" button for named content. Allows for custom ChoosePathString functionality.
        public static Action<string> OnDivertOverride;
		// Overrides the "Divert" button label. Can be handy for making it clear that Divert has been overridden in different contexts.
        public static Func<string, GUIContent> OnDivertLabelOverride;


        // Allows injecting right click context options into the story content view.
        public delegate void ContextMenuDelegate(GenericMenu contextMenu, InkHistoryContentItem content);
        public static List<ContextMenuDelegate> contextMenuDelegates = new List<ContextMenuDelegate>();

		
		
		public static InkPlayerParams playerParams = InkPlayerParams.Standard;
		public static PlayerOptions playerOptions = new PlayerOptions();

		

		// Create or get the window. If creating, dock it on the same panel as the inspector.
		[MenuItem("Window/Ink Player %#i", false, 2300)]
		public static InkPlayerWindow GetWindow () {
			return GetWindow(true);
		}

		public static InkPlayerWindow GetWindow (bool focus) {
			Type windowType = typeof(Editor).Assembly.GetType("UnityEditor.InspectorWindow");
			return GetWindow<InkPlayerWindow>(windowTitle, focus, windowType);
		}
		


		

		// Entry point for loading and playing a story.
		public static void LoadAndPlay (TextAsset storyJSONTextAsset, bool focusWindow = true) {
			GetWindow(focusWindow);
			if(InkPlayerWindow.story != null) {
				if(EditorUtility.DisplayDialog("Story in progress", "The Ink Player Window is already playing a story. Would you like to stop it and load the new story?", "Stop and load", "Cancel")) {
					InkPlayerWindow.Stop();
					InkPlayerWindow.Play(storyJSONTextAsset);
				}
			} else {
				InkPlayerWindow.Play(storyJSONTextAsset);
			}
		}

		public static void LoadAndPlay (string storyJSON, bool focusWindow = true) {
			GetWindow(focusWindow);
			if(InkPlayerWindow.story != null) {
				if(EditorUtility.DisplayDialog("Story in progress", "The Ink Player Window is already playing a story. Would you like to stop it and load the new story?", "Stop and load", "Cancel")) {
					InkPlayerWindow.Stop();
					InkPlayerWindow.Play(storyJSON);
				}
			} else {
				InkPlayerWindow.Play(storyJSON);
			}
		}
	
		// Handy utility for the common case of not wanting to show the ink player window when game view is maximised
		public static bool GetGameWindowIsMaximised () {
			var gameViewType = typeof(EditorWindow).Assembly.GetType("UnityEditor.GameView");
			var gameWindow = EditorWindow.GetWindow(gameViewType);
            return gameWindow == null ? false : gameWindow.maximized;
		}
		

		// Loads an existing story to the player window. Handy for debugging stories running in games in editor.
		public static void Attach (Story story) {
			Attach(story, InkPlayerWindow.InkPlayerParams.DisableInteraction);
		}
		public static void Attach (Story story, InkPlayerParams inkPlayerParams) {
			Clear();
			playerOptions.continueAutomatically = false;
			playerOptions.chooseAutomatically = false;
			playerParams = inkPlayerParams;
			attached = true;
			attachedWhileInPlayMode = EditorApplication.isPlaying;
			InkPlayerWindow.story = story;
            
			// Clear the last loaded story setup on attaching stories. We don't NEED to do this but it's never really helpful and often seems like a bug.
			InkPlayerWindowState.Instance.lastStoryJSONAssetPath = null;
			InkPlayerWindowState.Instance.lastStoryWasPlaying = false;

            // This allows reconstructing the story so it can be used after recompile. However, it can be expensive to run so there's a good argument for not running it on play!
            // var lastTime = Time.realtimeSinceStartup;
            // storyJSON = InkPlayerWindow.story.ToJson();
            // File.WriteAllText(System.IO.Path.Combine(System.IO.Path.GetTempPath(), "AttachedStory.json"), storyJSON);
            // Debug.Log("Wrote to "+System.IO.Path.Combine(System.IO.Path.GetTempPath(), "AttachedStory.json")+" in "+(Time.realtimeSinceStartup-lastTime));
		}
		
		// Detaches the attached story
		public static void Detach () {
			DetachInstance();
		}


        /// <summary>
		/// Draws a property field for a story using GUILayout, allowing you to attach stories to the player window for debugging.
		/// An example of how this is used is found in the Demo scene.
		/// </summary>
		/// <param name="story">Story.</param>
		/// <param name="label">Label.</param>
		public static void DrawStoryPropertyField (Story story, ref bool expanded, GUIContent label) {
			DrawStoryPropertyField(story, InkPlayerParams.DisableInteraction, ref expanded, label);
		}
		public static void DrawStoryPropertyField (Story story, InkPlayerParams playerParams, ref bool expanded, GUIContent label, bool interactable = false) {
			EditorGUILayout.BeginHorizontal();
			expanded = EditorGUILayout.Foldout(expanded, label, true);
			// var lastRect = GUILayoutUtility.GetLastRect();
			// GUILayout.BeginArea(new Rect(lastRect.x+200,lastRect.y,lastRect.width-200,lastRect.height));
			// Debug.Log(lastRect);
			// GUI.Box(lastRect,"");
			// GUILayout.BeginArea(lastRect);
			if(EditorApplication.isPlaying) {
				if(story != null) {
					// InkPlayerWindow window = InkPlayerWindow.GetWindow(false);
					if(InkPlayerWindow.attached && InkPlayerWindow.story == story) {
						if(GUILayout.Button("Detach", GUILayout.Width(80))) {
							InkPlayerWindow.Detach();
						}
					} else {
						if(GUILayout.Button("Attach", GUILayout.Width(80))) {
							InkPlayerWindow.Attach(story, playerParams);
						}
					}
					// EditorGUI.BeginDisabledGroup(visible);
					if(GUILayout.Button(InkPlayerWindow.isOpen ? "Show Player Window" : "Open Player Window", GUILayout.Width(140))) {
						InkPlayerWindow.GetWindow();
					}
				} else {
					EditorGUI.BeginDisabledGroup(true);
					GUILayout.Button("Story cannot be null to attach to editor");
					EditorGUI.EndDisabledGroup();
				}
			} else {
				EditorGUI.BeginDisabledGroup(true);
				GUILayout.Button("Enter play mode to attach to editor", GUILayout.Width(220));
				EditorGUI.EndDisabledGroup();
			}
			// GUILayout.EndArea();
			EditorGUILayout.EndHorizontal();
			if(expanded) {

				if(story != null) {
					EditorGUI.indentLevel++;
					EditorGUI.BeginDisabledGroup(!interactable);
					// Draw can continue
					EditorGUILayout.BeginHorizontal();
					EditorGUILayout.Toggle("Can Continue", story.canContinue);
					if(GUILayout.Button("Continue")) {
						story.Continue();
					}
					EditorGUILayout.EndHorizontal();

					// Draw current text
					EditorGUILayout.BeginHorizontal();
					EditorGUILayout.PrefixLabel("Current Text");
					EditorGUILayout.TextArea(story.currentText, wordWrappedTextArea);
					EditorGUILayout.EndHorizontal();

					// Draw current choices
					foreach(var choice in story.currentChoices) {
						EditorGUILayout.BeginHorizontal();
						EditorGUILayout.LabelField("Choice "+choice.index, choice.text);
						if(GUILayout.Button(new GUIContent("Choose"))) {
							if(OnChooseChoiceIndexOverride != null) OnChooseChoiceIndexOverride(choice.index);
							else story.ChooseChoiceIndex(choice.index);
						}
						EditorGUILayout.EndHorizontal();
					}
					EditorGUI.EndDisabledGroup();
					EditorGUI.indentLevel--;
				}
			}
		}

		

		/// <summary>
		/// Draws a property field for a story using GUI, allowing you to attach stories to the player window for debugging.
		/// </summary>
		/// <param name="position">Position.</param>
		/// <param name="story">Story.</param>
		/// <param name="label">Label.</param>
		public static void DrawStoryPropertyField (Rect position, Story story, GUIContent label) {
			position = EditorGUI.PrefixLabel(position, label);
			InkPlayerWindow.GetWindow(false);
			if(EditorApplication.isPlaying && story != null/* && story.state != null*/) {
				if(InkPlayerWindow.attached && InkPlayerWindow.story == story) {
					if(GUI.Button(position, "Detach")) {
						InkPlayerWindow.Detach();
					}
				} else {
					if(GUI.Button(position, "Attach")) {
						InkPlayerWindow.Attach(story);
					}
				}
			} else {
				EditorGUI.BeginDisabledGroup(true);
				GUI.Button(position, "Enter play mode to attach to editor");
				EditorGUI.EndDisabledGroup();
			}
		}

        



		// Allows you to change what the ink player does/is allowed to do when a story is loaded.
		// Especially handy for attached stories, where performance is critical or play controls might interfere with the game
		// TODO: Show these params somewhere slightly out of the way (debug mode for the window?) so you can fiddle with them mid-game if you <i>really</i> need to
		public struct InkPlayerParams {
			public bool disablePlayControls;
			public bool disableUndoHistory;
			public bool disableChoices;
			public bool disableStateLoading;
			public bool disableSettingVariables;
			public bool profileOnStart;
            
			public static InkPlayerParams Standard {
				get {
					return new InkPlayerParams();
				}
			} 
			public static InkPlayerParams DisableInteraction {
				get {
					var inkPlayerParams = new InkPlayerParams();
					inkPlayerParams.disablePlayControls = true;
					inkPlayerParams.disableUndoHistory = true;
					inkPlayerParams.disableChoices = true;
					inkPlayerParams.disableStateLoading = true;
					inkPlayerParams.disableSettingVariables = true;
					inkPlayerParams.profileOnStart = false;
					return inkPlayerParams;
				}
			} 
		}

		
        // Allows telling the story to play automatically.
		[System.Serializable]
		public class PlayerOptions {
			public bool continueAutomatically = true;
			public bool chooseAutomatically = false;
			public float continueAutomaticallyTimeInterval = 0.1f;
			public float chooseAutomaticallyTimeInterval = 0.1f;
		}

        #endregion




		
		static string storyJSON;
		static DateTime currentStoryJSONLastEditDateTime;

		private static Story _story;
		public static Story story {
			get {
				return _story;
			} private set {
				if(_story != null) {
					OnUnsetStory();
				}
				_story = value;
				if(_story != null) {
					OnSetStory();
				}
			}
		}


		private static TextAsset _storyStateTextAsset;
		public static TextAsset storyStateTextAsset {
			get {
				return _storyStateTextAsset;
			} set {
				if(_storyStateTextAsset == value) 
					return;
				_storyStateTextAsset = value;
				if(_storyStateTextAsset != null)
					storyStateValid = InkEditorUtils.CheckStoryStateIsValid(storyJSONTextAsset.text, storyStateTextAsset.text);
			}
		}





		[System.Serializable]
		public class InkPlayerWindowState {
			static string settingsEditorPrefsKey = typeof(InkPlayerWindowState).Name +" Settings";
			public static event Action OnCreateOrLoad;
			static InkPlayerWindowState _Instance;
			public static InkPlayerWindowState Instance {
				get {
					if(_Instance == null) LoadOrCreateAndSave();
					return _Instance;
				}
			}

			static InkPlayerWindowState LoadOrCreateAndSave () {
				Load();
				if(_Instance == null) CreateAndSave();
				return _Instance;
			}

			public static void CreateAndSave () {
				_Instance = new InkPlayerWindowState();
				Save(_Instance);
				if(OnCreateOrLoad != null) OnCreateOrLoad();
			}
			
			public static void Save () {
				Save(_Instance);
			}

			public static void Save (InkPlayerWindowState settings) {
				string data = JsonUtility.ToJson(settings);
				EditorPrefs.SetString(settingsEditorPrefsKey, data);
			}

			static void Load () {
				if(!EditorPrefs.HasKey(settingsEditorPrefsKey)) return;
				string data = EditorPrefs.GetString(settingsEditorPrefsKey);
				try {
					_Instance = JsonUtility.FromJson<InkPlayerWindowState>(data);
					if(_Instance != null) if(OnCreateOrLoad != null) OnCreateOrLoad();
				} catch {
					Debug.LogError("Save Data was corrupt and could not be parsed. New data created. Old data was:\n"+data);
					CreateAndSave();
				}
			}

			public string lastStoryJSONAssetPath;
			public bool lastStoryWasPlaying;
			public TextAsset TryGetLastStoryJSONAsset () {
				if(lastStoryJSONAssetPath == null) return null;
				var asset = AssetDatabase.LoadAssetAtPath<TextAsset>(lastStoryJSONAssetPath);
				if(asset == null) {
					lastStoryJSONAssetPath = null;
					Save();
				}
				return asset;
			}

			public StoryPanelState storyPanelState = new StoryPanelState() {showing=true};
			public BaseStoryPanelState choicePanelState = new BaseStoryPanelState() {showing=true};
			public BaseStoryPanelState storyStatePanelState = new BaseStoryPanelState();
			public BaseStoryPanelState profilerPanelState = new BaseStoryPanelState();
			public BaseStoryPanelState saveLoadPanelState = new BaseStoryPanelState();
			// public DivertPanelState divertPanelState = new DivertPanelState();
			public NamedContentPanelState namedContentPanelState = new NamedContentPanelState();
			public FunctionPanelState functionPanelState = new FunctionPanelState();
			// public FunctionPanelState.FunctionParams functionParams = new FunctionPanelState.FunctionParams();
			public VariablesPanelState variablesPanelState = new VariablesPanelState();
			public ObservedVariablesPanelState observedVariablesPanelState = new ObservedVariablesPanelState();
		}

		
		private const string windowTitle = "Ink Player";

		static bool attachedWhileInPlayMode {get; set;}

		static TextAsset _storyJSONTextAsset;
		static TextAsset storyJSONTextAsset {
			get {
				return _storyJSONTextAsset;
			} set {
				if(_storyJSONTextAsset == value) return;
				_storyJSONTextAsset = value;
				if (_storyJSONTextAsset != null) {
					InkPlayerWindowState.Instance.lastStoryJSONAssetPath = AssetDatabase.GetAssetPath(storyJSONTextAsset);
					string fullJSONFilePath = InkEditorUtils.UnityRelativeToAbsolutePath(InkPlayerWindowState.Instance.lastStoryJSONAssetPath);
					currentStoryJSONLastEditDateTime = File.GetLastWriteTime(fullJSONFilePath);
				} else {
					InkPlayerWindowState.Instance.lastStoryJSONAssetPath = null;
				}
				InkPlayerWindowState.Save();
			}
		}
		




		// This tracks the story state each time the user advances the story so that we can undo/redo
		static UndoHistory<InkPlayerHistoryItem> storyStateHistory = new UndoHistory<InkPlayerHistoryItem>();
		// This tracks the story output so we can view it in the content panel
		static List<InkHistoryContentItem> storyHistory = new List<InkHistoryContentItem>();

		
		static Exception playStoryException;
		static bool storyStateValid = false;


//		WindowState windowState = new WindowState();
//		public class WindowState {
		static Vector2 _scrollPosition;
		static Vector2 scrollPosition {
			get {
				return _scrollPosition;
			} set {
				if(_scrollPosition == value) return;
				_scrollPosition = value;
			}
		}
//		}

		
		
		[System.Serializable]
		public class BaseStoryPanelState {
			public bool showing;
			[SerializeField]
			Vector2 _scrollPosition;
			public Vector2 scrollPosition {
				get {
					return _scrollPosition;
				} set {
					if(_scrollPosition == value) return;
					_scrollPosition = value;
					// Deselect lines on scrolling because otherwise unity does weird things with the selection
					// Disabled because it was deselecting the search field as you typed
					// GUI.FocusControl(null);
				}
			}
            
			public float y;
			public float height = 200;
		}

		[System.Serializable]
		public class StoryPanelState : BaseStoryPanelState {
			public DisplayOptions displayOptions = new DisplayOptions();
			public string searchString = string.Empty;
			
			public const float minScrollRectHeight = 30;
			public const float maxScrollRectHeight = 480;
                
            public enum AutoScrollMode {
                WhenAtBottom,
                Always,
                Off
            }
            // Controls when story view should scroll to the bottom when the story view changes.
            public AutoScrollMode autoScrollMode = AutoScrollMode.WhenAtBottom;
		}


		[System.Serializable]
		public class NamedContentPanelState : BaseStoryPanelState {
			public string searchString = string.Empty;
		}

		// [System.Serializable]
		// public class DivertPanelState : BaseStoryPanelState {
		// 	public string divertCommand = String.Empty;
		// }

		static ReorderableList functionInputList;
		[System.Serializable]
		public class FunctionPanelState : BaseStoryPanelState {
			[System.Serializable]
			public class FunctionParams {
				[System.Serializable]
				public class FunctionInput {
					public enum FunctionInputType {
						Float,
						Int,
						String,
						Bool,
						InkVariable,
						InkListVariable
					}
					public FunctionInputType type;
					public float floatValue;
					public int intValue;
					public string stringValue;
					public bool boolValue;
					public string inkVariablePath;
					public object inkVariableValue;
					public InkList inkListVariableValue;
					public string inkListVariablePath;

					public void RefreshInkVariableValue (Story story) {
						if(!string.IsNullOrWhiteSpace(inkVariablePath)) inkVariableValue = story.variablesState[inkVariablePath];
						else inkVariableValue = null;
					}
					public void RefreshInkListVariableValue (Story story) {
						inkListVariableValue = null;
						try {
							if(!string.IsNullOrWhiteSpace(inkListVariablePath)) 
								inkListVariableValue = Ink.Runtime.InkList.FromString(inkListVariablePath, story);
						} catch {}
					}

					public override int GetHashCode () {	
						switch(type) {
						case FunctionPanelState.FunctionParams.FunctionInput.FunctionInputType.Float:
							return floatValue.GetHashCode();
						case FunctionPanelState.FunctionParams.FunctionInput.FunctionInputType.Int:
							return intValue.GetHashCode();
						case FunctionPanelState.FunctionParams.FunctionInput.FunctionInputType.String:
							return stringValue != null ? stringValue.GetHashCode() : 0;
						case FunctionPanelState.FunctionParams.FunctionInput.FunctionInputType.Bool:
							return boolValue.GetHashCode();
						case FunctionPanelState.FunctionParams.FunctionInput.FunctionInputType.InkVariable:
							return inkVariablePath != null ? inkVariablePath.GetHashCode() : 0;
						case FunctionPanelState.FunctionParams.FunctionInput.FunctionInputType.InkListVariable:
							return inkListVariablePath != null ? inkListVariablePath.GetHashCode() : 0;
						default:
							Debug.LogWarning("No hash code for type: "+type);
							return 1;
						}
					}
				}
				public string functionName = String.Empty;
				public List<FunctionInput> inputs = new List<FunctionInput>();

				public int GetInputHashCode () {	
					int hash = 19;
					if(!string.IsNullOrEmpty(functionName)) hash = hash * 31 + functionName.GetHashCode();
					foreach(var item in inputs) hash = (hash * 31) + item.GetHashCode();
					return hash;
				}
			}
			public FunctionParams functionParams = new FunctionParams();
			public int testedFunctionHash;
			public DateTime testedFunctionTime;
			public object functionReturnValue = null;
		}

		[System.Serializable]
		public class VariablesPanelState : BaseStoryPanelState {
			public string searchString = string.Empty;
			public List<string> expandedVariables = new List<string>();
		}
		public class ObservedVariablesPanelState : BaseStoryPanelState {
			// The cache is used to restore observed variables when the user exits play mode.
			public List<string> restorableObservedVariableNames = new List<string>();
			public Dictionary<string, ObservedVariable> observedVariables = new Dictionary<string, ObservedVariable>();
		}

		[System.Serializable]
		public class DisplayOptions {
			[Flags]
			public enum VisibilityOptions {
				Warnings = 1 << 0,
				Errors = 1 << 1,
				Content = 1 << 2,
				PresentedChoices = 1 << 3,
				SelectedChoice = 1 << 4,
				Function = 1 << 5,
				ChoosePathString = 1 << 6,
				DebugNotes = 1 << 7,
				TimeStamp = 1 << 8,
				EmptyEntries = 1 << 9,
				Tags = 1 << 10,
			}
			public VisibilityOptions visibilityOptions = VisibilityOptions.Warnings | VisibilityOptions.Errors | VisibilityOptions.Content;

			public bool displayWarningsInConsole = true;
			public bool displayErrorsInConsole = true;
		}

		static GUIStyle searchTextFieldStyle;
		static GUIStyle searchCancelButtonStyle;

		internal static DateTime dateTimeNow;


		static float lastOnGUITime = -1f;
		static float lastUpdateTime = -1f;

        

        // Lots of bits to do with the story view scroll rect
		public enum AutoScrollSmoothingMode {
			NONE,
			Snap,
			Smooth
		}
        
        static float storyScrollRectBottom;
        static bool storyScrollSnappedToBottom;
		static AutoScrollSmoothingMode storyScrollMarkedForBottom;
		static AutoScrollSmoothingMode storyScrollMarkedForSelectedLine;
		static InkHistoryContentItem selectedLine;

        static bool mainScrollViewActive;
		
		static bool doingAutoscroll;
		static float autoscrollTarget;
		static float autoscrollVelocity;
		static float autoscrollSmoothTime = 0.225f;



		static float timeUntilNextAutomaticChoice = 0;
		static float timeUntilNextAutomaticContinue = 0;



        // TODO - find a way to restore tethered stories after recompile. This is tricky because we don't have a reference to the json, and stories aren't serialized.
        // We should probably save the story to this path - but watch out for giant stories.
        // var jsonStr = story.ToJson ();
        // https://docs.microsoft.com/en-us/dotnet/api/system.io.path.gettemppath
        // Directory.temporaryFolder
		void OnEnable () {
			if(isOpen) return;
			isOpen = true;
			
			InkPlayerWindowState.OnCreateOrLoad += () => {
				// InkPlayerWindowState.Instance.functionPanelState.functionParams = InkPlayerWindowState.Instance.functionParams;
				BuildFunctionInputList();
			};
			
			BuildFunctionInputList();
			
			EditorApplication.update += Update;

			if(story == null && !EditorApplication.isPlayingOrWillChangePlaymode) {
				var lastLoadedStory = InkPlayerWindowState.Instance.TryGetLastStoryJSONAsset();
				if(lastLoadedStory != null) {
					if(InkPlayerWindowState.Instance.lastStoryWasPlaying) {
						LoadAndPlay(lastLoadedStory, false);
					} else {
						TryPrepareInternal(lastLoadedStory);
					}
				}
			}
		}

		void OnDisable () {
			EditorApplication.update -= Update;
		}

		private void OnBecameVisible() {
        	visible = true;
			if(doingAutoscroll) {
				InkPlayerWindowState.Instance.storyPanelState.scrollPosition = new Vector2(InkPlayerWindowState.Instance.storyPanelState.scrollPosition.x, autoscrollTarget);
				doingAutoscroll = false;
			}
		}
		
		void OnBecameInvisible () {
			visible = false;
		}
			
		void OnDestroy () {
			isOpen = false;
			Clear();
		}

		private static void Update () {
			var time = Time.realtimeSinceStartup;
			var deltaTime = 0f;
			if(lastUpdateTime != -1)
				deltaTime = time - lastUpdateTime;
			lastUpdateTime = time;
			
            if(story != null) {
				timeUntilNextAutomaticChoice -= deltaTime;
				if(story.currentChoices.Count > 0 && playerOptions.chooseAutomatically) {
					if(timeUntilNextAutomaticChoice <= 0) {
						MakeRandomChoice();
						timeUntilNextAutomaticChoice = playerOptions.chooseAutomaticallyTimeInterval;
					}
				}
				if(story.canContinue && playerOptions.continueAutomatically) {
					timeUntilNextAutomaticContinue -= deltaTime;
					if(timeUntilNextAutomaticContinue <= 0) {
						if(playerOptions.continueAutomaticallyTimeInterval == 0) {
							story.ContinueMaximally();
						} else {
							ContinueStory();
						}
						timeUntilNextAutomaticContinue = playerOptions.continueAutomaticallyTimeInterval;
					}
				}
			}
		}




		

		static void OnDidContinue () {
            AddStoryContent(story.currentText.Trim(), story.currentTags);
			if(story.currentChoices != null) {
				foreach(var choice in story.currentChoices) {
					AddToHistory(InkHistoryContentItem.CreateForPresentChoice(choice));
				}
			}
			AddWarningsAndErrorsToHistory();
		}
		static void OnMakeChoice (Choice choice) {
            AddToHistory(InkHistoryContentItem.CreateForMakeChoice(choice));		
			AddWarningsAndErrorsToHistory();
		}
		static void OnEvaluateFunction (string functionName, object[] arguments) {
            StringBuilder sb = new StringBuilder(functionName);
			if(arguments != null && arguments.Length > 0) {
				sb.Append(" with args: ");
				for (int i = 0; i < arguments.Length; i++) {
					if(arguments[i] == null) sb.Append("NULL");
					else {
						sb.Append(arguments[i]);
						sb.Append(" (");
						sb.Append(arguments[i].GetType().Name);
						sb.Append(")");
					}
					if(i < arguments.Length-1) sb.Append(", ");
				}
			}
			AddToHistory(InkHistoryContentItem.CreateForEvaluateFunction(sb.ToString().Trim()));		
			AddWarningsAndErrorsToHistory();
		}
		static void OnCompleteEvaluateFunction (string functionName, object[] arguments, string textOutput, object result) {
			StringBuilder sb = new StringBuilder(functionName);
			if(arguments != null && arguments.Length > 0) {
				sb.Append(" with args: ");
				for (int i = 0; i < arguments.Length; i++) {
					if(arguments[i] == null) sb.Append("NULL");
					else {
						sb.Append(arguments[i]);
						sb.Append(" (");
						sb.Append(arguments[i].GetType().Name);
						sb.Append(")");
					}
					if(i < arguments.Length-1) sb.Append(", ");
				}
				bool hasTextOutput = textOutput != null && textOutput != string.Empty;
				if(hasTextOutput) sb.Append(" text output is: "+textOutput);
				if(result != null) sb.Append(" result is: "+result);
				if(!hasTextOutput && result == null) sb.Append("has no output");
			}
			AddToHistory(InkHistoryContentItem.CreateForCompleteEvaluateFunction(sb.ToString().Trim()));		
			AddWarningsAndErrorsToHistory();
		}
		static void OnChoosePathString (string pathString, object[] arguments) {
            StringBuilder sb = new StringBuilder("ChoosePathString: ");
			sb.Append(pathString);
			if(arguments != null) {
				sb.Append(" with args: ");
				for (int i = 0; i < arguments.Length; i++) {
					if(arguments[i] == null) sb.Append("NULL");
					else {
						sb.Append(arguments[i]);
						sb.Append(" (");
						sb.Append(arguments[i].GetType().Name);
						sb.Append(")");
					}
					if(i < arguments.Length-1) sb.Append(", ");
				}
			}
			AddToHistory(InkHistoryContentItem.CreateForChoosePathString(sb.ToString().Trim()));
			AddWarningsAndErrorsToHistory();
		}
        static void OnLoadState () {
            OnDidContinue();
        }

		static void AddWarningsAndErrorsToHistory () {
			if(story.hasWarning) {
				foreach(var warning in story.currentWarnings) {
					AddToHistory(InkHistoryContentItem.CreateForWarning(warning.Trim()));
					if(InkPlayerWindowState.Instance.storyPanelState.displayOptions.displayWarningsInConsole) {
						Debug.LogWarning("Ink Warning: "+warning.Trim());
					}
				}
			}
			if(story.hasError) {
				foreach(var error in story.currentErrors) {
					AddToHistory(InkHistoryContentItem.CreateForError(error.Trim()));
					if(InkPlayerWindowState.Instance.storyPanelState.displayOptions.displayErrorsInConsole) {
						Debug.LogError("Ink Error: "+error.Trim());
					}
				}
			}
		}





		static void DetachInstance () {
			attached = false;
			story = null;
		}

		
		static void Play (TextAsset storyJSONTextAsset) {
			Play(storyJSONTextAsset, InkPlayerParams.Standard);
		}
		static void Play (TextAsset storyJSONTextAsset, InkPlayerParams inkPlayerParams) {
			if(TryPrepareInternal(storyJSONTextAsset)) {
				InkPlayerWindow.playerParams = inkPlayerParams;
				PlayInternal();
			}
		}
		static void Play (string storyJSON) {
			Play(storyJSON, InkPlayerParams.Standard);
		}
		static void Play (string storyJSON, InkPlayerParams inkPlayerParams) {
			if(TryPrepareInternal(storyJSON)) {
				InkPlayerWindow.playerParams = inkPlayerParams;
				PlayInternal();
			}
		}


		static void PlayInternal () {
			story = new Story(storyJSON);
		}

		// Loads the story, ready to be played
		static bool TryPrepareInternal (TextAsset newStoryJSONTextAsset) {
			// This forces a refresh
			storyJSONTextAsset = null;
			storyJSONTextAsset = newStoryJSONTextAsset;
			if(storyJSONTextAsset == null || !InkEditorUtils.CheckStoryIsValid(storyJSONTextAsset.text, out playStoryException))
				return false;
			storyJSON = storyJSONTextAsset.text;
			return true;
		}
		static bool TryPrepareInternal (string newStoryJSON) {
			if(!InkEditorUtils.CheckStoryIsValid(storyJSON, out playStoryException))
				return false;
			InkPlayerWindow.storyJSONTextAsset = null;
			InkPlayerWindow.storyJSON = newStoryJSON;
			return true;
		}

		static void OnUnsetStory () {
			// Unsubscribe from all story events we subscribed to
			_story.onDidContinue -= OnDidContinue;
			_story.onMakeChoice -= OnMakeChoice;
			_story.onEvaluateFunction -= OnEvaluateFunction;
			_story.onCompleteEvaluateFunction -= OnCompleteEvaluateFunction;
			_story.onChoosePathString -= OnChoosePathString;
			_story.state.onDidLoadState -= OnLoadState;
			
			// Clear any exceptions related to the story we were storing
			playStoryException = null;
			
			// Clear the history 
			ClearStoryHistory();
			
			// Unobserve all observed variables.
			foreach(var observedVariableName in InkPlayerWindowState.Instance.observedVariablesPanelState.restorableObservedVariableNames)
				UnobserveVariable(observedVariableName, false);
			InkPlayerWindowState.Instance.observedVariablesPanelState.observedVariables.Clear();
			
			InkPlayerWindowState.Instance.lastStoryWasPlaying = false;

			InkPlayerWindowState.Save();
		}


		static void OnSetStory () {
			// Allow function fallbacks so we can subscribe to them and avoid throwing errors.
			_story.allowExternalFunctionFallbacks = true;
			
			// Subscribe to all story events we'll use
			_story.onDidContinue += OnDidContinue;
			_story.onMakeChoice += OnMakeChoice;
			_story.onEvaluateFunction += OnEvaluateFunction;
			_story.onCompleteEvaluateFunction += OnCompleteEvaluateFunction;
			_story.onChoosePathString += OnChoosePathString;
			_story.state.onDidLoadState += OnLoadState;

            if(OnDidSetStory != null) OnDidSetStory(story);
			
			// Recalculate function ink variables
			foreach(var input in InkPlayerWindowState.Instance.functionPanelState.functionParams.inputs) {
				if(input.type == FunctionPanelState.FunctionParams.FunctionInput.FunctionInputType.InkVariable) {
					input.RefreshInkVariableValue(story);
				} else if(input.type == FunctionPanelState.FunctionParams.FunctionInput.FunctionInputType.InkListVariable) {
					input.RefreshInkListVariableValue(story);
				}
			}
			
			// Reobserve variables
			var variablesToObserve = new List<string>(InkPlayerWindowState.Instance.observedVariablesPanelState.restorableObservedVariableNames);
			InkPlayerWindowState.Instance.observedVariablesPanelState.observedVariables.Clear();
			InkPlayerWindowState.Instance.observedVariablesPanelState.restorableObservedVariableNames.Clear();
			foreach(var observedVariableName in variablesToObserve) {
				if(_story.variablesState.Contains(observedVariableName)) {
					var observedVariable = ObserveVariable(observedVariableName, true);
					observedVariable.AddValueState(_story.variablesState[observedVariableName]);
				}
			}

            RefreshVisibleHistory();
            RefreshVisibleVariables();

			if(!attached) 
				InkPlayerWindowState.Instance.lastStoryWasPlaying = true;
			InkPlayerWindowState.Save();
			
			if(playerParams.profileOnStart) isProfiling = true;

			PingAutomator();
		}


		static void PingAutomator () {
			if(playerParams.disablePlayControls) return;
			if(story == null) return;
            if(story.canContinue && playerOptions.continueAutomatically) {
				TryContinue();
			} else if(story.currentChoices.Count > 0 && playerOptions.chooseAutomatically) { 
				MakeRandomChoice();
			}
		}
		
		
		static void Stop () {
			Clear ();
		}
		
		// This function's role isn't clear. It's used both when restarting a story and when clearing it entirely. We should probably have two separate functions.
		static void Clear () {
			// InkPlayerWindowState.Instance.observedVariablesPanelState.restorableObservedVariableNames.Clear();
			
			// Clear the variable panel search
			RefreshVisibleVariables();
			
			story = null;
		}
		
		static void Restart () {
			Stop();
			if(storyJSONTextAsset != null)
				Play(storyJSONTextAsset);
			else if(storyJSON != null)
				Play(storyJSON);
			else
				Debug.LogError("Can't restart because no text asset or cached JSON exists");
		}

		static bool CanRestart() {
			return storyJSONTextAsset != null || storyJSON != null;
		}
		
		static void ContinueStory () {
			story.Continue();
		}

		static void AddStoryContent (string content, List<string> tags) {
			AddToHistory(InkHistoryContentItem.CreateForContent(content, tags));
			if(!playerParams.disableUndoHistory) AddToStateHistory();
		}
		
		static void AddToHistory (InkHistoryContentItem content) {
			storyHistory.Add(content);
            RefreshVisibleHistory();
            if(GetShouldAutoScrollOnStoryChange())
			    ScrollToBottom();
		}

		static void AddToStateHistory () {
			InkPlayerHistoryItem historyItem = new InkPlayerHistoryItem(story.state.ToJson(), new List<InkHistoryContentItem>(storyHistory));
			storyStateHistory.AddToUndoHistory(historyItem);
		}
		
		static void ClearStoryHistory () {
			storyHistory.Clear();
			storyStateHistory.Clear();
			RefreshVisibleHistory();
			ScrollToBottom();
		}

		static void CopyStoryHistoryToClipboard () {
			StringBuilder sb = new StringBuilder("Story Log\n");
			foreach(InkHistoryContentItem content in storyHistory) {
				sb.AppendLine();
				sb.Append(content.time.ToShortDateString());
				sb.Append(" ");
				sb.Append(content.time.ToLongTimeString());
				sb.Append(" (");
				sb.Append(content.contentType.ToString());
				sb.Append(") ");
				sb.Append(content.content);
			}
			GUIUtility.systemCopyBuffer = sb.ToString();
		}
		static void Undo () {
			InkPlayerHistoryItem item = storyStateHistory.Undo();
			story.state.LoadJson(item.inkStateJSON);
			storyHistory = new List<InkHistoryContentItem>(item.storyHistory);
            RefreshVisibleHistory();
            if(GetShouldAutoScrollOnStoryChange())
                ScrollToBottom();
		}
		
		static void Redo () {
			InkPlayerHistoryItem item = storyStateHistory.Redo();
			story.state.LoadJson(item.inkStateJSON);
			storyHistory = new List<InkHistoryContentItem>(item.storyHistory);
			RefreshVisibleHistory();
            if(GetShouldAutoScrollOnStoryChange())
                ScrollToBottom();
		}

		static void SaveStoryState (string storyStateJSON) {
			AddToHistory(InkHistoryContentItem.CreateForDebugNote("Saved state"));

			// Text asset can be null if we attached to an existing story rather than loading our own
			string dirPath = string.Empty;
			string storyName = "story";
			if( storyJSONTextAsset != null ) {
				dirPath = System.IO.Path.GetDirectoryName(AssetDatabase.GetAssetPath(storyJSONTextAsset));
				storyName = storyJSONTextAsset.name;
			}

			var newStateAsset = InkEditorUtils.CreateStoryStateTextFile(storyStateJSON, dirPath, storyName+"_SaveState");
			if(!playerParams.disableStateLoading)
				storyStateTextAsset = newStateAsset;
		}

		static void LoadStoryState (string storyStateJSON) {
			storyHistory.Clear();
			storyStateHistory.Clear();
			AddToHistory(InkHistoryContentItem.CreateForDebugNote("Loaded state"));
			story.state.LoadJson(storyStateJSON);
		}

        static bool GetShouldAutoScrollOnStoryChange () {
            if(InkPlayerWindowState.Instance.storyPanelState.autoScrollMode == StoryPanelState.AutoScrollMode.Off) return false;
            if(InkPlayerWindowState.Instance.storyPanelState.autoScrollMode == StoryPanelState.AutoScrollMode.Always) return true;
            if(InkPlayerWindowState.Instance.storyPanelState.autoScrollMode == StoryPanelState.AutoScrollMode.WhenAtBottom && storyScrollSnappedToBottom) return true;
            return false;
        }

		static void ScrollToBottom (bool instant = false) {
			storyScrollMarkedForBottom = instant ? AutoScrollSmoothingMode.Snap : AutoScrollSmoothingMode.Smooth;
		}

		static void ScrollToSelectedLine (bool instant = false) {
			storyScrollMarkedForSelectedLine = instant ? AutoScrollSmoothingMode.Snap : AutoScrollSmoothingMode.Smooth;
		}

		static void TryContinue () {
			if(!story.canContinue) 
				return;
			// if(playerOptions.continueAutomatically) {
			// 	while (story.canContinue) {
			// 		ContinueStory();
			// 	}
			// } else {
				ContinueStory();
			// }
		}
        void OnGUI () {
			HandleDragAndDrop();
			if(searchTextFieldStyle == null) searchTextFieldStyle = GUI.skin.FindStyle("ToolbarSearchTextField") ?? GUI.skin.FindStyle("ToolbarSeachTextField");
			if(searchCancelButtonStyle == null) searchCancelButtonStyle = GUI.skin.FindStyle("ToolbarSearchCancelButton") ?? GUI.skin.FindStyle("ToolbarSeachCancelButton");

			dateTimeNow = DateTime.Now;
			var time = Time.realtimeSinceStartup;
			var deltaTime = 0f;
			if(lastOnGUITime != -1)
				deltaTime = time - lastOnGUITime;
			lastOnGUITime = time;
			
			if(doingAutoscroll) {
				var newY = Mathf.SmoothDamp(InkPlayerWindowState.Instance.storyPanelState.scrollPosition.y, autoscrollTarget, ref autoscrollVelocity, autoscrollSmoothTime, Mathf.Infinity, deltaTime);
				InkPlayerWindowState.Instance.storyPanelState.scrollPosition = new Vector2(InkPlayerWindowState.Instance.storyPanelState.scrollPosition.x, newY);
				if(Mathf.Abs(InkPlayerWindowState.Instance.storyPanelState.scrollPosition.y - autoscrollTarget) < 0.1f) {
                    doingAutoscroll = false;
                }
			}

			this.Repaint();
			
			var lw = EditorGUIUtility.labelWidth;
			EditorGUIUtility.labelWidth = 200;

			scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition);

			if(story == null && attached) 
				DetachInstance();

			DisplayHeader();

			if(playStoryException == null) {
				DisplayStoryControlGroup();
			} else {
				DisplayErrors();
			}

			if(story != null && story.state != null) {
				DrawStoryHistory();
				DrawChoices();
				DrawStoryState();
				DrawProfilerData();
				DrawSaveLoad();
				DrawNamedContent();
				// DrawDiverts();
				DrawFunctions();
				DrawVariables();
				InkPlayerWindowState.Save();
			} else {
				// EditorGUILayout.BeginVertical(GUILayout.Width(position.width * 0.6f));
				GUILayout.Space(40);
				EditorGUILayout.LabelField("Use this window to play and debug ink stories", EditorStyles.boldLabel);
				GUILayout.Space(10);
				EditorGUILayout.LabelField("You can tether your story as it runs in Play Mode to this window, allowing you to view and edit variables and divert in real time!", EditorStyles.wordWrappedLabel);
				GUILayout.Space(20);
				if(GUILayout.Button("View Documentation")) {
					Application.OpenURL("https://github.com/inkle/ink-unity-integration/blob/master/Documentation/InkPlayerWindow.md");
				}
				// EditorGUILayout.EndVertical();
			}

            var lastRectMaxY = GUILayoutUtility.GetLastRect().yMax;
            EditorGUILayout.EndScrollView();
            if (Event.current.type == EventType.Repaint) {
                var scrollRectMaxY = GUILayoutUtility.GetLastRect().yMax;
                mainScrollViewActive = lastRectMaxY >= (scrollRectMaxY-3);
            }

			EditorGUIUtility.labelWidth = lw;
		}
		
		void DisplayHeader () {
			if(attached) {
				EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);
				var headerTitle = new System.Text.StringBuilder("Attached");
				if(attachedWhileInPlayMode != EditorApplication.isPlaying) {
                    playerParams = InkPlayerParams.Standard;
					if(attachedWhileInPlayMode) headerTitle.Append(" (Ex-play-mode story)");
				}
				GUILayout.Label(new GUIContent(headerTitle.ToString(), attachedStoryIcon, "This story reference has been attached from elsewhere"));
				if (GUILayout.Button(new GUIContent("Detach", "Detach from the loaded external story"), EditorStyles.toolbarButton)) {
					Detach();
				}
				EditorGUILayout.EndHorizontal();
			} else {
				EditorGUILayout.BeginVertical();
				EditorGUI.BeginChangeCheck();
				storyJSONTextAsset = EditorGUILayout.ObjectField("Story JSON", storyJSONTextAsset, typeof(TextAsset), false) as TextAsset;
				if(EditorGUI.EndChangeCheck()) {
					if(storyJSONTextAsset == null) {
						story = null;
					} else {
						Stop();
						Play(storyJSONTextAsset);
					}
				}
				if(CanRestart()) {
					string fullJSONFilePath = InkEditorUtils.UnityRelativeToAbsolutePath(AssetDatabase.GetAssetPath(storyJSONTextAsset));
					var updatedStoryJSONLastEditDateTime = File.GetLastWriteTime(fullJSONFilePath);
					if (currentStoryJSONLastEditDateTime != updatedStoryJSONLastEditDateTime ) {
						EditorGUILayout.BeginHorizontal();
						EditorGUILayout.HelpBox ("Story JSON file has changed. Reload or restart to play updated story.", MessageType.Warning);
						EditorGUILayout.BeginVertical();
						if(GUILayout.Button(new GUIContent("Reload", restartIcon, "Reload and restart the current story, which has been updated."))) {
							var storyStateJSON = story.state.ToJson();
							Play(storyJSONTextAsset, InkPlayerWindow.playerParams);
							story.state.LoadJson(storyStateJSON);
						}
						if(GUILayout.Button(new GUIContent("Restart", restartIcon, "Restart the current story"))) {
							Restart();
						}
						EditorGUILayout.EndVertical();
						EditorGUILayout.EndHorizontal();
					}
				}
				EditorGUILayout.EndVertical();
			}
		}
		
		void DisplayErrors () {
			EditorGUILayout.HelpBox(playStoryException.Message, MessageType.Error);
		}

		void DisplayStoryControlGroup () {
			EditorGUILayout.BeginHorizontal (EditorStyles.toolbar);

			if(story == null) {
				EditorGUI.BeginDisabledGroup(storyJSONTextAsset == null);
				if(GUILayout.Button(new GUIContent("Start", playIcon, "Run the story"), EditorStyles.toolbarButton)) {
					var playerParams = InkPlayerParams.Standard;
					playerParams.profileOnStart = InkPlayerWindow.playerParams.profileOnStart;
					Play(storyJSONTextAsset, playerParams);
				}
				EditorGUI.EndDisabledGroup();
			} else {
				EditorGUI.BeginDisabledGroup(playerParams.disablePlayControls);
				if(GUILayout.Button(new GUIContent("Stop", stopIcon, "Stop the story"), EditorStyles.toolbarButton)) {
					Stop();
				}
				EditorGUI.BeginDisabledGroup(!CanRestart());
				if(GUILayout.Button(new GUIContent("Restart", restartIcon, "Restarts the story"), EditorStyles.toolbarButton)) {
					Restart();
				}
				EditorGUI.EndDisabledGroup();
				EditorGUI.EndDisabledGroup();
			}

			GUILayout.FlexibleSpace();

			// Profiler button
			if( story != null ) {
				var profileButtonTitle = new GUIContent(
					isProfiling ? "Stop Profiling" : "Profile", 
					profilerIcon,
					(isProfiling ? "Stop" : "Start") + " Profiling");
				isProfiling = GUILayout.Toggle(isProfiling, profileButtonTitle, EditorStyles.toolbarButton);

			} else {
				var profileButtonTitle = new GUIContent("Profile On Start", profilerIcon, "Immediately start the profiler when the story starts.");
				playerParams.profileOnStart = GUILayout.Toggle(playerParams.profileOnStart, profileButtonTitle, EditorStyles.toolbarButton);
			}
			GUILayout.FlexibleSpace();
				
			// Undo/Redo
			if(story != null) {
				EditorGUI.BeginDisabledGroup(playerParams.disableUndoHistory || !storyStateHistory.canUndo);
				if(GUILayout.Button(new GUIContent("Undo", undoIcon, "Undo the last continue or choice"), EditorStyles.toolbarButton, GUILayout.Width(46))) {
					Undo();
				}
				EditorGUI.EndDisabledGroup();
				EditorGUI.BeginDisabledGroup(playerParams.disableUndoHistory || !storyStateHistory.canRedo);
				if(GUILayout.Button(new GUIContent("Redo", redoIcon, "Redo the last continue or choice"), EditorStyles.toolbarButton, GUILayout.Width(46))) {
					Redo();
				}
				EditorGUI.EndDisabledGroup();
			}

			GUILayout.FlexibleSpace();

			EditorGUI.BeginDisabledGroup(playerParams.disablePlayControls);
			EditorGUI.BeginChangeCheck();
			var newContinueAutomatically = GUILayout.Toggle(playerOptions.continueAutomatically && !playerParams.disablePlayControls, new GUIContent("Auto-Continue", "Continues content automatically"), EditorStyles.toolbarButton);
			if(EditorGUI.EndChangeCheck()) {
				if(!playerParams.disablePlayControls) playerOptions.continueAutomatically = newContinueAutomatically;
				PingAutomator();
			}

			EditorGUI.BeginChangeCheck();
			var newChooseAutomatically = GUILayout.Toggle(playerOptions.chooseAutomatically && !playerParams.disablePlayControls, new GUIContent("Auto-Choice", "Makes choices automatically"), EditorStyles.toolbarButton);
			if(EditorGUI.EndChangeCheck()) {
				if(!playerParams.disablePlayControls) playerOptions.chooseAutomatically = newChooseAutomatically;
			}
			EditorGUI.EndDisabledGroup();
			EditorGUILayout.LabelField(new GUIContent(timeIntervalIcon, "Time between automatic choices"), GUILayout.Width(16));
			playerOptions.continueAutomaticallyTimeInterval = playerOptions.chooseAutomaticallyTimeInterval = GUILayout.HorizontalSlider(playerOptions.continueAutomaticallyTimeInterval, 1f, 0f, GUILayout.Width(80));
			GUILayout.EndHorizontal();
		}
			



		
		#region Story
		void DrawStoryHistory () {
			DisplayStoryHeader();
			if(InkPlayerWindowState.Instance.storyPanelState.showing)
				DisplayStoryBody ();
		}

		void DisplayStoryHeader () {
			EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);
			
			InkPlayerWindowState.Instance.storyPanelState.showing = EditorGUILayout.Foldout(InkPlayerWindowState.Instance.storyPanelState.showing, "Content", true);
			
			if(GUILayout.Button(new GUIContent("Clear", clearIcon, "Clears the output"), EditorStyles.toolbarButton, GUILayout.ExpandWidth(false))) {
				ClearStoryHistory();
			}
			GUILayout.Space(12);
			if(GUILayout.Button(new GUIContent("Copy", /*copyToClipboardIcon, */"Copy the output to clipboard"), EditorStyles.toolbarButton, GUILayout.ExpandWidth(false))) {
				CopyStoryHistoryToClipboard();
			}

			GUILayout.Space(12);
            {
                var lw = EditorGUIUtility.labelWidth;
                var autoScrollGUIContent = EditorGUIUtility.IconContent("ScrollRect Icon");
                autoScrollGUIContent.tooltip = "Autoscroll Mode";
                EditorGUIUtility.labelWidth = 20;
                InkPlayerWindowState.Instance.storyPanelState.autoScrollMode = (StoryPanelState.AutoScrollMode)EditorGUILayout.EnumPopup(autoScrollGUIContent, InkPlayerWindowState.Instance.storyPanelState.autoScrollMode, EditorStyles.toolbarPopup, GUILayout.Width(130));
                EditorGUIUtility.labelWidth = lw;
            }
            
			
			GUILayout.Space(12);
			EditorGUI.BeginChangeCheck();
            DrawVisibilityOptions();
			if(EditorGUI.EndChangeCheck()) {
                RefreshVisibleHistory();
                if(GetShouldAutoScrollOnStoryChange())
				    ScrollToBottom();
			}
            void DrawVisibilityOptions () {
                var lw = EditorGUIUtility.labelWidth;
                var visibilityOptionsGUIContent = EditorGUIUtility.IconContent("d_ViewToolOrbit");
                visibilityOptionsGUIContent.tooltip = "Visiblity Options";
                EditorGUIUtility.labelWidth = 20;
                Enum newVisibilityOptions = EditorGUILayout.EnumFlagsField(visibilityOptionsGUIContent, InkPlayerWindowState.Instance.storyPanelState.displayOptions.visibilityOptions, EditorStyles.toolbarDropDown, GUILayout.Width(80));
                EditorGUIUtility.labelWidth = lw;
                InkPlayerWindowState.Instance.storyPanelState.displayOptions.visibilityOptions = (DisplayOptions.VisibilityOptions)(int)Convert.ChangeType(newVisibilityOptions, typeof(DisplayOptions.VisibilityOptions));

                // TODO: tooltips for options. I'd REALLY like for it not to show "Mixed ..." in the box mais c'est la vie
                // TODO: Add a "default" option in the dropdown
                // See:
                // https://github.com/Unity-Technologies/UnityCsReference/blob/master/Editor/Mono/EditorGUI.cs#L3561
                // But a lot of the code is internal.

                // var enumValue = InkPlayerWindowState.Instance.storyPanelState.displayOptions.visibilityOptions;
                // var style = EditorStyles.toolbarDropDown;
                // var position = EditorGUILayout.GetControlRect(true, 18, style, GUILayout.Width(80));
                
                // var enumType = typeof(DisplayOptions.VisibilityOptions);
                // var includeObsolete = false;
                // var label = GUIContent.none;
                // var displayNames = Enum.GetNames(typeof(DisplayOptions.VisibilityOptions));
                // // var flagValues = new int[];

                // var id = GUIUtility.GetControlID(0, FocusType.Keyboard, position);
                // position = EditorGUI.PrefixLabel(position, id, label);

                // InkPlayerWindowState.Instance.storyPanelState.displayOptions.visibilityOptions = (DisplayOptions.VisibilityOptions)EditorGUI.MaskField(position, (int)enumValue, displayNames, style);
            }

			bool changed = DrawSearchBar(ref InkPlayerWindowState.Instance.storyPanelState.searchString);
			if(changed) {
			    RefreshVisibleHistory();
				if(selectedLine != null) ScrollToSelectedLine(true);
				else ScrollToBottom();
			}

			EditorGUILayout.EndHorizontal();
		}

		static bool ShouldShowContentWithSearchString (string contentString, string searchString) {
			if(StringContains(contentString, searchString, StringComparison.OrdinalIgnoreCase)) return true;
			return false;
		}

		static bool ShouldShowContent (InkHistoryContentItem content, DisplayOptions.VisibilityOptions visibilityOpts) {
			switch(content.contentType) {
				case InkHistoryContentItem.ContentType.PresentedContent: {
					if((visibilityOpts & DisplayOptions.VisibilityOptions.Content) != 0) {
						if(content.content.Length == 0 && (visibilityOpts & DisplayOptions.VisibilityOptions.EmptyEntries) == 0) return false;
						else return true;
					} else return false;
				}
				case InkHistoryContentItem.ContentType.ChooseChoice:
					return (visibilityOpts & DisplayOptions.VisibilityOptions.SelectedChoice) != 0;
				case InkHistoryContentItem.ContentType.PresentedChoice:
					return (visibilityOpts & DisplayOptions.VisibilityOptions.PresentedChoices) != 0;
				case InkHistoryContentItem.ContentType.DebugNote:
					return (visibilityOpts & DisplayOptions.VisibilityOptions.DebugNotes) != 0;
				case InkHistoryContentItem.ContentType.Warning:
					return (visibilityOpts & DisplayOptions.VisibilityOptions.Warnings) != 0;
				case InkHistoryContentItem.ContentType.Error:
					return (visibilityOpts & DisplayOptions.VisibilityOptions.Errors) != 0;
				case InkHistoryContentItem.ContentType.ChoosePathString:
					return (visibilityOpts & DisplayOptions.VisibilityOptions.ChoosePathString) != 0;
				case InkHistoryContentItem.ContentType.EvaluateFunction:
					return (visibilityOpts & DisplayOptions.VisibilityOptions.Function) != 0;
				default: break;
			}
			return false;
		}
		
		static List<InkHistoryContentItem> visibleHistory = new List<InkHistoryContentItem>();
		static void RefreshVisibleHistory () {
			visibleHistory.Clear();
			bool doingSearch = !string.IsNullOrWhiteSpace(InkPlayerWindowState.Instance.storyPanelState.searchString);
			var visibilityOpts = InkPlayerWindowState.Instance.storyPanelState.displayOptions.visibilityOptions;
			var count = storyHistory.Count;
			for(int i = 0; i < count; i++) {
				var content = storyHistory[i];
				if(doingSearch && !ShouldShowContentWithSearchString(content.content, InkPlayerWindowState.Instance.storyPanelState.searchString)) continue;
				if(!ShouldShowContent(content, visibilityOpts)) continue;
				visibleHistory.Add(content);
			}
		}

        void DisplayStoryBody () {	
			float contentMarginXY = 4;
			float contentSpacing = 8;
			
			var timestampWidth = 58;
			var contentTypeWidth = 26;
			var tagsWidth = 160;

			var visibilityOptions = InkPlayerWindowState.Instance.storyPanelState.displayOptions.visibilityOptions;
			bool showTimestamp = (visibilityOptions & DisplayOptions.VisibilityOptions.TimeStamp) != 0; 
			bool showTags = (visibilityOptions & DisplayOptions.VisibilityOptions.Tags) != 0; 

			var lastRect = GUILayoutUtility.GetLastRect();
			var containerWidth = position.width - GUI.skin.verticalScrollbar.fixedWidth;
            if(mainScrollViewActive) containerWidth -= GUI.skin.verticalScrollbar.fixedWidth;
			
			var lineWidth = containerWidth - contentMarginXY * 2;
			
			var contentWidth = lineWidth;
			if(showTimestamp) {
				contentWidth -= timestampWidth;
				contentWidth -= contentSpacing;
			}
			contentWidth -= contentTypeWidth;
			contentWidth -= contentSpacing;
			if(showTags) {
				contentWidth -= tagsWidth;
				contentWidth -= contentSpacing;
			}
			float totalHeight = 0;
			float[] heights = new float[storyHistory.Count];
			int selectedLineIndex = -1;
			float selectedLineY = -1;

			for(int i = 0; i < visibleHistory.Count; i++) {
				var content = visibleHistory[i];
				heights[i] = EditorStyles.wordWrappedLabel.CalcHeight(new GUIContent(content.content), contentWidth);
				if(showTags) {
					var tagsHeight = EditorStyles.wordWrappedLabel.CalcHeight(new GUIContent(GetTagsString(content.tags)), tagsWidth);
					heights[i] = Mathf.Max(heights[i], tagsHeight);
				}
				heights[i] += contentMarginXY * 2;
				if(content == selectedLine) {
					selectedLineIndex = i;
					selectedLineY = totalHeight;
				}
				totalHeight += heights[i];
			}

            void OnRefreshSelectedLine () {
                float _totalHeight = 0;
                for(int i = 0; i < visibleHistory.Count; i++) {
                    var content = visibleHistory[i];
                    if(content == selectedLine) {
                        selectedLineIndex = i;
                        selectedLineY = _totalHeight;
                    }
                    _totalHeight += heights[i];
                }
            }

			if(Event.current.type == EventType.Repaint) {
				InkPlayerWindowState.Instance.storyPanelState.y = lastRect.yMax;
			}

			var viewportRect = new Rect(0, lastRect.yMax, position.width, InkPlayerWindowState.Instance.storyPanelState.height);
            if(mainScrollViewActive) viewportRect.width -= GUI.skin.verticalScrollbar.fixedWidth;
			var containerRect = new Rect(0,0,containerWidth, totalHeight);


            var showScrollToBottomButton = (totalHeight - viewportRect.height) - (doingAutoscroll ? autoscrollTarget : InkPlayerWindowState.Instance.storyPanelState.scrollPosition.y) > 100;
            var scrollToBottomButtonRect = new Rect(viewportRect.center.x - 80, viewportRect.yMax-40, 160, 32);
            
            if(showScrollToBottomButton) {
                EditorGUIUtility.AddCursorRect(scrollToBottomButtonRect, MouseCursor.Link);
                if(Event.current.type == EventType.MouseDown && Event.current.button == 0 && scrollToBottomButtonRect.Contains(Event.current.mousePosition)) {
                    GUI.FocusControl(null);
                    ScrollToBottom();
                    Event.current.Use();
                }
            }

            storyScrollRectBottom = totalHeight - viewportRect.height;

			
			var newScrollPos = GUI.BeginScrollView(viewportRect, InkPlayerWindowState.Instance.storyPanelState.scrollPosition, containerRect, false, true);
			if(newScrollPos != InkPlayerWindowState.Instance.storyPanelState.scrollPosition) {
				doingAutoscroll = false;
				InkPlayerWindowState.Instance.storyPanelState.scrollPosition = newScrollPos;
                storyScrollSnappedToBottom = storyScrollRectBottom - InkPlayerWindowState.Instance.storyPanelState.scrollPosition.y < 0.1f;
			}

			var y = 0f;
			var panelTop = InkPlayerWindowState.Instance.storyPanelState.scrollPosition.y;
			var panelBottom = InkPlayerWindowState.Instance.storyPanelState.scrollPosition.y + viewportRect.height;
			// int numShown = 0;
			// var log = "";

			// This appears to be necessary, else the selected text moves around when scrolling!
			// if(doingAutoscroll) {
			// 	GUI.FocusControl(null);
			// }
            


			for(int i = 0; i < visibleHistory.Count; i++) {
				var endY = y + heights[i];
				if(panelTop <= endY && panelBottom >= y) {
					// if(numShown == 0) {
					//     log += "Total space "+totalHeight+" Scroll "+InkPlayerWindowState.Instance.storyPanelState.storyScrollPosition.y+" Space "+y+", showing: ";
					// }
					var content = visibleHistory[i];
					var lineContainerRect = new Rect(0, y, containerWidth, heights[i]);
					var lineRect = new Rect(lineContainerRect.x + contentMarginXY, lineContainerRect.y + contentMarginXY, lineContainerRect.width - contentMarginXY * 2, lineContainerRect.height - contentMarginXY * 2);
					
					GUIStyle lineStyle = null;
					if(selectedLine == content) lineStyle = historyItemBGStyleSelected.guiStyle;
					else lineStyle = i % 2 == 0 ? historyItemBGStyleDark.guiStyle : historyItemBGStyleLight.guiStyle;
					
					GUI.Box(lineContainerRect, GUIContent.none, lineStyle);
                    EditorGUIUtility.AddCursorRect(lineContainerRect, MouseCursor.ArrowPlus);
					if(Event.current.type == EventType.MouseDown && lineContainerRect.Contains(Event.current.mousePosition)) {
						if(Event.current.button == 0) {
							selectedLine = content;
                            OnRefreshSelectedLine();
                            // To avoid disruption, only scroll when the line is close to the edge of the panel
                            var targetY = GetTargetScrollPositionToCenterStoryLine(i, false);
                            if(Mathf.Abs(targetY-InkPlayerWindowState.Instance.storyPanelState.scrollPosition.y) > viewportRect.height * 0.225f) {
                                ScrollToSelectedLine();
                            }
                            Event.current.Use();
						}
					}
					string textToDisplay = String.Empty;
					
					var x = lineRect.x;
					if(showTimestamp) {
						var timeRect = new Rect(x, lineRect.y, timestampWidth, lineRect.height);
						DisplayLineTime(timeRect, content);
						x += timestampWidth;
						x += contentSpacing;
					}
					var iconRect = new Rect(x, lineRect.y, contentTypeWidth, lineRect.height);
					DisplayLineIcon(iconRect, content);
					x += contentTypeWidth;
					x += contentSpacing;
					
					var contentRect = new Rect(x, lineRect.y, contentWidth, lineRect.height);
					DisplayLine(contentRect, content);
					x += contentWidth;
					x += contentSpacing;
					if(showTags) {
						var tagsRect = new Rect(x, lineRect.y, tagsWidth, lineRect.height);
						DisplayTags(tagsRect, content);
						x += tagsWidth;
						x += contentSpacing;
					}

					if(Event.current.type == EventType.MouseDown && lineContainerRect.Contains(Event.current.mousePosition)) {
                        if(Event.current.button == 1) {
							if(GUI.GetNameOfFocusedControl() != content.GetHashCode().ToString()) {
								GUI.FocusControl(null);
								var contextMenu = new GenericMenu();
								contextMenu.AddItem(new GUIContent("Copy"), false, () => {
									GUIUtility.systemCopyBuffer = content.content;
								});
                                foreach(var contextMenuDelegate in contextMenuDelegates) {
                                    contextMenuDelegate(contextMenu, content);
                                }
								contextMenu.ShowAsContext();
								Event.current.Use();
							}
						}
					}

					// log += i+", ";
				}
				y = endY;
			}

			var lineX = contentMarginXY;
			if(showTimestamp) {
				lineX += timestampWidth;
				lineX += contentSpacing * 0.5f;
				GUI.Box(new Rect(lineX, 0, 1, containerRect.height), "", dividerLineStyle.guiStyle);
				lineX += contentSpacing * 0.5f;
			}

			lineX += contentTypeWidth;
			lineX += contentSpacing * 0.5f;
			GUI.Box(new Rect(lineX, 0, 1, containerRect.height), "", dividerLineStyle.guiStyle);
			lineX += contentSpacing * 0.5f;
			
			if(showTags) {
				lineX += contentWidth;
				lineX += contentSpacing * 0.5f;
				GUI.Box(new Rect(lineX, 0, 1, containerRect.height), "", dividerLineStyle.guiStyle);
				lineX += contentSpacing * 0.5f;
			}

			GUI.EndScrollView();

            if(showScrollToBottomButton) {
                GUI.Box(scrollToBottomButtonRect, "Scroll to bottom", GUI.skin.button);
            }

			GUILayout.Space(viewportRect.height);



			if(Event.current.type == EventType.Layout) {
				if(storyScrollMarkedForBottom != AutoScrollSmoothingMode.NONE) {
					var targetPosition = totalHeight - viewportRect.height;
					if(storyScrollMarkedForBottom == AutoScrollSmoothingMode.Smooth) {
						doingAutoscroll = true;
						autoscrollTarget = targetPosition;
					} else if(storyScrollMarkedForBottom == AutoScrollSmoothingMode.Snap) {
						doingAutoscroll = false;
						InkPlayerWindowState.Instance.storyPanelState.scrollPosition = new Vector2(InkPlayerWindowState.Instance.storyPanelState.scrollPosition.x, targetPosition);
					}
					autoscrollVelocity = 0;
                    storyScrollSnappedToBottom = true;
					storyScrollMarkedForBottom = AutoScrollSmoothingMode.NONE;
				}
				if(storyScrollMarkedForSelectedLine != AutoScrollSmoothingMode.NONE && selectedLineIndex != -1) {
					var targetPosition = GetTargetScrollPositionToCenterStoryLine(selectedLineIndex);
					if(storyScrollMarkedForSelectedLine == AutoScrollSmoothingMode.Smooth) {
						doingAutoscroll = true;
						autoscrollTarget = targetPosition;
					} else if(storyScrollMarkedForSelectedLine == AutoScrollSmoothingMode.Snap) {
						doingAutoscroll = false;
						InkPlayerWindowState.Instance.storyPanelState.scrollPosition = new Vector2(InkPlayerWindowState.Instance.storyPanelState.scrollPosition.x, targetPosition);
					}
					autoscrollVelocity = 0;
                    storyScrollSnappedToBottom = (storyScrollRectBottom+viewportRect.height * 0.5f) - targetPosition < 0.1f;
					storyScrollMarkedForSelectedLine = AutoScrollSmoothingMode.NONE;
				}
			}

			float GetTargetScrollPositionToCenterStoryLine (int lineIndex, bool clamped = true) {
				var targetY = (selectedLineY + heights[lineIndex] * 0.5f) - viewportRect.height * 0.5f;
				if(clamped) targetY = Mathf.Clamp(targetY, 0, totalHeight - viewportRect.height);
				return targetY;
			}
		}

		static ColoredBackgroundGUIStyle _historyItemBGStyleDark;
		static ColoredBackgroundGUIStyle historyItemBGStyleDark {
			get {
				if(_historyItemBGStyleDark == null) _historyItemBGStyleDark = new ColoredBackgroundGUIStyle(new Color(0.8470589f,0.8470589f,0.8470589f,1), new Color(0.21f,0.21f,0.21f,1f), new Color(0.92f,0.92f,0.92f,1), new Color(0.3f,0.3f,0.3f,1f));
				return _historyItemBGStyleDark;
			}
		}

		static ColoredBackgroundGUIStyle _historyItemBGStyleLight;
		static ColoredBackgroundGUIStyle historyItemBGStyleLight {
			get {
				if(_historyItemBGStyleLight == null) _historyItemBGStyleLight = new ColoredBackgroundGUIStyle(new Color(0.8745099f,0.8745099f,0.8745099f,1f), new Color(0.23f,0.23f,0.23f,1f), new Color(0.92f,0.92f,0.92f,1), new Color(0.3f,0.3f,0.3f,1f));
				return _historyItemBGStyleLight;
			}
		}

		static ColoredBackgroundGUIStyle _historyItemBGStyleSelected;
		static ColoredBackgroundGUIStyle historyItemBGStyleSelected {
			get {
				if(_historyItemBGStyleSelected == null) _historyItemBGStyleSelected = new ColoredBackgroundGUIStyle(new Color(0.3920879f,0.6161963f,0.9339623f,1f), new Color(0.243137255f,0.37254902f,0.588235294f,1f));
				return _historyItemBGStyleSelected;
			}
		}

		static ColoredBackgroundGUIStyle _dividerLineStyle;
		static ColoredBackgroundGUIStyle dividerLineStyle {
			get {
				if(_dividerLineStyle == null) _dividerLineStyle = new ColoredBackgroundGUIStyle(new Color(0.85f,0.85f,0.85f,1f), new Color(0.25f,0.25f,0.25f,1f));
				return _dividerLineStyle;
			}
		}

		void DisplayLineTime (Rect rect, InkHistoryContentItem content) {
			EditorGUI.LabelField(rect, new GUIContent(content.time.ToLongTimeString()));
		}

		void DisplayLineIcon (Rect rect, InkHistoryContentItem content) {
			var visibilityOptions = InkPlayerWindowState.Instance.storyPanelState.displayOptions.visibilityOptions;
			if(content.contentType == InkHistoryContentItem.ContentType.ChooseChoice && (visibilityOptions & DisplayOptions.VisibilityOptions.SelectedChoice) != 0) {
				var icon = new GUIContent("*", "Selected Choice");
				EditorGUI.LabelField(rect, icon);
			} else if(content.contentType == InkHistoryContentItem.ContentType.PresentedChoice && (visibilityOptions & DisplayOptions.VisibilityOptions.PresentedChoices) != 0) {
				var icon = new GUIContent("*?", "Presented Choice");
				EditorGUI.LabelField(rect, icon);
			} else if(content.contentType == InkHistoryContentItem.ContentType.EvaluateFunction && (visibilityOptions & DisplayOptions.VisibilityOptions.Function) != 0) {
				var icon = new GUIContent("f(x)", "Took Function");
				EditorGUI.LabelField(rect, icon);
			} else if(content.contentType == InkHistoryContentItem.ContentType.ChoosePathString && (visibilityOptions & DisplayOptions.VisibilityOptions.ChoosePathString) != 0) {
				var icon = new GUIContent("->", "Took Path");
				EditorGUI.LabelField(rect, icon);
			} else if(content.contentType == InkHistoryContentItem.ContentType.DebugNote && (visibilityOptions & DisplayOptions.VisibilityOptions.DebugNotes) != 0) {
				var icon = new GUIContent("//", "Debug Note");
				EditorGUI.LabelField(rect, icon);
			} else if(content.contentType == InkHistoryContentItem.ContentType.Warning && (visibilityOptions & DisplayOptions.VisibilityOptions.Warnings) != 0) {
				var icon = EditorGUIUtility.IconContent("console.warnicon.sml");
				icon.tooltip = "Warning";
				EditorGUI.LabelField(rect, icon);
			} else if(content.contentType == InkHistoryContentItem.ContentType.Error && (visibilityOptions & DisplayOptions.VisibilityOptions.Errors) != 0) {
				var icon = EditorGUIUtility.IconContent("console.erroricon.sml");
				icon.tooltip = "Error";
				EditorGUI.LabelField(rect, icon);
			} else {
				// var icon = EditorGUIUtility.IconContent("console.infoicon.sml");
				// EditorGUI.LabelField(rect, icon);
			}
		}

		void DisplayLine (Rect rect, InkHistoryContentItem content) {
			if (content.content.Length == 0) return;
			float timeSinceLastWrite = (float)(dateTimeNow - content.time).TotalSeconds;
			var revealTime = 0.8f;
			var l = Mathf.InverseLerp(revealTime, 0, timeSinceLastWrite);
			var newColor = new Color(GUI.color.r, GUI.color.g, GUI.color.b, 0);
			var color = Color.Lerp(GUI.color, newColor, l);
			var oldGUIColor = GUI.color; 
			GUI.color = color;
			GUI.SetNextControlName(content.GetHashCode().ToString());
			EditorGUI.SelectableLabel(rect, content.content, EditorStyles.wordWrappedLabel);
			GUI.color = oldGUIColor;
		}

		void DisplayTags (Rect rect, InkHistoryContentItem content) {
			if (content.tags == null || content.tags.Count == 0) return;
			float timeSinceLastWrite = (float)(dateTimeNow - content.time).TotalSeconds;
			var revealTime = 0.8f;
			var l = Mathf.InverseLerp(revealTime, 0, timeSinceLastWrite);
			var newColor = new Color(GUI.color.r, GUI.color.g, GUI.color.b, 0);
			var color = Color.Lerp(GUI.color, newColor, l);
			var oldGUIColor = GUI.color; 
			GUI.color = color;
			GUI.SetNextControlName(content.GetHashCode().ToString());
			EditorGUI.SelectableLabel(rect, GetTagsString(content.tags), EditorStyles.wordWrappedLabel);
			GUI.color = oldGUIColor;
		}

		string GetTagsString (List<string> tags) {
			return (tags == null || tags.Count == 0) ? string.Empty : string.Join("\n", tags);
		}
		#endregion






		#region Choices
		void DrawChoices () {
			EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);
			InkPlayerWindowState.Instance.choicePanelState.showing = EditorGUILayout.Foldout(InkPlayerWindowState.Instance.choicePanelState.showing, "Choices", true);
			EditorGUILayout.EndHorizontal();
			if(InkPlayerWindowState.Instance.choicePanelState.showing)
				DisplayChoices ();
		}

		void DisplayChoices () {
			EditorGUI.BeginDisabledGroup(playerParams.disableChoices);
			GUILayout.BeginVertical();
			if(story.canContinue) {
				EditorGUI.BeginDisabledGroup(playerOptions.continueAutomatically);
				if(GUILayout.Button(new GUIContent("Continue", "Continues once"))) {
					ContinueStory();
				}
				if(GUILayout.Button(new GUIContent("Continue Maximally", "Continues until the next choice"))) {
					while(story.canContinue) {
						ContinueStory();
					}
				}
				EditorGUI.EndDisabledGroup();
			} else if(story.currentChoices.Count > 0) {
				EditorGUI.BeginDisabledGroup(playerOptions.chooseAutomatically);
				foreach(Choice choice in story.currentChoices) {
					GUILayout.BeginHorizontal();
					StringBuilder sb = new StringBuilder();
					sb.Append("Index: ");
					sb.AppendLine(choice.index.ToString());
					sb.Append("Tags: ");
					if (choice.tags == null) {
						sb.Append("NONE");
					} else {
						for (var index = 0; index < choice.tags.Count; index++) {
							var tag = choice.tags[index];
							sb.Append(tag);
							if (index < choice.tags.Count - 1) sb.Append(", ");
							else sb.AppendLine();
						}
					}
					sb.Append("SourcePath: ");
					sb.Append(choice.sourcePath.Trim());
					if(GUILayout.Button(new GUIContent(choice.text.Trim(), sb.ToString()))) {
						MakeChoice(choice);
					}
					GUILayout.EndHorizontal();
				}
				EditorGUI.EndDisabledGroup();
			} else {
				GUILayout.Label("Reached end of story");
			}

			GUILayout.EndVertical();
			EditorGUI.EndDisabledGroup();
		}

		static void MakeRandomChoice () {
			MakeChoice(story.currentChoices[UnityEngine.Random.Range(0, story.currentChoices.Count)]);
		}

		static void MakeChoice (Choice choice) {
			if(OnChooseChoiceIndexOverride != null) OnChooseChoiceIndexOverride(choice.index);
			else story.ChooseChoiceIndex(choice.index);
			if(!playerParams.disableUndoHistory) AddToStateHistory();
			TryContinue();
		}
		#endregion
		




		#region StoryState
		static void DrawStoryState () {
			EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);
			InkPlayerWindowState.Instance.storyStatePanelState.showing = EditorGUILayout.Foldout(InkPlayerWindowState.Instance.storyStatePanelState.showing, "Story State", true);
			EditorGUILayout.EndHorizontal();
			if(InkPlayerWindowState.Instance.storyStatePanelState.showing)
				DrawStoryStatePanel ();
		}

		static void DrawStoryStatePanel () {
			GUILayout.BeginVertical();
			
			EditorGUILayout.BeginHorizontal();
			EditorGUILayout.PrefixLabel("Story Seed");
			EditorGUILayout.LabelField(story.state.storySeed.ToString());
			EditorGUILayout.EndHorizontal();

			EditorGUILayout.BeginHorizontal();
			EditorGUILayout.PrefixLabel("Current Turn Index");
			EditorGUILayout.LabelField(story.state.currentTurnIndex.ToString());
			EditorGUILayout.EndHorizontal();

			EditorGUILayout.BeginHorizontal();
			EditorGUILayout.PrefixLabel("Current Path String");
			if(story.canContinue) EditorGUILayout.LabelField(story.state.currentPathString);
			else EditorGUILayout.LabelField("(Always blank when story.canContinue is false)");
			EditorGUILayout.EndHorizontal();

			GUILayout.EndVertical();
		}
		#endregion



		#region SaveLoad
		static void DrawSaveLoad () {
			EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);
			InkPlayerWindowState.Instance.saveLoadPanelState.showing = EditorGUILayout.Foldout(InkPlayerWindowState.Instance.saveLoadPanelState.showing, "Save/Load", true);
			EditorGUILayout.EndHorizontal();
			if(InkPlayerWindowState.Instance.saveLoadPanelState.showing)
				DrawSaveLoadPanel ();
		}

		static void DrawSaveLoadPanel () {
			GUILayout.BeginVertical();

			EditorGUILayout.BeginHorizontal();
			if (GUILayout.Button("Copy To Clipboard")) {
				GUIUtility.systemCopyBuffer = InkEditorUtils.FormatJson(story.state.ToJson());
			}
			if (GUILayout.Button("Save As...")) {
				SaveStoryState(InkEditorUtils.FormatJson(story.state.ToJson()));
			}
			EditorGUILayout.EndHorizontal();

			EditorGUI.BeginDisabledGroup(playerParams.disableStateLoading);
			EditorGUILayout.BeginHorizontal();
			EditorGUI.BeginChangeCheck();
			storyStateTextAsset = EditorGUILayout.ObjectField("Load Story State JSON File", storyStateTextAsset, typeof(TextAsset), false) as TextAsset;
			EditorGUI.BeginDisabledGroup(storyStateTextAsset == null);
			if (GUILayout.Button("Load")) {
				LoadStoryState(storyStateTextAsset.text);
			}
			EditorGUI.EndDisabledGroup();
			EditorGUILayout.EndHorizontal();
			if(storyStateTextAsset != null && !storyStateValid) {
				EditorGUILayout.HelpBox("Loaded story state file is not valid.", MessageType.Error);
			}
			GUILayout.EndVertical();
			EditorGUI.EndDisabledGroup();
		}
		#endregion




		

		#region Diverts
		void DrawNamedContent () {
			DrawNamedContentHeader();
			if(InkPlayerWindowState.Instance.namedContentPanelState.showing)
				DrawNamedContentPanel ();
		}

		void DrawNamedContentHeader () {
			EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);
			InkPlayerWindowState.Instance.namedContentPanelState.showing = EditorGUILayout.Foldout(InkPlayerWindowState.Instance.namedContentPanelState.showing, "Named Content", true);
			
			EditorGUI.BeginDisabledGroup(!InkPlayerWindowState.Instance.namedContentPanelState.showing);
			bool changed = DrawSearchBar(ref InkPlayerWindowState.Instance.namedContentPanelState.searchString);
			if(changed) InkPlayerWindowState.Instance.namedContentPanelState.scrollPosition = Vector2.zero;
			EditorGUI.EndDisabledGroup();

			EditorGUILayout.EndHorizontal();
		}

        void DrawNamedContentPanel () {	
			float contentMarginX = 4;
			float contentMarginY = 0;
			float indentChangeVerticalSpacing = 6;
			
			var lastRect = GUILayoutUtility.GetLastRect();
			var containerWidth = position.width - GUI.skin.verticalScrollbar.fixedWidth;
            if(mainScrollViewActive) containerWidth -= GUI.skin.verticalScrollbar.fixedWidth;
			
			float totalHeight = 0;

			List<Rect> rects = new List<Rect>();
			List<string> paths = new List<string>();
            {
                AddContainer(string.Empty, story.mainContentContainer);
                void AddContainer (string currentPath, Container container, int indent = 0) {
                    if(container == null || container.namedOnlyContent == null) return;
                    
                    var lastTotalHeight = totalHeight;
                    indent++;
                    foreach(var contentKVP in container.namedOnlyContent) {
                        var newPath = currentPath.Length == 0 ? contentKVP.Key : currentPath+"."+contentKVP.Key;
                        AddContent(newPath, contentKVP, indent);
                    }
                    indent--;
                    if(lastTotalHeight != totalHeight) totalHeight += indentChangeVerticalSpacing;
                }
                void AddContent (string currentPath, KeyValuePair<string, Runtime.Object> contentKVP, int indent = 0) {
                    if(SearchStringMatch(currentPath, InkPlayerWindowState.Instance.namedContentPanelState.searchString)) {
                        var itemHeight = EditorGUIUtility.singleLineHeight;
                        itemHeight += contentMarginY * 2;

                        rects.Add(new Rect(indent*8, totalHeight, containerWidth-indent*8, itemHeight));
                        totalHeight += itemHeight;
                        paths.Add(currentPath);
                    }
                    
                    var namedContainer = contentKVP.Value as Container;
                    AddContainer(currentPath, namedContainer, indent);
                }
            }
            totalHeight -= indentChangeVerticalSpacing;

			if(Event.current.type == EventType.Repaint) {
				InkPlayerWindowState.Instance.namedContentPanelState.y = lastRect.yMax;
			}
			var viewportRect = new Rect(0, lastRect.yMax, position.width, InkPlayerWindowState.Instance.namedContentPanelState.height);
            if(mainScrollViewActive) viewportRect.width -= GUI.skin.verticalScrollbar.fixedWidth;
			var containerRect = new Rect(0,0,containerWidth, totalHeight);
			
			var newScrollPos = GUI.BeginScrollView(viewportRect, InkPlayerWindowState.Instance.namedContentPanelState.scrollPosition, containerRect, false, true);
			if(newScrollPos != InkPlayerWindowState.Instance.namedContentPanelState.scrollPosition) {
				doingAutoscroll = false;
				InkPlayerWindowState.Instance.namedContentPanelState.scrollPosition = newScrollPos;
			}

			var panelTop = InkPlayerWindowState.Instance.namedContentPanelState.scrollPosition.y;
			var panelBottom = InkPlayerWindowState.Instance.namedContentPanelState.scrollPosition.y + viewportRect.height;
            
			for(int i = 0; i < paths.Count; i++) {
				if(panelTop <= rects[i].yMax && panelBottom >= rects[i].yMin) {
					var content = paths[i];
					var lineContainerRect = rects[i];
					var lineRect = new Rect(lineContainerRect.x + contentMarginX, lineContainerRect.y + contentMarginY, lineContainerRect.width - contentMarginX * 2, lineContainerRect.height - contentMarginY * 2);		
					DrawNamedContentItem(lineRect, content);
				}
			}

			GUI.EndScrollView();
			GUILayout.Space(viewportRect.height);
		}

		static GUIContent defaultDivertLabel = new GUIContent("Divert");
		void DrawNamedContentItem (Rect rect, string currentPath) {
			EditorGUI.LabelField(rect, new GUIContent(currentPath, "Path"));
			EditorGUI.LabelField(new Rect(rect.xMax-200, rect.y, 32, rect.height), new GUIContent(story.state.VisitCountAtPathString(currentPath).ToString(), "Read count"));
			if(GUI.Button(new Rect(rect.xMax-168, rect.y, 80, rect.height), OnDivertLabelOverride == null ? defaultDivertLabel : OnDivertLabelOverride(currentPath))) {
                if(OnDivertOverride != null) {
					OnDivertOverride(currentPath);
				} else {
					// This is a bit horrible tbh. Not all the paths we show are valid for diverting, but we don't really have a way of testing it.
					// Additionally, doing this can brick the story, so it's important we prevent it.
					// We test by creating an entirely new story and running it, and checking for errors in the flow.
					// The result is that this function is really slow :(
					var hadError = false;
					try {
						// We might optimise this by caching story.ToJson() - we could use this in other places too.
						var tmpStory = new Story(story.ToJson());
						tmpStory.allowExternalFunctionFallbacks = true;
						var state = story.state.ToJson();
						tmpStory.state.LoadJson(state);
						tmpStory.ChoosePathString(currentPath);
						tmpStory.ContinueMaximally();
					} catch (Exception e) {
						Debug.LogWarning("Could not divert to "+currentPath+"! Only Knots and Stitches can be diverted to. Is this a function? Alternatively, the path might lead to an error, which we prevent from occuring in this tool to safeguard the state.\n"+e.ToString());
						hadError = true;
					} finally {
						if(!hadError) {
							story.ChoosePathString(currentPath);
							AddToHistory(InkHistoryContentItem.CreateForDebugNote("Diverted to '"+currentPath+"'"));
						}
					}
				}
            }

            if(Event.current.type == EventType.MouseDown && Event.current.button == 1 && rect.Contains(Event.current.mousePosition)) {
                var contextMenu = new GenericMenu();
                contextMenu.AddItem(new GUIContent("Copy Path"), false, () => {
                    GUIUtility.systemCopyBuffer = currentPath;
                });
                contextMenu.ShowAsContext();
                Event.current.Use();
            }
		}
		#endregion


		#region Functions
		void DrawFunctions () {
			DrawFunctionsHeader();
			if(InkPlayerWindowState.Instance.functionPanelState.showing)
				DrawFunctionsPanel ();
		}

		void DrawFunctionsHeader () {
			EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);
			InkPlayerWindowState.Instance.functionPanelState.showing = EditorGUILayout.Foldout(InkPlayerWindowState.Instance.functionPanelState.showing, "Functions", true);
			EditorGUILayout.EndHorizontal();
		}

		void DrawFunctionsPanel () {
			GUILayout.BeginVertical();

			DrawFunctionInput();
			DrawFunctionOutput();

			GUILayout.EndVertical();
		}

		void DrawFunctionInput () {
			// TODO - Autocomplete function names using this, which I should add to Story.cs ( ask joe first! )	
			// public IEnumerable<string> allFunctionNames {
			//     get {
			//         return mainContentContainer.namedContent.Keys;
			//     }
			// }

			var functionParams = InkPlayerWindowState.Instance.functionPanelState.functionParams;

			GUILayout.BeginVertical(GUI.skin.box);
			EditorGUI.BeginChangeCheck();
			functionParams.functionName = EditorGUILayout.TextField("Function Name", functionParams.functionName);
			if(EditorGUI.EndChangeCheck()) {
				InkPlayerWindowState.Instance.functionPanelState.testedFunctionHash = 0;
				InkPlayerWindowState.Instance.functionPanelState.testedFunctionTime = default(DateTime);
				InkPlayerWindowState.Instance.functionPanelState.functionReturnValue = null;
			}
			functionInputList.DoLayoutList();
			bool functionIsValid = functionParams.functionName != String.Empty && story.HasFunction(functionParams.functionName);
			EditorGUI.BeginDisabledGroup(!functionIsValid);
			
			Story.ExternalFunction externalFunction;
			var isExternalFunction = story.TryGetExternalFunction(functionParams.functionName, out externalFunction);
			if (GUILayout.Button(new GUIContent(isExternalFunction ? "Execute (External)" : "Execute", "Runs the function"))) {
				AddToHistory(InkHistoryContentItem.CreateForDebugNote("Execute function '"+functionParams.functionName+"'"));
				string outputContent = null;
				object[] allInput = new object[functionParams.inputs.Count];
				for (int i = 0; i < functionParams.inputs.Count; i++) {
					var input = functionParams.inputs[i];
					object obj = null;
					switch(input.type) {
					case FunctionPanelState.FunctionParams.FunctionInput.FunctionInputType.Float:
						obj = input.floatValue;
						break;
					case FunctionPanelState.FunctionParams.FunctionInput.FunctionInputType.Int:
						obj = input.intValue;
						break;
					case FunctionPanelState.FunctionParams.FunctionInput.FunctionInputType.String:
						obj = input.stringValue;
						break;
					case FunctionPanelState.FunctionParams.FunctionInput.FunctionInputType.Bool:
						obj = input.boolValue;
						break;
					case FunctionPanelState.FunctionParams.FunctionInput.FunctionInputType.InkVariable:
						obj = input.inkVariableValue;
						break;
					case FunctionPanelState.FunctionParams.FunctionInput.FunctionInputType.InkListVariable:
						obj = input.inkListVariableValue;
						break;
					}
					allInput[i] = obj;
				}
				if(isExternalFunction) {
					OnEvaluateFunction(functionParams.functionName, allInput);
					InkPlayerWindowState.Instance.functionPanelState.functionReturnValue = externalFunction (allInput);
					OnCompleteEvaluateFunction(functionParams.functionName, allInput, null, InkPlayerWindowState.Instance.functionPanelState.functionReturnValue);
				} else {
					InkPlayerWindowState.Instance.functionPanelState.functionReturnValue = story.EvaluateFunction(functionParams.functionName, out outputContent, allInput);
				}
				if(outputContent != null)
					AddStoryContent(outputContent, null);

				InkPlayerWindowState.Instance.functionPanelState.testedFunctionHash = functionParams.GetInputHashCode();
				InkPlayerWindowState.Instance.functionPanelState.testedFunctionTime = dateTimeNow;
			}
			EditorGUI.EndDisabledGroup();
			GUILayout.EndVertical();
		}

		void DrawFunctionOutput () {
			float timeSinceLastWrite = (float)(dateTimeNow - InkPlayerWindowState.Instance.functionPanelState.testedFunctionTime).TotalSeconds;
			var revealTime = 0.8f;
			var l = Mathf.InverseLerp(revealTime, 0, timeSinceLastWrite);
			var newColor = new Color(GUI.color.r, GUI.color.g, GUI.color.b, 0);
			var color = Color.Lerp(GUI.color, newColor, l);
			var oldGUIColor = GUI.color; 
			GUI.color = color;

			var functionParams = InkPlayerWindowState.Instance.functionPanelState.functionParams;

			bool functionIsValid = functionParams.functionName != String.Empty && story.HasFunction(functionParams.functionName);
			if(functionIsValid && functionParams.GetInputHashCode() == InkPlayerWindowState.Instance.functionPanelState.testedFunctionHash) {
				GUILayout.BeginVertical(GUI.skin.box);
				if(InkPlayerWindowState.Instance.functionPanelState.functionReturnValue == null) {
					EditorGUILayout.LabelField("Output (Null)");
				} else if(InkPlayerWindowState.Instance.functionPanelState.functionReturnValue is string) {
					EditorGUILayout.TextField("Output (String)", (string)InkPlayerWindowState.Instance.functionPanelState.functionReturnValue);
				} else if(InkPlayerWindowState.Instance.functionPanelState.functionReturnValue is float) {
					EditorGUILayout.FloatField("Output (Float)", (float)InkPlayerWindowState.Instance.functionPanelState.functionReturnValue);
				} else if(InkPlayerWindowState.Instance.functionPanelState.functionReturnValue is int) {
					EditorGUILayout.IntField("Output (Int)", (int)InkPlayerWindowState.Instance.functionPanelState.functionReturnValue);
				} else if(InkPlayerWindowState.Instance.functionPanelState.functionReturnValue is bool) {
					EditorGUILayout.Toggle("Output (Bool)", (bool)InkPlayerWindowState.Instance.functionPanelState.functionReturnValue);
				} else if(InkPlayerWindowState.Instance.functionPanelState.functionReturnValue is InkList) {
					EditorGUILayoutInkListField(new GUIContent("Output (InkList)"), (InkList)InkPlayerWindowState.Instance.functionPanelState.functionReturnValue);
				} else {
					EditorGUILayout.LabelField("Function returned unexpected type "+InkPlayerWindowState.Instance.functionPanelState.functionReturnValue.GetType().Name+".");
				}
				GUILayout.EndVertical();
			}
			GUI.color = oldGUIColor;
		}

		void BuildFunctionInputList () {
			var functionParams = InkPlayerWindowState.Instance.functionPanelState.functionParams;

			functionInputList = new ReorderableList(functionParams.inputs, typeof(FunctionPanelState.FunctionParams.FunctionInput), true, true, true, true);
			functionInputList.drawHeaderCallback = (Rect rect) => {
				EditorGUI.LabelField(rect, "Inputs");
			};
			functionInputList.elementHeight = EditorGUIUtility.singleLineHeight + EditorGUIUtility.standardVerticalSpacing * 2;
			functionInputList.drawElementCallback = (Rect rect, int index, bool isActive, bool isFocused) => {
				var input = functionParams.inputs[index];
				Rect typeRect = new Rect(rect.x, rect.y, 80, EditorGUIUtility.singleLineHeight);
				input.type = (FunctionPanelState.FunctionParams.FunctionInput.FunctionInputType)EditorGUI.EnumPopup(typeRect, input.type);
				Rect inputRect = new Rect(rect.x + 90, rect.y, rect.width - 90, EditorGUIUtility.singleLineHeight);
				switch(input.type) {
				case FunctionPanelState.FunctionParams.FunctionInput.FunctionInputType.Float:
					input.floatValue = EditorGUI.FloatField(inputRect, input.floatValue);
					break;
				case FunctionPanelState.FunctionParams.FunctionInput.FunctionInputType.Int:
					input.intValue = EditorGUI.IntField(inputRect, input.intValue);
					break;
				case FunctionPanelState.FunctionParams.FunctionInput.FunctionInputType.String:
					input.stringValue = EditorGUI.TextField(inputRect, input.stringValue);
					break;
				case FunctionPanelState.FunctionParams.FunctionInput.FunctionInputType.Bool:
					input.boolValue = EditorGUI.Toggle(inputRect, input.boolValue);
					break;
				case FunctionPanelState.FunctionParams.FunctionInput.FunctionInputType.InkVariable:
					{
						var halfInput = new Rect(inputRect.x, inputRect.y, Mathf.RoundToInt(inputRect.width * 0.5f) - 5, inputRect.height);
						var halfInput2 = new Rect(inputRect.x + Mathf.RoundToInt(inputRect.width * 0.5f) + 5, inputRect.y, Mathf.RoundToInt(inputRect.width * 0.5f) - 10, inputRect.height);
						EditorGUI.BeginChangeCheck();
						input.inkVariablePath = EditorGUI.TextField(halfInput, input.inkVariablePath);
						if(EditorGUI.EndChangeCheck()) input.RefreshInkVariableValue(story);
						
						EditorGUI.BeginDisabledGroup(true);
						DrawVariable(halfInput2, GUIContent.none, input.inkVariableValue);
						EditorGUI.EndDisabledGroup();
					}
					break;
				case FunctionPanelState.FunctionParams.FunctionInput.FunctionInputType.InkListVariable:
					{
						var halfInput = new Rect(inputRect.x, inputRect.y, Mathf.RoundToInt(inputRect.width * 0.5f) - 5, inputRect.height);
						var halfInput2 = new Rect(inputRect.x + Mathf.RoundToInt(inputRect.width * 0.5f) + 5, inputRect.y, Mathf.RoundToInt(inputRect.width * 0.5f) - 10, inputRect.height);
						EditorGUI.BeginChangeCheck();
						input.inkListVariablePath = EditorGUI.TextField(halfInput, input.inkListVariablePath);
						if(EditorGUI.EndChangeCheck()) input.RefreshInkListVariableValue(story);
						EditorGUI.BeginDisabledGroup(true);
						DrawVariable(halfInput2, GUIContent.none, input.inkListVariableValue);
						EditorGUI.EndDisabledGroup();
					}
					break;
				}
			};
		}
		#endregion



		
		#region Variables
		void DrawVariables () {
            EditorGUILayout.BeginVertical();
			if(InkEditorUtils.StoryContainsVariables(story)) {
				DrawVariablesHeader();
				if(InkPlayerWindowState.Instance.variablesPanelState.showing)
					DrawVariablesPanel ();

				if(InkPlayerWindowState.Instance.observedVariablesPanelState.observedVariables.Count > 0) {
					DrawObservedVariablesHeader();
					if(InkPlayerWindowState.Instance.observedVariablesPanelState.showing)
						DrawObservedVariablesPanel ();
				}
			}
            EditorGUILayout.EndVertical();
		}

		void DrawVariablesHeader () {
			EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);
			InkPlayerWindowState.Instance.variablesPanelState.showing = EditorGUILayout.Foldout(InkPlayerWindowState.Instance.variablesPanelState.showing, "Variables", true);

			EditorGUI.BeginDisabledGroup(!InkPlayerWindowState.Instance.variablesPanelState.showing);
			bool changed = DrawSearchBar(ref InkPlayerWindowState.Instance.variablesPanelState.searchString);
			if(changed) {
                RefreshVisibleVariables();
                InkPlayerWindowState.Instance.variablesPanelState.scrollPosition = Vector2.zero;
            }
			EditorGUI.EndDisabledGroup();

			EditorGUILayout.EndHorizontal();
		}

		void DrawVariablesPanel () {
			GUILayout.BeginVertical(GUI.skin.box, GUILayout.ExpandHeight(true));
			InkPlayerWindowState.Instance.variablesPanelState.scrollPosition = EditorGUILayout.BeginScrollView(InkPlayerWindowState.Instance.variablesPanelState.scrollPosition);
			string variableToChange = null;
			object newVariableValue = null;
			foreach(string variable in visibleVariables) {
				DrawObservableVariable(variable, ref variableToChange, ref newVariableValue);
			}
			if(variableToChange != null) {
				AddToHistory(InkHistoryContentItem.CreateForDebugNote("Change '"+variableToChange+"' from '"+story.variablesState[variableToChange]+"' to '"+newVariableValue+"'"));
				story.variablesState[variableToChange] = newVariableValue;
				variableToChange = null;
				newVariableValue = null;
			}
			
			EditorGUILayout.EndScrollView();
			GUILayout.EndVertical();
		}

        static List<string> visibleVariables = new List<string>();
		static void RefreshVisibleVariables () {
			visibleVariables.Clear();
            if(story == null) return;
			bool doingSearch = !string.IsNullOrWhiteSpace(InkPlayerWindowState.Instance.variablesPanelState.searchString);
			foreach(string variable in story.variablesState) {
				if(doingSearch && !ShouldShowContentWithSearchString(variable, InkPlayerWindowState.Instance.variablesPanelState.searchString)) continue;
				visibleVariables.Add(variable);
			}
		}

        // TODO - only draw those that are visible in the scroll rect, as we do for content. Important for performance on larger projects.
        void DrawObservableVariable (string variable, ref string variableToChange, ref object newVariableValue) {
            if(!SearchStringMatch(variable, InkPlayerWindowState.Instance.variablesPanelState.searchString)) 
                return;
            EditorGUILayout.BeginHorizontal();
            object variableValue = story.variablesState[variable];
            if(DrawVariableLayout(new GUIContent(variable, variableValue.GetType().Name), variable, ref variableValue, "observable")) {
                variableToChange = variable;
                newVariableValue = variableValue;
            }

            if(InkPlayerWindowState.Instance.observedVariablesPanelState.observedVariables.ContainsKey(variable)) {
                if(GUILayout.Button(new GUIContent(unobserveIcon, "Un-observe this variable"), GUILayout.Width(24))) {
                    UnobserveVariable(variable, true);
                }
            } else {
                if(GUILayout.Button(new GUIContent(observeIcon, "Click to observe this variable, tracking changes"), GUILayout.Width(24))) {
                    var observedVariable = ObserveVariable(variable, true);
                    observedVariable.AddValueState(variableValue);
                }
            }
            EditorGUILayout.EndHorizontal();
        }

		static ObservedVariable ObserveVariable (string variableName, bool alsoAddToCache) {
			if(InkPlayerWindowState.Instance.observedVariablesPanelState.observedVariables.ContainsKey(variableName)) return InkPlayerWindowState.Instance.observedVariablesPanelState.observedVariables[variableName];
			var observedVariable = new ObservedVariable(variableName);
			observedVariable.variableObserver = (_variableName, newValue) => {
				observedVariable.AddValueState(newValue);
			};
			story.ObserveVariable(variableName, observedVariable.variableObserver);
			InkPlayerWindowState.Instance.observedVariablesPanelState.observedVariables.Add(variableName, observedVariable);
			if(alsoAddToCache) {
				InkPlayerWindowState.Instance.observedVariablesPanelState.restorableObservedVariableNames.Add(variableName);
				if(InkPlayerWindowState.Instance.observedVariablesPanelState.observedVariables.Count != InkPlayerWindowState.Instance.observedVariablesPanelState.restorableObservedVariableNames.Count) {
					Debug.LogError(InkPlayerWindowState.Instance.observedVariablesPanelState.observedVariables.Count +" "+ InkPlayerWindowState.Instance.observedVariablesPanelState.restorableObservedVariableNames.Count);
					InkPlayerWindowState.Instance.observedVariablesPanelState.restorableObservedVariableNames.Clear();
					InkPlayerWindowState.Instance.observedVariablesPanelState.observedVariables.Clear();
				}
			}
			return observedVariable;
		}
		
		// The cache is used to restore observed variables when the user exits play mode.
		static void UnobserveVariable (string variableName, bool alsoRemoveFromCache) {
			if(!InkPlayerWindowState.Instance.observedVariablesPanelState.observedVariables.ContainsKey(variableName)) return;
			
			var observedVariable = InkPlayerWindowState.Instance.observedVariablesPanelState.observedVariables[variableName];
			story.RemoveVariableObserver(observedVariable.variableObserver, variableName);
			InkPlayerWindowState.Instance.observedVariablesPanelState.observedVariables.Remove(variableName);
			if(alsoRemoveFromCache) {
				InkPlayerWindowState.Instance.observedVariablesPanelState.restorableObservedVariableNames.Remove(variableName);
				if(InkPlayerWindowState.Instance.observedVariablesPanelState.observedVariables.Count != InkPlayerWindowState.Instance.observedVariablesPanelState.restorableObservedVariableNames.Count) {
					Debug.LogError(InkPlayerWindowState.Instance.observedVariablesPanelState.observedVariables.Count +" "+ InkPlayerWindowState.Instance.observedVariablesPanelState.restorableObservedVariableNames.Count);
					InkPlayerWindowState.Instance.observedVariablesPanelState.restorableObservedVariableNames.Clear();
					InkPlayerWindowState.Instance.observedVariablesPanelState.observedVariables.Clear();
				}
			}
		}

		bool DrawVariableLayout (GUIContent guiContent, string variableName, ref object variableValue, string expandedIDModifier) {
			var lastVariableValue = variableValue;
            var anythingChanged = false;
            EditorGUILayout.BeginHorizontal();
			if(variableValue is string) {
				EditorGUI.BeginDisabledGroup(playerParams.disableSettingVariables);
				variableValue = EditorGUILayout.DelayedTextField(guiContent, (string)variableValue);
                anythingChanged = (string)lastVariableValue != (string)variableValue;
				EditorGUI.EndDisabledGroup();
			} else if(variableValue is float) {
				EditorGUI.BeginDisabledGroup(playerParams.disableSettingVariables);
				variableValue = EditorGUILayout.FloatField(guiContent, (float)variableValue);
                anythingChanged = (float)lastVariableValue != (float)variableValue;
				EditorGUI.EndDisabledGroup();
			} else if(variableValue is int) {
				EditorGUI.BeginDisabledGroup(playerParams.disableSettingVariables);
				variableValue = EditorGUILayout.IntField(guiContent, (int)variableValue);
                anythingChanged = (int)lastVariableValue != (int)variableValue;
				EditorGUI.EndDisabledGroup();
			} else if(variableValue is bool) {
				EditorGUI.BeginDisabledGroup(playerParams.disableSettingVariables);
				variableValue = EditorGUILayout.Toggle(guiContent, (bool)variableValue);
                anythingChanged = (bool)lastVariableValue != (bool)variableValue;
				EditorGUI.EndDisabledGroup();
			} else if(variableValue is InkList) {
				anythingChanged = EditorGUILayoutInkListField(guiContent, (InkList)variableValue, variableName+expandedIDModifier);
			} else if(variableValue is Ink.Runtime.Path) {
				var c = new GUIContent(((Ink.Runtime.Path)variableValue).ToString()+" (Ink.Runtime.Path)");
				EditorGUILayout.LabelField(guiContent, c);
			} else if(variableValue == null) {
				EditorGUILayout.LabelField(guiContent, new GUIContent("InkPlayerError: Variable is null"));
			} else {
				EditorGUILayout.LabelField(guiContent, new GUIContent("InkPlayerError: Variable is of unexpected type "+variableValue.GetType().Name+"."));
			}
			EditorGUILayout.LabelField(variableValue.GetType().Name, EditorStyles.miniLabel, GUILayout.Width(80));
			EditorGUILayout.EndHorizontal();
			return anythingChanged;
		}

		object DrawVariable (Rect rect, GUIContent variable, object variableValue) {
			if(variableValue is string) {
				variableValue = EditorGUI.TextField(rect, variable, (string)variableValue);
			} else if(variableValue is float) {
				variableValue = EditorGUI.FloatField(rect, variable, (float)variableValue);
			} else if(variableValue is int) {
				variableValue = EditorGUI.IntField(rect, variable, (int)variableValue);
			} else if(variableValue is InkList) {
				var c = new GUIContent(variable);
				var inkList = (InkList)variableValue;
				c.text += " (InkList)";
				if(inkList.Any()) {
					bool first = true;
					foreach(var item in inkList) {
						if(!first) c.text += ", ";
						c.text += item.ToString();
						first = false;
					}
				} else {
					c.text += " Empty";
				}
				EditorGUI.LabelField(rect, c);
			} else if(variableValue is Ink.Runtime.Path) {
				var c = new GUIContent(((Ink.Runtime.Path)variableValue).ToString()+" (Ink.Runtime.Path)");
				EditorGUI.LabelField(rect, c);
			} else if(variableValue == null) {
				EditorGUI.LabelField(rect, variable, new GUIContent("InkPlayerError: Variable is null"));
			} else {
				EditorGUI.LabelField(rect, variable, new GUIContent("InkPlayerError: Variable is of unexpected type "+variableValue.GetType().Name+"."));
			}
			return variableValue;
		}

		void DrawObservedVariablesHeader () {
			EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);
			InkPlayerWindowState.Instance.observedVariablesPanelState.showing = EditorGUILayout.Foldout(InkPlayerWindowState.Instance.observedVariablesPanelState.showing, "Observed Variables", true);
			EditorGUILayout.EndHorizontal();
		}

		void DrawObservedVariablesPanel () {
			List<string> allToRemove = new List<string>();
			foreach(var observedVariable in InkPlayerWindowState.Instance.observedVariablesPanelState.observedVariables) {
				bool removeVariable = DrawObservedVariable(observedVariable.Value);
				if(removeVariable)
					allToRemove.Add(observedVariable.Key);
			}
			foreach(var toRemove in allToRemove) {
				UnobserveVariable(toRemove, true);
			}
		}

		bool DrawObservedVariable (ObservedVariable observedVariable) {
			GUILayout.BeginHorizontal();
			observedVariable.expanded = EditorGUILayout.Foldout(observedVariable.expanded, observedVariable.variable, true);
			if(GUILayout.Button(new GUIContent(unobserveIcon, "Un-observe this variable"), GUILayout.Width(24))) {
				return true;
			}
			GUILayout.EndHorizontal();

			if(observedVariable.expanded) {
				GUILayout.BeginVertical(GUILayout.ExpandHeight(false));
				observedVariable.scrollPosition = EditorGUILayout.BeginScrollView(observedVariable.scrollPosition, GUI.skin.box);
				
				foreach(var value in observedVariable.values) {
					DrawVariableLayout(new GUIContent(value.dateTime.ToLongTimeString()), observedVariable.variable, ref value.state, "observed"+value.GetHashCode().ToString());
				}
				
				EditorGUILayout.EndScrollView();
				GUILayout.EndVertical();
			}

			return false;
		}
		#endregion





		#region Profiler
		static bool isProfiling {
			get {
				return _currentStoryProfiler != null;
			}
			set {
				var shouldBeProfiling = value;
				if( shouldBeProfiling != isProfiling ) {
					if( _currentStoryProfiler == null ) {
						_currentStoryProfiler = story.StartProfiling();
					} else {
						story.EndProfiling();
						_profilerResultRootNode = _currentStoryProfiler.rootNode;

						Debug.Log(_currentStoryProfiler.StepLengthReport());

						_previousStoryProfiler = _currentStoryProfiler;
						_currentStoryProfiler = null;
					}
				}
			}
		}
		static ProfileNode _profilerResultRootNode;
		static Ink.Runtime.Profiler _currentStoryProfiler;
		static Ink.Runtime.Profiler _previousStoryProfiler;
		
		void DrawProfilerData() {

			// Don't show profiler data at all if you've never clicked Profile button
			if( _profilerResultRootNode == null && !isProfiling ) return;

			EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);
			InkPlayerWindowState.Instance.profilerPanelState.showing = EditorGUILayout.Foldout(InkPlayerWindowState.Instance.profilerPanelState.showing, "Profiler data", true);
			GUILayout.FlexibleSpace();
			if( _previousStoryProfiler != null && GUILayout.Button("Save mega log", EditorStyles.toolbarButton) ) {

				var path = EditorUtility.SaveFilePanel(
					"Save mega log",
					"",
					"megalog.txt",
					"txt");
				if( path != null && path.Length > 0 ) 
					File.WriteAllText(path, _previousStoryProfiler.Megalog());

			}
			EditorGUILayout.EndHorizontal();

			if(InkPlayerWindowState.Instance.profilerPanelState.showing) {
				if(isProfiling) {
					EditorGUILayout.LabelField("Click 'Stop Profiling' to show profiling results.", EditorStyles.centeredGreyMiniLabel);
				} else {
					DisplayProfileDataNode(_profilerResultRootNode);
				}
			}
		}

		void DisplayProfileDataNode(ProfileNode node) {
			var key = node.key;
			if( key == null ) {
				if( node == _profilerResultRootNode )
					key = "TOTAL";
				else
					key = "?";
			}

			var nodeText = key + ": " + node.ownReport;

			if( node.hasChildren ) {
				node.openInUI = EditorGUILayout.Foldout(node.openInUI, nodeText, true);

				if( node.openInUI ) {
					EditorGUI.indentLevel++;

					foreach(var childNode in node.descendingOrderedNodes)
						DisplayProfileDataNode(childNode.Value);

					EditorGUI.indentLevel--;
				}
			} else {
				EditorGUILayout.LabelField(nodeText);
			}
		}
		#endregion
		




		BaseStoryPanelState resizingPanel;
		// float height = 50;
		Rect GetResizeArea (float x, float width, float centerY) {
			float height = 10;
			return new Rect(x, centerY-Mathf.RoundToInt(height * 0.5f), width, height);
		}
		void HandleDragAndDrop () {
			// Rect area1 = GUILayoutUtility.GetRect (0.0f, height, GUILayout.ExpandWidth (true));
			// Rect area2 = GUILayoutUtility.GetRect (0.0f, 50.0f, GUILayout.ExpandWidth (true));
        	// GUI.Box (area1, "Add Trigger");
        	// GUI.Box (area2, "Add Trigger");

			// if (Event.current.type == EventType.DragUpdated) {
			// 	DragAndDrop.visualMode = DragAndDropVisualMode.Copy;
			// 	Event.current.Use();
			// } else if (Event.current.type == EventType.DragPerform) {
			// 	// To consume drag data.
				
			// 	DragAndDrop.AcceptDrag();
			// 	foreach (var obj in DragAndDrop.objectReferences) {
			// 		if(obj is TextAsset && System.IO.Path.GetExtension(AssetDatabase.GetAssetPath(obj)) == ".json") {
			// 			Play(obj as TextAsset);
			// 		}
			// 	}
			// }
            
            if (resizingPanel != null && Event.current.type == EventType.MouseUp) {
                resizingPanel = null;
                Event.current.Use();
            }
            HandlePanelResize(InkPlayerWindowState.Instance.storyPanelState, StoryPanelState.minScrollRectHeight, StoryPanelState.maxScrollRectHeight);
            HandlePanelResize(InkPlayerWindowState.Instance.namedContentPanelState, StoryPanelState.minScrollRectHeight, StoryPanelState.maxScrollRectHeight);
		}
		void HandlePanelResize (BaseStoryPanelState panel, float minHeight, float maxHeight) {
			var resizeArea = GetResizeArea(0, position.width, panel.y+panel.height);
			EditorGUIUtility.AddCursorRect(resizeArea, MouseCursor.ResizeVertical);
			
			if (Event.current.type == EventType.MouseDown) {
				if(resizeArea.Contains(Event.current.mousePosition)) {
					resizingPanel = panel;
					Event.current.Use();
				}
			}
			if (resizingPanel == panel) {
				if(Event.current.type == EventType.MouseDrag) {
					var targetHeight = panel.height + Event.current.delta.y;
					panel.height = Mathf.Clamp(targetHeight, minHeight, maxHeight);
					Event.current.Use();
				}
			}
        }
		
		#region Utils
		static bool StringContains(string str, string toCheck, StringComparison comp) {
			if(toCheck.Length == 0) return false;
			return str.IndexOf(toCheck, comp) >= 0;
		}

		static bool DrawSearchBar (ref string searchString) {
			var lastString = searchString;
			searchString = GUILayout.TextField(searchString, searchTextFieldStyle);
			if (GUILayout.Button("", searchCancelButtonStyle)) {
				searchString = string.Empty;
			}
			return lastString != searchString;
		}

        static bool SearchStringMatch (string content, string searchString) {
            return string.IsNullOrWhiteSpace(searchString) || StringContains(content, searchString, StringComparison.OrdinalIgnoreCase);
        }


		static bool EditorGUILayoutInkListField (GUIContent guiContent, InkList inkList, string expandedVariableKey = null) {
			var anythingChanged = false;
            // if(inkList.Any()) {
				var show = expandedVariableKey == null ? true : InkPlayerWindowState.Instance.variablesPanelState.expandedVariables.Contains(expandedVariableKey);
				var c = new GUIContent(guiContent);
				c.text += " (InkList with "+inkList.Count+" entries)";
				EditorGUILayout.BeginVertical();
				
				EditorGUI.BeginChangeCheck();
				show = EditorGUILayout.Foldout(show, c, true);
				if(EditorGUI.EndChangeCheck() && expandedVariableKey != null) {
					if(show) InkPlayerWindowState.Instance.variablesPanelState.expandedVariables.Add(expandedVariableKey);
					else InkPlayerWindowState.Instance.variablesPanelState.expandedVariables.Remove(expandedVariableKey);
				}
				
				if(show) {
					EditorGUI.indentLevel++;
					var isOrigin = inkList.origins == null;
                    var list = isOrigin ? inkList : inkList.all;
                    List<KeyValuePair<InkListItem, int>> toAdd = null;
                    List<InkListItem> toRemove = null;
                    foreach(var item in list) {
						EditorGUILayout.BeginHorizontal();
						EditorGUILayout.LabelField(new GUIContent(item.Key.fullName));
						// Disabled until I can be bothered to integrate this into the change detection system
						var contains = inkList.Contains(item);
						var newContains = EditorGUILayout.Toggle(contains, GUILayout.Width(100));
                        if(contains != newContains) {
                            if(newContains) {
                                if(toAdd == null) toAdd = new List<KeyValuePair<InkListItem, int>>();
                                toAdd.Add(item);
                            } else {
                                if(toRemove == null) toRemove = new List<InkListItem>();
                                toRemove.Add(item.Key);
                            }
                            anythingChanged = true;
                        }
						EditorGUI.BeginDisabledGroup(true);
						EditorGUILayout.IntField(item.Value, GUILayout.Width(100));
						EditorGUI.EndDisabledGroup();
						EditorGUILayout.EndHorizontal();
					}
                    if(toAdd != null)
                        foreach(var item in toAdd)
                            inkList.Add(item.Key, item.Value);
                    if(toRemove != null)
                        foreach(var item in toRemove)
                            inkList.Remove(item);
					EditorGUI.indentLevel--;
				}
				EditorGUILayout.EndVertical();
			// } else {
			// 	var c = new GUIContent(guiContent);
			// 	c.text += " (InkList)";
			// 	EditorGUILayout.PrefixLabel(c);
			// 	EditorGUILayout.LabelField("Empty");
			// }
            return anythingChanged;
		}

		// static void EditorGUILayoutInkListField (string text, InkList inkList) {
		//     EditorGUILayoutInkListField(new GUIContent(text), inkList);
		// }

		// static void EditorGUILayoutInkListField (GUIContent content, InkList inkList) {
		//     EditorGUILayout.BeginVertical(GUI.skin.box);
		//     EditorGUILayout.LabelField("InkList with "+inkList.Count+" values:", EditorStyles.boldLabel);
		//     foreach(var item in inkList) {
		//         EditorGUILayout.LabelField(item.Key.ToString()+" ("+item.Value.ToString()+")");
		//     }
		//     EditorGUILayout.EndVertical();
		// }
		static void EditorGUIInkListField (Rect rect, GUIContent content, InkList inkList, string variableName) {
			EditorGUI.PrefixLabel(rect, content);
			if(inkList.Any()) {
				if(GUILayout.Button("Log Contents")) {
					string log = "Log for InkList "+variableName+":";
					foreach(var item in inkList)
						log += item.ToString() + " / ";
					Debug.Log(log);
				}
			} else {
				EditorGUI.LabelField(rect, "Empty");
			}
		}
		#endregion


		

		static GUIStyle _wordWrappedTextArea;
		static GUIStyle wordWrappedTextArea {
			get {
				if(_wordWrappedTextArea == null) {
					_wordWrappedTextArea = new GUIStyle(EditorStyles.textArea);
					_wordWrappedTextArea.wordWrap = true;
				}
				return _wordWrappedTextArea;
			}
		}

		static Texture _profilerIcon;
		static Texture profilerIcon {
			get {
				if(_profilerIcon == null) {
					_profilerIcon = EditorGUIUtility.IconContent("UnityEditor.ProfilerWindow").image;
					// Profiler.CPU
					// Record Off
					// Record On
				}
				return _profilerIcon;
			}
		}
		
		static Texture _playIcon;
		static Texture playIcon {
			get {
				if(_playIcon == null) {
					_playIcon = EditorGUIUtility.IconContent("PlayButton").image;
				}
				return _playIcon;
			}
		}
		static Texture _stopIcon;
		static Texture stopIcon {
			get {
				if(_stopIcon == null) {
					_stopIcon = EditorGUIUtility.IconContent("PreMatQuad").image;
				}
				return _stopIcon;
			}
		}
		static Texture _restartIcon;
		static Texture restartIcon {
			get {
				if(_restartIcon == null) {
					_restartIcon = EditorGUIUtility.IconContent("Refresh").image;
				}
				return _restartIcon;
			}
		}
		static Texture _attachedStoryIcon;
		static Texture attachedStoryIcon {
			get {
				if(_attachedStoryIcon == null) {
					_attachedStoryIcon = EditorGUIUtility.IconContent("UnityEditor.FindDependencies").image;
				}
				return _attachedStoryIcon;
			}
		}
		static Texture _saveIcon;
		static Texture saveIcon {
			get {
				if(_saveIcon == null) {
					_saveIcon = EditorGUIUtility.IconContent("SaveAs").image;
				}
				return _saveIcon;
			}
		}
		static Texture _clearIcon;
		static Texture clearIcon {
			get {
				if(_clearIcon == null) {
					_clearIcon = EditorGUIUtility.IconContent("d_Grid.EraserTool").image;
					// d_back
				}
				return _clearIcon;
			}
		}
		static Texture _copyToClipboardIcon;
		static Texture copyToClipboardIcon {
			get {
				if(_copyToClipboardIcon == null) {
					_copyToClipboardIcon = EditorGUIUtility.IconContent("Clipboard").image;
				}
				return _copyToClipboardIcon;
			}
		}
		static Texture _undoIcon;
		static Texture undoIcon {
			get {
				if(_undoIcon == null) {
					_undoIcon = EditorGUIUtility.IconContent("d_back").image;
					// d_back
					// Animation.PrevKey
				}
				return _undoIcon;
			}
		}
		static Texture _redoIcon;
		static Texture redoIcon {
			get {
				if(_redoIcon == null) {
					_redoIcon = EditorGUIUtility.IconContent("d_forward").image;
					// d_forward
					// Animation.NextKey
				}
				return _redoIcon;
			}
		}
		static Texture _warningIcon;
		static Texture warningIcon {
			get {
				if(_warningIcon == null) {
					_warningIcon = EditorGUIUtility.IconContent("console.warnicon.sml").image;
				}
				return _warningIcon;
			}
		}
		static Texture _errorIcon;
		static Texture errorIcon {
			get {
				if(_errorIcon == null) {
					_errorIcon = EditorGUIUtility.IconContent("console.erroricon.sml").image;
				}
				return _errorIcon;
			}
		}
		static Texture _functionIcon;
		static Texture functionIcon {
			get {
				if(_functionIcon == null) {
					_functionIcon = EditorGUIUtility.IconContent("d_StyleSheet Icon").image;
				}
				return _functionIcon;
			}
		}
		static Texture _timeIntervalIcon;
		static Texture timeIntervalIcon {
			get {
				if(_timeIntervalIcon == null) {
					_timeIntervalIcon = EditorGUIUtility.IconContent("UnityEditor.AnimationWindow").image;
				}
				return _timeIntervalIcon;
			}
		}
		static Texture _observeIcon;
		static Texture observeIcon {
			get {
				if(_observeIcon == null) {
					_observeIcon = EditorGUIUtility.IconContent("d_animationvisibilitytoggleon").image;
				}
				return _observeIcon;
			}
		}
		static Texture _unobserveIcon;
		static Texture unobserveIcon {
			get {
				if(_unobserveIcon == null) {
					_unobserveIcon = EditorGUIUtility.IconContent("d_animationvisibilitytoggleoff").image;
				}
				return _unobserveIcon;
			}
		}
	}

	// Keeps a history of state changes for an ink variable. Handy for debugging.
	public class ObservedVariable {
		public string variable;
		public Story.VariableObserver variableObserver;
		public List<ObservedVariableState> values = new List<ObservedVariableState>();
		public bool expanded = true;
		public Vector2 scrollPosition = Vector2.zero;

		public class ObservedVariableState {
			public object state;
			public DateTime dateTime;
			public ObservedVariableState (object state) {
				// Make sure to clone any object ref types! (just InkList at time of writing)
				if(state is InkList) state = new InkList((InkList)state);
				this.state = state;
				dateTime = InkPlayerWindow.dateTimeNow;
			}
		}

		public ObservedVariable (string variable) {
			this.variable = variable;
		}
		public void AddValueState (object value) {
			values.Add(new ObservedVariableState(value));
		}
	}
    

	public class ColoredBackgroundGUIStyle {
		public GUIStyle guiStyle;
		public ColoredBackgroundGUIStyle (Color color) : this (color, color) {}
		public ColoredBackgroundGUIStyle (Color colorFree, Color colorPro) {
			guiStyle = new GUIStyle();

			var texture = new Texture2D( 1, 1 );
			texture.SetPixel(0, 0, EditorGUIUtility.isProSkin ? colorPro : colorFree);
			texture.Apply();
			guiStyle.normal.background = texture;
		}
		public ColoredBackgroundGUIStyle (Color colorFree, Color colorPro, Color hoverColorFree, Color hoverColorPro) {
			guiStyle = new GUIStyle();

			var texture = new Texture2D( 1, 1 );
			texture.SetPixel(0, 0, EditorGUIUtility.isProSkin ? colorPro : colorFree);
			texture.Apply();
			guiStyle.normal.background = texture;

			var hoverTexture = new Texture2D( 1, 1 );
			hoverTexture.SetPixel(0, 0, EditorGUIUtility.isProSkin ? hoverColorPro : hoverColorFree);
			hoverTexture.Apply();
			guiStyle.hover.background = hoverTexture;
		}
	}


	[System.Serializable]
	public class UndoHistory<T> where T : class {
		
		private int _undoHistoryIndex;
		public int undoHistoryIndex {
			get {
				return _undoHistoryIndex;
			} set {
				_undoHistoryIndex = Mathf.Clamp(value, 0, undoHistory.Count-1);
				if(OnChangeHistoryIndex != null) OnChangeHistoryIndex(undoHistory[undoHistoryIndex]);
			}
		}
		
		public List<T> undoHistory;
		public int maxHistoryItems = 100;
		
		public bool canUndo {
			get {
				return undoHistory.Count > 0 && undoHistoryIndex > 0;
			}
		}
		
		public bool canRedo {
			get {
				return undoHistory.Count > 0 && undoHistoryIndex < undoHistory.Count - 1;
			}
		}
		
		public delegate void OnUndoEvent(T historyItem);
		public event OnUndoEvent OnUndo;
		
		public delegate void OnRedoEvent(T historyItem);
		public event OnRedoEvent OnRedo;
		
		public delegate void OnChangeHistoryIndexEvent(T historyItem);
		public event OnChangeHistoryIndexEvent OnChangeHistoryIndex;
		
		public delegate void OnChangeUndoHistoryEvent();
		public event OnChangeUndoHistoryEvent OnChangeUndoHistory;
		
		public UndoHistory () {
			undoHistory = new List<T>();
			_undoHistoryIndex = -1;
		}
		
		public UndoHistory (int maxHistoryItems) : this () {
			this.maxHistoryItems = Mathf.Clamp(maxHistoryItems, 1, int.MaxValue);
		}
		
		public virtual void AddToUndoHistory (T state) {
			if(undoHistory.Count > 0 && undoHistory.Count - (undoHistoryIndex + 1) > 0) {
				undoHistory.RemoveRange(undoHistoryIndex + 1, undoHistory.Count - (undoHistoryIndex + 1));
			}
			
			if(undoHistory.Count >= maxHistoryItems) {
				undoHistory.RemoveAt (0);
				_undoHistoryIndex--;
			}
			
			undoHistory.Add (state);
			_undoHistoryIndex++;
			
			if(OnChangeUndoHistory != null) OnChangeUndoHistory();
		}
		
		public virtual void Clear () {
			undoHistory.Clear();
			_undoHistoryIndex = -1;
			if(OnChangeUndoHistory != null) OnChangeUndoHistory();
		}
		
		public virtual T Undo () {
			if(!canUndo) {
				if(undoHistory.Count > 0)
					return default(T);
			} else {
				undoHistoryIndex--;
				if(OnUndo != null) OnUndo(undoHistory[undoHistoryIndex]);
			}
			return undoHistory[undoHistoryIndex];
		}
		
		public virtual T Redo () {
			if(!canRedo) {
				if(undoHistory.Count > 0)
					return default(T);
			} else {
				undoHistoryIndex++;
				if(OnRedo != null) OnRedo(undoHistory[undoHistoryIndex]);
			}
			return undoHistory[undoHistoryIndex];
		}
		
		protected virtual void ApplyHistoryItem (T historyItem) {}
	}

	public class InkPlayerHistoryItem {
		public string inkStateJSON;
		public List<InkHistoryContentItem> storyHistory;
		
		public InkPlayerHistoryItem (string inkStateJSON, List<InkHistoryContentItem> storyHistory) {
			this.inkStateJSON = inkStateJSON;
			this.storyHistory = storyHistory;
		}
	}
}

--- Путь к файлу: .\Assets\Ink\Editor\Tools\Startup Window\InkUnityIntegrationStartupWindow.cs ---

﻿using System;
using System.IO;
using System.Text.RegularExpressions;
using UnityEditor;
using UnityEngine;

namespace Ink.UnityIntegration {
	[InitializeOnLoad]
	public class InkUnityIntegrationStartupWindow : EditorWindow {
		const string editorPrefsKeyForVersionSeen = "Ink Unity Integration Startup Window Version Confirmed";
		const int announcementVersion = 2;
		
		Vector2 scrollPosition;
		static int announcementVersionPreviouslySeen;
		static string changelogText;

		static InkUnityIntegrationStartupWindow () {
			EditorApplication.delayCall += TryCreateWindow;
		}

		static void TryCreateWindow() {
			if (InkSettings.instance.suppressStartupWindow) return;
			announcementVersionPreviouslySeen = EditorPrefs.GetInt(editorPrefsKeyForVersionSeen, -1);
			if(announcementVersion != announcementVersionPreviouslySeen) {
				ShowWindow();
			}
		}
		
        public static void ShowWindow () {
            InkUnityIntegrationStartupWindow window = GetWindow(typeof(InkUnityIntegrationStartupWindow), true, "Ink Update "+InkLibrary.unityIntegrationVersionCurrent, true) as InkUnityIntegrationStartupWindow;
            window.minSize = new Vector2(200, 200);
            var size = new Vector2(520, 320);
            window.position = new Rect((Screen.currentResolution.width-size.x) * 0.5f, (Screen.currentResolution.height-size.y) * 0.5f, size.x, size.y);
            EditorPrefs.SetInt(editorPrefsKeyForVersionSeen, announcementVersion);
        }

        void OnEnable() {
	        var packageDirectory = InkEditorUtils.FindAbsolutePluginDirectory();
	        changelogText = File.ReadAllText(Path.Combine(packageDirectory, "CHANGELOG.md"));
        }
        
		void OnGUI ()
		{
			EditorGUILayout.BeginVertical();
			var areaSize = new Vector2(90,90);
			GUILayout.BeginArea(new Rect((position.width-areaSize.x)*0.5f, 15, areaSize.x, areaSize.y));
			EditorGUILayout.BeginVertical();
			EditorGUILayout.LabelField(new GUIContent(InkEditorUtils.inkLogoIcon), GUILayout.Width(areaSize.x), GUILayout.Height(areaSize.x*((float)InkEditorUtils.inkLogoIcon.height/InkEditorUtils.inkLogoIcon.width)));
			GUILayout.Space(5);
			EditorGUILayout.LabelField("Version "+InkLibrary.unityIntegrationVersionCurrent, EditorStyles.centeredGreyMiniLabel);
			EditorGUILayout.LabelField("Ink version "+InkLibrary.inkVersionCurrent, EditorStyles.centeredGreyMiniLabel);
			EditorGUILayout.EndVertical();
			GUILayout.EndArea();


			GUILayout.Space(20+areaSize.y);
			
			if(announcementVersionPreviouslySeen == -1) {
				EditorGUILayout.BeginVertical(GUI.skin.box);
				EditorGUILayout.LabelField("New to ink?", EditorStyles.boldLabel);
				EditorGUILayout.EndVertical();
			}

			{
				EditorGUILayout.BeginHorizontal();
			
				if (GUILayout.Button("About Ink")) {
					Application.OpenURL("https://www.inklestudios.com/ink/");
				}
				if (GUILayout.Button("❤️Support Us!❤️")) {
					Application.OpenURL("https://www.patreon.com/inkle");
				}
				if (GUILayout.Button("Discord Community+Support")) {
					Application.OpenURL("https://discord.gg/inkle");
				}
				if (GUILayout.Button("Close")) {
					Close();
				}
				EditorGUILayout.EndHorizontal();
			}

			EditorGUILayout.Space();
			
			if(changelogText != null) {
				scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition);
				
				var versionSections = Regex.Split(changelogText, "## "); // Split markdown text into version sections
				foreach (var section in versionSections) {
					if (string.IsNullOrWhiteSpace(section)) continue;

					var lines = section.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries); // Split each section into lines
					var version = lines[0]; // First line is version

					EditorGUILayout.BeginVertical(GUI.skin.box);
					EditorGUILayout.LabelField($"{version}", EditorStyles.boldLabel);
					for (int i = 1; i < lines.Length; i++) {
						var bulletPoint = lines[i].TrimStart('-').TrimStart(' ');
						EditorGUILayout.LabelField($"• {bulletPoint}", EditorStyles.wordWrappedLabel);
					}

					EditorGUILayout.EndVertical();
				}

				EditorGUILayout.EndScrollView();
			}
			EditorGUILayout.Space();

			EditorGUILayout.EndVertical();
		}
	}
}

--- Путь к файлу: .\Assets\Ink\InkLibs\InkCompiler\CharacterRange.cs ---

using System.Collections.Generic;
using System.Linq;

namespace Ink
{
    /// <summary>
    /// A class representing a character range. Allows for lazy-loading a corresponding <see cref="CharacterSet">character set</see>.
    /// </summary>
    public sealed class CharacterRange
    {
        public static CharacterRange Define(char start, char end, IEnumerable<char> excludes = null)
        {
            return new CharacterRange (start, end, excludes);
        }

        /// <summary>
        /// Returns a <see cref="CharacterSet">character set</see> instance corresponding to the character range
        /// represented by the current instance.
        /// </summary>
        /// <remarks>
        /// The internal character set is created once and cached in memory.
        /// </remarks>
        /// <returns>The char set.</returns>
        public CharacterSet ToCharacterSet ()
        {
            if (_correspondingCharSet.Count == 0) 
            {
                for (char c = _start; c <= _end; c++)
                {
                    if (!_excludes.Contains (c)) 
                    {
                        _correspondingCharSet.Add (c);
                    }
                }
            }
            return _correspondingCharSet;
        }

        public char start { get { return _start; } }
        public char end { get { return _end; } }

        CharacterRange (char start, char end, IEnumerable<char> excludes)
        {
        	_start = start;
        	_end = end;
            _excludes = excludes == null ? new HashSet<char>() : new HashSet<char> (excludes);
        }

        char _start;
        char _end;
        ICollection<char> _excludes;
        CharacterSet _correspondingCharSet = new CharacterSet();
    }    
}


--- Путь к файлу: .\Assets\Ink\InkLibs\InkCompiler\CharacterSet.cs ---

﻿using System.Collections.Generic;

namespace Ink
{

	public class CharacterSet : HashSet<char>
	{
		public static CharacterSet FromRange(char start, char end) 
		{
			return new CharacterSet ().AddRange (start, end);
		}

		public CharacterSet ()
		{
		}

		public CharacterSet(string str)
		{
            AddCharacters (str);
		}

        public CharacterSet(CharacterSet charSetToCopy)
        {
            AddCharacters (charSetToCopy);
        }

		public CharacterSet AddRange(char start, char end)
		{
			for(char c=start; c<=end; ++c) {
				Add (c);
			}
			return this;
		}

		public CharacterSet AddCharacters(IEnumerable<char> chars)
		{
            foreach (char c in chars) {
				Add (c);
			}
			return this;
		}

        public CharacterSet AddCharacters (string chars)
        {
        	foreach (char c in chars) {
        		Add (c);
        	}
        	return this;
        }

	}
}



--- Путь к файлу: .\Assets\Ink\InkLibs\InkCompiler\CommandLineInput.cs ---

﻿namespace Ink
{
    public class CommandLineInput
    {
        public bool isHelp;
        public bool isExit;
        public int? choiceInput;
        public int? debugSource;
        public string debugPathLookup;
        public object userImmediateModeStatement;
    }
}

--- Путь к файлу: .\Assets\Ink\InkLibs\InkCompiler\Compiler.cs ---

﻿using System;
using System.Collections.Generic;
using Ink;

namespace Ink
{
    public class Compiler
    {
        public class Options
        {
            public string sourceFilename;
            public List<string> pluginDirectories;
            public bool countAllVisits;
            public Ink.ErrorHandler errorHandler;
            public Ink.IFileHandler fileHandler;
        }

        public Parsed.Story parsedStory {
            get {
                return _parsedStory;
            }
        }

        public Compiler (string inkSource, Options options = null)
        {
            _inputString = inkSource;
            _options = options ?? new Options();
            if( _options.pluginDirectories != null )
                _pluginManager = new PluginManager (_options.pluginDirectories);
        }

        public Parsed.Story Parse()
        {
            _parser = new InkParser(_inputString, _options.sourceFilename, OnParseError, _options.fileHandler);
            _parsedStory = _parser.Parse();
            return _parsedStory;
        }

        public Runtime.Story Compile ()
        {
            if( _pluginManager != null )
                _inputString = _pluginManager.PreParse(_inputString);

            Parse();

            if( _pluginManager != null )
                _parsedStory = _pluginManager.PostParse(_parsedStory);

            if (_parsedStory != null && !_hadParseError) {

                _parsedStory.countAllVisits = _options.countAllVisits;

                _runtimeStory = _parsedStory.ExportRuntime (_options.errorHandler);

                if( _pluginManager != null )
                    _runtimeStory = _pluginManager.PostExport (_parsedStory, _runtimeStory);
            } else {
                _runtimeStory = null;
            }

            return _runtimeStory;
        }

        public class CommandLineInputResult {
            public bool requestsExit;
            public int choiceIdx = -1;
            public string divertedPath;
            public string output;
        }
        public CommandLineInputResult HandleInput (CommandLineInput inputResult)
        {
            var result = new CommandLineInputResult ();

            // Request for debug source line number
            if (inputResult.debugSource != null) {
                var offset = (int)inputResult.debugSource;
                var dm = DebugMetadataForContentAtOffset (offset);
                if (dm != null)
                    result.output = "DebugSource: " + dm.ToString ();
                else
                    result.output = "DebugSource: Unknown source";
            }

            // Request for runtime path lookup (to line number)
            else if (inputResult.debugPathLookup != null) {
                var pathStr = inputResult.debugPathLookup;
                var contentResult = _runtimeStory.ContentAtPath (new Runtime.Path (pathStr));
                var dm = contentResult.obj.debugMetadata;
                if( dm != null )
                    result.output = "DebugSource: " + dm.ToString ();
                else
                    result.output = "DebugSource: Unknown source";
            }

            // User entered some ink
            else if (inputResult.userImmediateModeStatement != null) {
                var parsedObj = inputResult.userImmediateModeStatement as Parsed.Object;
                return ExecuteImmediateStatement(parsedObj);

            } else {
              return null;
            }

            return result;
        }

        CommandLineInputResult ExecuteImmediateStatement(Parsed.Object parsedObj) {
            var result = new CommandLineInputResult ();

           // Variable assignment: create in Parsed.Story as well as the Runtime.Story
           // so that we don't get an error message during reference resolution
           if (parsedObj is Parsed.VariableAssignment) {
               var varAssign = (Parsed.VariableAssignment)parsedObj;
               if (varAssign.isNewTemporaryDeclaration) {
                   _parsedStory.TryAddNewVariableDeclaration (varAssign);
               }
           }

           parsedObj.parent = _parsedStory;
           var runtimeObj = parsedObj.runtimeObject;

           parsedObj.ResolveReferences (_parsedStory);

           if (!_parsedStory.hadError) {

               // Divert
               if (parsedObj is Parsed.Divert) {
                   var parsedDivert = parsedObj as Parsed.Divert;
                   result.divertedPath = parsedDivert.runtimeDivert.targetPath.ToString();
               }

               // Expression or variable assignment
               else if (parsedObj is Parsed.Expression || parsedObj is Parsed.VariableAssignment) {
                   var evalResult = _runtimeStory.EvaluateExpression ((Runtime.Container)runtimeObj);
                   if (evalResult != null) {
                       result.output = evalResult.ToString ();
                   }
               }
           } else {
               _parsedStory.ResetError ();
           }

          return result;
        }

        public void RetrieveDebugSourceForLatestContent ()
        {
            foreach (var outputObj in _runtimeStory.state.outputStream) {
                var textContent = outputObj as Runtime.StringValue;
                if (textContent != null) {
                    var range = new DebugSourceRange ();
                    range.length = textContent.value.Length;
                    range.debugMetadata = textContent.debugMetadata;
                    range.text = textContent.value;
                    _debugSourceRanges.Add (range);
                }
            }
        }

        Runtime.DebugMetadata DebugMetadataForContentAtOffset (int offset)
        {
            int currOffset = 0;

            Runtime.DebugMetadata lastValidMetadata = null;
            foreach (var range in _debugSourceRanges) {
                if (range.debugMetadata != null)
                    lastValidMetadata = range.debugMetadata;

                if (offset >= currOffset && offset < currOffset + range.length)
                    return lastValidMetadata;

                currOffset += range.length;
            }

            return null;
        }

        public struct DebugSourceRange
        {
            public int length;
            public Runtime.DebugMetadata debugMetadata;
            public string text;
        }

        // Need to wrap the error handler so that we know
        // when there was a critical error between parse and codegen stages
        void OnParseError (string message, ErrorType errorType)
        {
            if( errorType == ErrorType.Error )
                _hadParseError = true;
            
            if (_options.errorHandler != null)
                _options.errorHandler (message, errorType);
            else
                throw new System.Exception(message);
        }

        string _inputString;
        Options _options;


        InkParser _parser;
        Parsed.Story _parsedStory;
        Runtime.Story _runtimeStory;

        PluginManager _pluginManager;

        bool _hadParseError;

        List<DebugSourceRange> _debugSourceRanges = new List<DebugSourceRange> ();
    }
}


--- Путь к файлу: .\Assets\Ink\InkLibs\InkCompiler\FileHandler.cs ---

﻿using System.IO;

namespace Ink
{
    public interface IFileHandler
    {
        string ResolveInkFilename (string includeName);
        string LoadInkFileContents (string fullFilename);
    }

    public class DefaultFileHandler : Ink.IFileHandler {
        public string ResolveInkFilename (string includeName)
        {
            var workingDir = Directory.GetCurrentDirectory ();
            var fullRootInkPath = Path.Combine (workingDir, includeName);
            return fullRootInkPath;
        }

        public string LoadInkFileContents (string fullFilename)
        {
        	return File.ReadAllText (fullFilename);
        }
    }
}


--- Путь к файлу: .\Assets\Ink\InkLibs\InkCompiler\InkStringConversionExtensions.cs ---

﻿using System.Collections.Generic;

namespace Ink
{
    public static class InkStringConversionExtensions
    {
        public static string[] ToStringsArray<T>(this List<T> list) {
            int count = list.Count;
            var strings = new string[count];

            for(int i = 0; i < count; i++) {
                strings[i] = list[i].ToString();
            }

            return strings;
        }
    }
}


--- Путь к файлу: .\Assets\Ink\InkLibs\InkCompiler\Stats.cs ---


namespace Ink {
    public struct Stats {

        public int words;
        public int knots;
        public int stitches;
        public int functions;
        public int choices;
        public int gathers;
        public int diverts;

        public static Stats Generate(Ink.Parsed.Story story) {
            var stats = new Stats();

            var allText = story.FindAll<Ink.Parsed.Text>();

            // Count all the words across all strings
            stats.words = 0;
            foreach(var text in allText) {

                var wordsInThisStr = 0;
                var wasWhiteSpace = true;
                foreach(var c in text.text) {
                    if( c == ' ' || c == '\t' || c == '\n' || c == '\r' ) {
                        wasWhiteSpace = true;
                    } else if( wasWhiteSpace ) {
                        wordsInThisStr++;
                        wasWhiteSpace = false;
                    }
                }

                stats.words += wordsInThisStr;
            }

            var knots = story.FindAll<Ink.Parsed.Knot>();
            stats.knots = knots.Count;

            stats.functions = 0;
            foreach(var knot in knots)
                if (knot.isFunction) stats.functions++;

            var stitches = story.FindAll<Ink.Parsed.Stitch>();
            stats.stitches = stitches.Count;

            var choices = story.FindAll<Ink.Parsed.Choice>();
            stats.choices = choices.Count;

            // Skip implicit gather that's generated at top of story
            // (we know which it is because it isn't assigned debug metadata)
            var gathers = story.FindAll<Ink.Parsed.Gather>(g => g.debugMetadata != null);
            stats.gathers = gathers.Count;

            // May not be entirely what you expect.
            // Does it nevertheless have value?
            // Includes:
            //  - DONE, END
            //  - Function calls
            //  - Some implicitly generated weave diverts
            // But we subtract one for the implicit DONE
            // at the end of the main flow outside of knots.
            var diverts = story.FindAll<Ink.Parsed.Divert>();
            stats.diverts = diverts.Count - 1;

            return stats;
        }
    }
}

--- Путь к файлу: .\Assets\Ink\InkLibs\InkCompiler\InkParser\CommentEliminator.cs ---

﻿
namespace Ink
{
    /// <summary>
    /// Pre-pass before main ink parser runs. It actually performs two main tasks:
    ///  - comment elimination to simplify the parse rules in the main parser
    ///  - Conversion of Windows line endings (\r\n) to the simpler Unix style (\n), so
    ///    we don't have to worry about them later.
    /// </summary>
    public class CommentEliminator : StringParser
    {
        public CommentEliminator (string input) : base(input)
        {
        }

        public string Process()
        {
            // Make both comments and non-comments optional to handle trivial empty file case (or *only* comments)
            var stringList = Interleave<string>(Optional (CommentsAndNewlines), Optional(MainInk));

            if (stringList != null) {
                return string.Join("", stringList.ToArray());
            } else {
                return null;
            }
        }

        string MainInk()
        {
            return ParseUntil (CommentsAndNewlines, _commentOrNewlineStartCharacter, null);
        }

        string CommentsAndNewlines()
        {
            var newlines = Interleave<string> (Optional (ParseNewline), Optional (ParseSingleComment));

            if (newlines != null) {
                return string.Join ("", newlines.ToArray());
            } else {
                return null;
            }
        }

        // Valid comments always return either an empty string or pure newlines,
        // which we want to keep so that line numbers stay the same
        string ParseSingleComment()
        {
            return (string) OneOf (EndOfLineComment, BlockComment);
        }

        string EndOfLineComment()
        {
            if (ParseString ("//") == null) {
                return null;
            }

            ParseUntilCharactersFromCharSet (_newlineCharacters);

            return "";
        }

        string BlockComment()
        {
            if (ParseString ("/*") == null) {
                return null;
            }

            int startLineIndex = lineIndex;

            var commentResult = ParseUntil (String("*/"), _commentBlockEndCharacter, null);

            if (!endOfInput) {
                ParseString ("*/");
            }

            // Count the number of lines that were inside the block, and replicate them as newlines
            // so that the line indexing still works from the original source
            if (commentResult != null) {
                return new string ('\n', lineIndex - startLineIndex);
            } 

            // No comment at all
            else {
                return null;
            }
        }
          
        CharacterSet _commentOrNewlineStartCharacter = new CharacterSet ("/\r\n");
        CharacterSet _commentBlockEndCharacter = new CharacterSet("*");
        CharacterSet _newlineCharacters = new CharacterSet ("\n\r");
    }
}



--- Путь к файлу: .\Assets\Ink\InkLibs\InkCompiler\InkParser\InkParser.cs ---

using System;
using System.Collections.Generic;
using System.IO;

namespace Ink
{
    public partial class InkParser : StringParser
    {
        public InkParser(string str, string filenameForMetadata = null, Ink.ErrorHandler externalErrorHandler = null, IFileHandler fileHandler = null)
            : this(str, filenameForMetadata, externalErrorHandler, null, fileHandler)
        {  }

        InkParser(string str, string inkFilename = null, Ink.ErrorHandler externalErrorHandler = null, InkParser rootParser = null, IFileHandler fileHandler = null) : base(str) {
            _filename = inkFilename;
            RegisterExpressionOperators ();
            GenerateStatementLevelRules ();

            // Built in handler for all standard parse errors and warnings
            this.errorHandler = OnStringParserError;

            // The above parse errors are then formatted as strings and passed
            // to the Ink.ErrorHandler, or it throws an exception
            _externalErrorHandler = externalErrorHandler;

            _fileHandler = fileHandler ?? new DefaultFileHandler();

            if (rootParser == null) {
                _rootParser = this;

                _openFilenames = new HashSet<string> ();

                if (inkFilename != null) {
                    var fullRootInkPath = _fileHandler.ResolveInkFilename (inkFilename);
                    _openFilenames.Add (fullRootInkPath);
                }

            } else {
                _rootParser = rootParser;
            }

        }

        // Main entry point
        public Parsed.Story Parse()
        {
            List<Parsed.Object> topLevelContent = StatementsAtLevel (StatementLevel.Top);

            // Note we used to return null if there were any errors, but this would mean
            // that include files would return completely empty rather than attempting to
            // continue with errors. Returning an empty include files meant that anything
            // that *did* compile successfully would otherwise be ignored, generating way
            // more errors than necessary.
            return new Parsed.Story (topLevelContent, isInclude:_rootParser != this);
        }

        protected List<T> SeparatedList<T> (SpecificParseRule<T> mainRule, ParseRule separatorRule) where T : class
        {
            T firstElement = Parse (mainRule);
            if (firstElement == null) return null;

            var allElements = new List<T> ();
            allElements.Add (firstElement);

            do {

                int nextElementRuleId = BeginRule ();

                var sep = separatorRule ();
                if (sep == null) {
                    FailRule (nextElementRuleId);
                    break;
                }

                var nextElement = Parse (mainRule);
                if (nextElement == null) {
                    FailRule (nextElementRuleId);
                    break;
                }

                SucceedRule (nextElementRuleId);

                allElements.Add (nextElement);

            } while (true);

            return allElements;
        }

        protected override string PreProcessInputString(string str)
        {
            var inputWithCommentsRemoved = (new CommentEliminator (str)).Process();
            return inputWithCommentsRemoved;
        }

        protected Runtime.DebugMetadata CreateDebugMetadata(StringParserState.Element stateAtStart, StringParserState.Element stateAtEnd)
        {
            var md = new Runtime.DebugMetadata ();
            md.startLineNumber = stateAtStart.lineIndex + 1;
            md.endLineNumber = stateAtEnd.lineIndex + 1;
            md.startCharacterNumber = stateAtStart.characterInLineIndex + 1;
            md.endCharacterNumber = stateAtEnd.characterInLineIndex + 1;
            md.fileName = _filename;
            return md;
        }

        protected override void RuleDidSucceed(object result, StringParserState.Element stateAtStart, StringParserState.Element stateAtEnd)
        {
            // Apply DebugMetadata based on the state at the start of the rule
            // (i.e. use line number as it was at the start of the rule)
            var parsedObj = result as Parsed.Object;
            if ( parsedObj) {
                parsedObj.debugMetadata = CreateDebugMetadata(stateAtStart, stateAtEnd);
                return;
            }

            // A list of objects that doesn't already have metadata?
            var parsedListObjs = result as List<Parsed.Object>;
            if (parsedListObjs != null) {
                foreach (var parsedListObj in parsedListObjs) {
                    if (!parsedListObj.hasOwnDebugMetadata) {
                        parsedListObj.debugMetadata = CreateDebugMetadata(stateAtStart, stateAtEnd);
                    }
                }
            }

            var id = result as Parsed.Identifier;
            if (id != null) {
                id.debugMetadata = CreateDebugMetadata(stateAtStart, stateAtEnd);
            }
        }

        protected bool parsingStringExpression
        {
            get {
                return GetFlag ((uint)CustomFlags.ParsingString);
            }
            set {
                SetFlag ((uint)CustomFlags.ParsingString, value);
            }
        }

        protected bool tagActive
        {
            get {
                return GetFlag ((uint)CustomFlags.TagActive);
            }
            set {
                SetFlag ((uint)CustomFlags.TagActive, value);
            }
        }

        protected enum CustomFlags {
            ParsingString = 0x1,
            TagActive = 0x2
        }

        void OnStringParserError(string message, int index, int lineIndex, bool isWarning)
        {
            var warningType = isWarning ? "WARNING:" : "ERROR:";
            string fullMessage;

            if (_filename != null) {
                fullMessage = string.Format(warningType+" '{0}' line {1}: {2}",  _filename, (lineIndex+1), message);
            } else {
                fullMessage = string.Format(warningType+" line {0}: {1}", (lineIndex+1), message);
            }

            if (_externalErrorHandler != null) {
                _externalErrorHandler (fullMessage, isWarning ? ErrorType.Warning : ErrorType.Error);
            } else {
                throw new System.Exception (fullMessage);
            }
        }

        IFileHandler _fileHandler;

        Ink.ErrorHandler _externalErrorHandler;

        string _filename;
    }
}



--- Путь к файлу: .\Assets\Ink\InkLibs\InkCompiler\InkParser\InkParser_AuthorWarning.cs ---

﻿using Ink.Parsed;

namespace Ink
{
    public partial class InkParser
    {
        protected AuthorWarning AuthorWarning()
        {
            Whitespace ();

            var identifier = Parse (IdentifierWithMetadata);
            if (identifier == null || identifier.name != "TODO")
                return null;

            Whitespace ();

            ParseString (":");

            Whitespace ();

            var message = ParseUntilCharactersFromString ("\n\r");

            return new AuthorWarning (message);
        }

    }
}



--- Путь к файлу: .\Assets\Ink\InkLibs\InkCompiler\InkParser\InkParser_CharacterRanges.cs ---

using Ink.Parsed;
using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;

namespace Ink
{
    public partial class InkParser
    {
		public static readonly CharacterRange LatinBasic = 
			CharacterRange.Define ('\u0041', '\u007A', excludes: new CharacterSet().AddRange('\u005B', '\u0060'));
		public static readonly CharacterRange LatinExtendedA = CharacterRange.Define('\u0100', '\u017F'); // no excludes here
		public static readonly CharacterRange LatinExtendedB = CharacterRange.Define('\u0180', '\u024F'); // no excludes here
		public static readonly CharacterRange Greek = 
			CharacterRange.Define('\u0370', '\u03FF', excludes: new CharacterSet().AddRange('\u0378','\u0385').AddCharacters("\u0374\u0375\u0378\u0387\u038B\u038D\u03A2"));
		public static readonly CharacterRange Cyrillic = 
			CharacterRange.Define('\u0400', '\u04FF', excludes: new CharacterSet().AddRange('\u0482', '\u0489'));
		public static readonly CharacterRange Armenian = 
			CharacterRange.Define('\u0530', '\u058F', excludes: new CharacterSet().AddCharacters("\u0530").AddRange('\u0557', '\u0560').AddRange('\u0588', '\u058E'));
		public static readonly CharacterRange Hebrew = 
			CharacterRange.Define('\u0590', '\u05FF', excludes: new CharacterSet());
		public static readonly CharacterRange Arabic = 
			CharacterRange.Define('\u0600', '\u06FF', excludes: new CharacterSet());
		public static readonly CharacterRange Korean =
			CharacterRange.Define('\uAC00', '\uD7AF', excludes: new CharacterSet());
        public static readonly CharacterRange Latin1Supplement =
			CharacterRange.Define('\u0080', '\u00FF', excludes: new CharacterSet());
        public static readonly CharacterRange Chinese =
			CharacterRange.Define('\u4E00', '\u9FFF', excludes: new CharacterSet());

        private void ExtendIdentifierCharacterRanges(CharacterSet identifierCharSet)
        {
            var characterRanges = ListAllCharacterRanges();

            foreach (var charRange in characterRanges)
            {
                identifierCharSet.AddCharacters(charRange.ToCharacterSet());
            }
        }

        /// <summary>
        /// Gets an array of <see cref="CharacterRange" /> representing all of the currently supported
        /// non-ASCII character ranges that can be used in identifier names.
        /// </summary>
        /// <returns>
        /// An array of <see cref="CharacterRange" /> representing all of the currently supported
        /// non-ASCII character ranges that can be used in identifier names.
        /// </returns>
        public static CharacterRange[] ListAllCharacterRanges() {
            return new CharacterRange[] {
                LatinBasic,
                LatinExtendedA,
                LatinExtendedB,
                Arabic,
                Armenian,
                Cyrillic,
                Greek,
                Hebrew,
                Korean,
		Latin1Supplement,
		Chinese,
            };
        }
	}
}



--- Путь к файлу: .\Assets\Ink\InkLibs\InkCompiler\InkParser\InkParser_Choices.cs ---

﻿using Ink.Parsed;
using System.Diagnostics;

namespace Ink
{
	public partial class InkParser
	{
		protected Choice Choice()
		{
            bool onceOnlyChoice = true;
            var bullets = Interleave <string>(OptionalExclude(Whitespace), String("*") );
            if (bullets == null) {

                bullets = Interleave <string>(OptionalExclude(Whitespace), String("+") );
                if (bullets == null) {
                    return null;
                }

                onceOnlyChoice = false;
            }

            // Optional name for the choice
            Identifier optionalName = Parse(BracketedName);

            Whitespace ();

            // Allow optional newline right after a choice name
            if( optionalName != null ) Newline ();

            // Optional condition for whether the choice should be shown to the player
            Expression conditionExpr = Parse(ChoiceCondition);

            Whitespace ();

            // Ordinarily we avoid parser state variables like these, since
            // nesting would require us to store them in a stack. But since you should
            // never be able to nest choices within choice content, it's fine here.
            Debug.Assert(_parsingChoice == false, "Already parsing a choice - shouldn't have nested choices");
            _parsingChoice = true;

            ContentList startContent = null;
            var startTextAndLogic = Parse (MixedTextAndLogic);
            if (startTextAndLogic != null)
                startContent = new ContentList (startTextAndLogic);


            ContentList optionOnlyContent = null;
            ContentList innerContent = null;

            // Check for a the weave style format:
            //   * "Hello[."]," he said.
            bool hasWeaveStyleInlineBrackets = ParseString("[") != null;
            if (hasWeaveStyleInlineBrackets) {

                EndTagIfNecessary(startContent);

                var optionOnlyTextAndLogic = Parse (MixedTextAndLogic);
                if (optionOnlyTextAndLogic != null)
                    optionOnlyContent = new ContentList (optionOnlyTextAndLogic);


                Expect (String("]"), "closing ']' for weave-style option");

                EndTagIfNecessary(optionOnlyContent);

                var innerTextAndLogic = Parse (MixedTextAndLogic);
                if( innerTextAndLogic != null )
                    innerContent = new ContentList (innerTextAndLogic);
            }

			Whitespace ();

            EndTagIfNecessary(innerContent ?? startContent);

            // Finally, now we know we're at the end of the main choice body, parse
            // any diverts separately.
            var diverts =  Parse(MultiDivert);

            _parsingChoice = false;

            Whitespace ();

            // Completely empty choice without even an empty divert?
            bool emptyContent = !startContent && !innerContent && !optionOnlyContent;
            if (emptyContent && diverts == null)
                Warning ("Choice is completely empty. Interpretting as a default fallback choice. Add a divert arrow to remove this warning: * ->");

            // * [] some text
            else if (!startContent && hasWeaveStyleInlineBrackets && !optionOnlyContent)
                Warning ("Blank choice - if you intended a default fallback choice, use the `* ->` syntax");

            if (!innerContent) innerContent = new ContentList ();

            EndTagIfNecessary(innerContent);

            // Normal diverts on the end of a choice - simply add to the normal content
            if (diverts != null) {
                foreach (var divObj in diverts) {
                    // may be TunnelOnwards
                    var div = divObj as Divert;

                    // Empty divert serves no purpose other than to say
                    // "this choice is intentionally left blank"
                    // (as an invisible default choice)
                    if (div && div.isEmpty) continue;

                    innerContent.AddContent (divObj);
                }
            }

            // Terminate main content with a newline since this is the end of the line
            // Note that this will be redundant if the diverts above definitely take
            // the flow away permanently.
            innerContent.AddContent (new Text ("\n"));

            var choice = new Choice (startContent, optionOnlyContent, innerContent);
            choice.identifier = optionalName;
            choice.indentationDepth = bullets.Count;
            choice.hasWeaveStyleInlineBrackets = hasWeaveStyleInlineBrackets;
            choice.condition = conditionExpr;
            choice.onceOnly = onceOnlyChoice;
            choice.isInvisibleDefault = emptyContent;

            return choice;

		}

        protected Expression ChoiceCondition()
        {
            var conditions = Interleave<Expression> (ChoiceSingleCondition, ChoiceConditionsSpace);
            if (conditions == null)
                return null;
            else if (conditions.Count == 1)
                return conditions [0];
            else {
                return new MultipleConditionExpression (conditions);
            }
        }

        protected object ChoiceConditionsSpace()
        {
            // Both optional
            // Newline includes initial end of line whitespace
            Newline ();
            Whitespace ();
            return ParseSuccess;
        }

        protected Expression ChoiceSingleCondition()
        {
            if (ParseString ("{") == null)
                return null;

            var condExpr = Expect(Expression, "choice condition inside { }") as Expression;
            DisallowIncrement (condExpr);

            Expect (String ("}"), "closing '}' for choice condition");

            return condExpr;
        }

        protected Gather Gather()
        {
            object gatherDashCountObj = Parse(GatherDashes);
            if (gatherDashCountObj == null) {
                return null;
            }

            int gatherDashCount = (int)gatherDashCountObj;

            // Optional name for the gather
            Identifier optionalName = Parse(BracketedName);

            var gather = new Gather (optionalName, gatherDashCount);

            // Optional newline before gather's content begins
            Newline ();

            return gather;
        }

        protected object GatherDashes()
        {
            Whitespace ();

            int gatherDashCount = 0;

            while (ParseDashNotArrow () != null) {
                gatherDashCount++;
                Whitespace ();
            }

            if (gatherDashCount == 0)
                return null;

            return gatherDashCount;
        }

        protected object ParseDashNotArrow()
        {
            var ruleId = BeginRule ();

            if (ParseString ("->") == null && ParseSingleCharacter () == '-') {
                return SucceedRule (ruleId);
            } else {
                return FailRule (ruleId);
            }
        }

        protected Identifier BracketedName()
        {
            if (ParseString ("(") == null)
                return null;

            Whitespace ();

            Identifier name = Parse(IdentifierWithMetadata);
            if (name == null)
                return null;

            Whitespace ();

            Expect (String (")"), "closing ')' for bracketed name");

            return name;
        }

        bool _parsingChoice;
	}
}



--- Путь к файлу: .\Assets\Ink\InkLibs\InkCompiler\InkParser\InkParser_CommandLineInput.cs ---


namespace Ink
{
    public partial class InkParser
    {
        // Valid returned objects:
        //  - "help"
        //  - int: for choice number
        //  - Parsed.Divert
        //  - Variable declaration/assignment
        //  - Epression
        //  - Lookup debug source for character offset
        //  - Lookup debug source for runtime path
        public CommandLineInput CommandLineUserInput()
        {
            CommandLineInput result = new CommandLineInput ();

            Whitespace ();

            if (ParseString ("help") != null) {
                result.isHelp = true;
                return result;
            }

            if (ParseString ("exit") != null || ParseString ("quit") != null) {
                result.isExit = true;
                return result;
            }

            return (CommandLineInput) OneOf (
                DebugSource,
                DebugPathLookup,
                UserChoiceNumber, 
                UserImmediateModeStatement
            );
        }

        CommandLineInput DebugSource ()
        {
            Whitespace ();

            if (ParseString ("DebugSource") == null)
                return null;

            Whitespace ();

            var expectMsg = "character offset in parentheses, e.g. DebugSource(5)";
            if (Expect (String ("("), expectMsg) == null)
                return null;

            Whitespace ();

            int? characterOffset = ParseInt ();
            if (characterOffset == null) {
                Error (expectMsg);
                return null;
            }

            Whitespace ();

            Expect (String (")"), "closing parenthesis");

            var inputStruct = new CommandLineInput ();
            inputStruct.debugSource = characterOffset;
            return inputStruct;
        }

        CommandLineInput DebugPathLookup ()
        {
            Whitespace ();

            if (ParseString ("DebugPath") == null)
                return null;

            if (Whitespace () == null)
                return null;

            var pathStr = Expect (RuntimePath, "path") as string;

            var inputStruct = new CommandLineInput ();
            inputStruct.debugPathLookup = pathStr;
            return inputStruct;
        }

        string RuntimePath ()
        {
            if (_runtimePathCharacterSet == null) {
                _runtimePathCharacterSet = new CharacterSet (identifierCharSet);
                _runtimePathCharacterSet.Add ('-'); // for c-0, g-0 etc
                _runtimePathCharacterSet.Add ('.');

            }
            
            return ParseCharactersFromCharSet (_runtimePathCharacterSet);
        }

        CommandLineInput UserChoiceNumber()
        {
            Whitespace ();

            int? number = ParseInt ();
            if (number == null) {
                return null;
            }

            Whitespace ();

            if (Parse(EndOfLine) == null) {
                return null;
            }

            var inputStruct = new CommandLineInput ();
            inputStruct.choiceInput = number;
            return inputStruct;
        }

        CommandLineInput UserImmediateModeStatement()
        {
            var statement = OneOf (SingleDivert, TempDeclarationOrAssignment, Expression);

            var inputStruct = new CommandLineInput ();
            inputStruct.userImmediateModeStatement = statement;
            return inputStruct;
        }

        CharacterSet _runtimePathCharacterSet;
    }
}



--- Путь к файлу: .\Assets\Ink\InkLibs\InkCompiler\InkParser\InkParser_Conditional.cs ---

using System.Collections.Generic;
using System.Linq;
using Ink.Parsed;

namespace Ink
{
    public partial class InkParser
    {
        protected Conditional InnerConditionalContent()
        {
            var initialQueryExpression = Parse(ConditionExpression);
            var conditional = Parse(() => InnerConditionalContent (initialQueryExpression));
            if (conditional == null)
                return null;

            return conditional;
        }

        protected Conditional InnerConditionalContent(Expression initialQueryExpression)
        {
            List<ConditionalSingleBranch> alternatives;

            bool canBeInline = initialQueryExpression != null;
            bool isInline = Parse(Newline) == null;

            if (isInline && !canBeInline) {
                return null;
            }

            // Inline innards
            if (isInline) {
                alternatives = InlineConditionalBranches ();
            } 

            // Multiline innards
            else {
                alternatives = MultilineConditionalBranches ();
                if (alternatives == null) {

                    // Allow single piece of content within multi-line expression, e.g.:
                    // { true: 
                    //    Some content that isn't preceded by '-'
                    // }
                    if (initialQueryExpression) {
                        List<Parsed.Object> soleContent = StatementsAtLevel (StatementLevel.InnerBlock);
                        if (soleContent != null) {
                            var soleBranch = new ConditionalSingleBranch (soleContent);
                            alternatives = new List<ConditionalSingleBranch> ();
                            alternatives.Add (soleBranch);

                            // Also allow a final "- else:" clause
                            var elseBranch = Parse (SingleMultilineCondition);
                            if (elseBranch) {
                                if (!elseBranch.isElse) {
                                    ErrorWithParsedObject ("Expected an '- else:' clause here rather than an extra condition", elseBranch);
                                    elseBranch.isElse = true;
                                }
                                alternatives.Add (elseBranch);
                            }
                        }
                    }

                    // Still null?
                    if (alternatives == null) {
                        return null;
                    }
                } 

                // Empty true branch - didn't get parsed, but should insert one for semantic correctness,
                // and to make sure that any evaluation stack values get tidied up correctly.
                else if (alternatives.Count == 1 && alternatives [0].isElse && initialQueryExpression) {
                    var emptyTrueBranch = new ConditionalSingleBranch (null);
                    emptyTrueBranch.isTrueBranch = true;
                    alternatives.Insert (0, emptyTrueBranch);
                }

                // Like a switch statement
                // { initialQueryExpression:
                //    ... match the expression
                // }
                if (initialQueryExpression) {

                    bool earlierBranchesHaveOwnExpression = false;
                    for (int i = 0; i < alternatives.Count; ++i) {
                        var branch = alternatives [i];
                        bool isLast = (i == alternatives.Count - 1);

                        // Matching equality with initial query expression
                        // We set this flag even for the "else" clause so that
                        // it knows to tidy up the evaluation stack at the end

                        // Match query
                        if (branch.ownExpression) {
                            branch.matchingEquality = true;
                            earlierBranchesHaveOwnExpression = true;
                        }

                        // Else (final branch)
                        else if (earlierBranchesHaveOwnExpression && isLast) {
                            branch.matchingEquality = true;
                            branch.isElse = true;
                        } 

                        // Binary condition:
                        // { trueOrFalse:
                        //    - when true
                        //    - when false
                        // }
                        else {

                            if (!isLast && alternatives.Count > 2) {
                                ErrorWithParsedObject ("Only final branch can be an 'else'. Did you miss a ':'?", branch);
                            } else {
                                if (i == 0)
                                    branch.isTrueBranch = true;
                                else
                                    branch.isElse = true;
                            }
                        }
                    }
                } 

                // No initial query, so just a multi-line conditional. e.g.:
                // {
                //   - x > 3:  greater than three
                //   - x == 3: equal to three
                //   - x < 3:  less than three
                // }
                else {
                    
                    for (int i = 0; i < alternatives.Count; ++i) {
                        var alt = alternatives [i];
                        bool isLast = (i == alternatives.Count - 1);
                        if (alt.ownExpression == null) {
                            if (isLast) {
                                alt.isElse = true;
                            } else {
                                if (alt.isElse) {
                                    // Do we ALSO have a valid "else" at the end? Let's report the error there.
                                    var finalClause = alternatives [alternatives.Count - 1];
                                    if (finalClause.isElse) {
                                        ErrorWithParsedObject ("Multiple 'else' cases. Can have a maximum of one, at the end.", finalClause);
                                    } else {
                                        ErrorWithParsedObject ("'else' case in conditional should always be the final one", alt);
                                    }
                                } else {
                                    ErrorWithParsedObject ("Branch doesn't have condition. Are you missing a ':'? ", alt);
                                }

                            }
                        }
                    }
                        
                    if (alternatives.Count == 1 && alternatives [0].ownExpression == null) {
                        ErrorWithParsedObject ("Condition block with no conditions", alternatives [0]);
                    }
                }
            }

            // TODO: Come up with water-tight error conditions... it's quite a flexible system!
            // e.g.
            //   - inline conditionals must have exactly 1 or 2 alternatives
            //   - multiline expression shouldn't have mixed existence of branch-conditions?
            if (alternatives == null)
                return null;

            foreach (var branch in alternatives) {
                branch.isInline = isInline;
            }

            var cond = new Conditional (initialQueryExpression, alternatives);
            return cond;
        }

        protected List<ConditionalSingleBranch> InlineConditionalBranches()
        {
            var listOfLists = Interleave<List<Parsed.Object>> (MixedTextAndLogic, Exclude (String ("|")), flatten: false);
            if (listOfLists == null || listOfLists.Count == 0) {
                return null;
            }

            var result = new List<ConditionalSingleBranch> ();

            if (listOfLists.Count > 2) {
                Error ("Expected one or two alternatives separated by '|' in inline conditional");
            } else {
                
                var trueBranch = new ConditionalSingleBranch (listOfLists[0]);
                trueBranch.isTrueBranch = true;
                result.Add (trueBranch);

                if (listOfLists.Count > 1) {
                    var elseBranch = new ConditionalSingleBranch (listOfLists[1]);
                    elseBranch.isElse = true;
                    result.Add (elseBranch);
                }
            }

            return result;
        }

        protected List<ConditionalSingleBranch> MultilineConditionalBranches()
        {
            MultilineWhitespace ();

            List<object> multipleConditions = OneOrMore (SingleMultilineCondition);
            if (multipleConditions == null)
                return null;
            
            MultilineWhitespace ();

            return multipleConditions.Cast<ConditionalSingleBranch>().ToList();
        }

        protected ConditionalSingleBranch SingleMultilineCondition()
        {
            Whitespace ();

            // Make sure we're not accidentally parsing a divert
            if (ParseString ("->") != null)
                return null;

            if (ParseString ("-") == null)
                return null;

            Whitespace ();

            Expression expr = null;
            bool isElse = Parse(ElseExpression) != null;

            if( !isElse )
                expr = Parse(ConditionExpression);

            List<Parsed.Object> content = StatementsAtLevel (StatementLevel.InnerBlock);
            if (expr == null && content == null) {
                Error ("expected content for the conditional branch following '-'");

                // Recover
                content = new List<Ink.Parsed.Object> ();
                content.Add (new Text (""));
            }

            // Allow additional multiline whitespace, if the statements were empty (valid)
            // then their surrounding multiline whitespacce needs to be handled manually.
            // e.g.
            // { x:
            //   - 1:    // intentionally left blank, but newline needs to be parsed
            //   - 2: etc
            // }
            MultilineWhitespace ();

            var branch = new ConditionalSingleBranch (content);
            branch.ownExpression = expr;
            branch.isElse = isElse;
            return branch;
        }

        protected Expression ConditionExpression()
        {
            var expr = Parse(Expression);
            if (expr == null)
                return null;

            DisallowIncrement (expr);

            Whitespace ();

            if (ParseString (":") == null)
                return null;

            return expr;
        }

        protected object ElseExpression()
        {
            if (ParseString ("else") == null)
                return null;

            Whitespace ();

            if (ParseString (":") == null)
                return null;

            return ParseSuccess;
        }
    }
}



--- Путь к файлу: .\Assets\Ink\InkLibs\InkCompiler\InkParser\InkParser_Content.cs ---

﻿using Ink.Parsed;
using System.Text;
using System.Collections.Generic;
using System.Linq;

namespace Ink
{
    public partial class InkParser
    {
        void TrimEndWhitespace(List<Parsed.Object> mixedTextAndLogicResults, bool terminateWithSpace)
        {
            // Trim whitespace from end
            if (mixedTextAndLogicResults.Count > 0) {
                var lastObjIdx = mixedTextAndLogicResults.Count - 1;
                var lastObj = mixedTextAndLogicResults[lastObjIdx];
                if (lastObj is Text) {
                    var text = (Text)lastObj;
                    text.text = text.text.TrimEnd (' ', '\t');

                    if (terminateWithSpace)
                        text.text += " ";

                    // No content left at all? trim the whole object
                    else if( text.text.Length == 0 ) {
                        mixedTextAndLogicResults.RemoveAt(lastObjIdx);

                        // Recurse in case there's more whitespace
                        TrimEndWhitespace(mixedTextAndLogicResults, terminateWithSpace:false);
                    }
                }
            }
        }

        protected List<Parsed.Object> LineOfMixedTextAndLogic()
        {
            // Consume any whitespace at the start of the line
            // (Except for escaped whitespace)
            Parse (Whitespace);

            var result = Parse(MixedTextAndLogic);
            if (result == null || result.Count == 0)
                return null;

            // Warn about accidentally writing "return" without "~"
            var firstText = result[0] as Text;
            if (firstText) {
                if (firstText.text.StartsWith ("return")) {
                    Warning ("Do you need a '~' before 'return'? If not, perhaps use a glue: <> (since it's lowercase) or rewrite somehow?");
                }
            }
            if (result.Count == 0)
                return null;

            var lastObj = result [result.Count - 1];
            if (!(lastObj is Divert)) {
                TrimEndWhitespace (result, terminateWithSpace:false);
            }

            EndTagIfNecessary(result);

            // If the line doens't actually contain any normal text content
            // but is in fact entirely a tag, then let's not append
            // a newline, since we want the tag (or tags) to be associated
            // with the line below rather than being completely independent.
            bool lineIsPureTag = result.Count > 0 && result[0] is Parsed.Tag && ((Parsed.Tag)result[0]).isStart;
            if( !lineIsPureTag )
                result.Add (new Text ("\n"));

            Expect(EndOfLine, "end of line", recoveryRule: SkipToNextLine);

            return result;
        }

        protected List<Parsed.Object> MixedTextAndLogic()
        {
            // Check for disallowed "~" within this context
            var disallowedTilda = ParseObject(Spaced(String("~")));
            if (disallowedTilda != null)
                Error ("You shouldn't use a '~' here - tildas are for logic that's on its own line. To do inline logic, use { curly braces } instead");

            // Either, or both interleaved
            var results = Interleave<Parsed.Object>(Optional (ContentText), Optional (InlineLogicOrGlueOrStartTag));

            // Terminating divert?
            // (When parsing content for the text of a choice, diverts aren't allowed.
            //  The divert on the end of the body of a choice is handled specially.)
            if (!_parsingChoice) {

                var diverts = Parse (MultiDivert);
                if (diverts != null) {

                    // May not have had any results at all if there's *only* a divert!
                    if (results == null)
                        results = new List<Parsed.Object> ();

                    // End previously active tag if necessary
                    EndTagIfNecessary(results);

                    TrimEndWhitespace (results, terminateWithSpace:true);

                    results.AddRange (diverts);
                }

            }
                
            if (results == null)
                return null;

            return results;
        }

        protected Parsed.Text ContentText()
        {
            return ContentTextAllowingEcapeChar ();
        }

        protected Parsed.Text ContentTextAllowingEcapeChar()
        {
            StringBuilder sb = null;

            do {
                var str = Parse(ContentTextNoEscape);
                bool gotEscapeChar = ParseString(@"\") != null;

                if( gotEscapeChar || str != null ) {
                    if( sb == null ) {
                        sb = new StringBuilder();
                    }

                    if( str != null ) {
                        sb.Append(str);
                    }

                    if( gotEscapeChar ) {
                        char c = ParseSingleCharacter();
                        sb.Append(c);
                    }

                } else {
                    break;
                }

            } while(true);

            if (sb != null ) {
                return new Parsed.Text (sb.ToString ());

            } else {
                return null;
            }
        }

        // Content text is an unusual parse rule compared with most since it's
        // less about saying "this is is the small selection of stuff that we parse"
        // and more "we parse ANYTHING except this small selection of stuff".
        protected string ContentTextNoEscape()
        {
            // Eat through text, pausing at the following characters, and
            // attempt to parse the nonTextRule.
            // "-": possible start of divert or start of gather
            // "<": possible start of glue
            if (_nonTextPauseCharacters == null) {
                _nonTextPauseCharacters = new CharacterSet ("-<");
            }

            // If we hit any of these characters, we stop *immediately* without bothering to even check the nonTextRule
            // "{" for start of logic
            // "|" for mid logic branch
            if (_nonTextEndCharacters == null) {
                _nonTextEndCharacters = new CharacterSet ("{}|\n\r\\#");
                _notTextEndCharactersChoice = new CharacterSet (_nonTextEndCharacters);
                _notTextEndCharactersChoice.AddCharacters ("[]");
                _notTextEndCharactersString = new CharacterSet (_nonTextEndCharacters);
                _notTextEndCharactersString.AddCharacters ("\"");
            }

            // When the ParseUntil pauses, check these rules in case they evaluate successfully
            ParseRule nonTextRule = () => OneOf (ParseDivertArrow, ParseThreadArrow, EndOfLine, Glue);

            CharacterSet endChars = null;
            if (parsingStringExpression) {
                endChars = _notTextEndCharactersString;
            } 
            else if (_parsingChoice) {
                endChars = _notTextEndCharactersChoice;
            } 
            else {
                endChars = _nonTextEndCharacters;
            }

            string pureTextContent = ParseUntil (nonTextRule, _nonTextPauseCharacters, endChars);
            if (pureTextContent != null ) {
                return pureTextContent;

            } else {
                return null;
            }

        }

        CharacterSet _nonTextPauseCharacters;
        CharacterSet _nonTextEndCharacters;
        CharacterSet _notTextEndCharactersChoice;
        CharacterSet _notTextEndCharactersString;



    }
}



--- Путь к файлу: .\Assets\Ink\InkLibs\InkCompiler\InkParser\InkParser_Divert.cs ---

﻿using System.Collections.Generic;
using Ink.Parsed;


namespace Ink
{
    public partial class InkParser
    {
        protected List<Parsed.Object> MultiDivert()
        {
            Whitespace ();

            List<Parsed.Object> diverts = null;

            // Try single thread first
            var threadDivert = Parse(StartThread);
            if (threadDivert) {
                diverts = new List<Object> ();
                diverts.Add (threadDivert);
                return diverts;
            }

            // Normal diverts and tunnels
            var arrowsAndDiverts = Interleave<object> (
                ParseDivertArrowOrTunnelOnwards,
                DivertIdentifierWithArguments);

            if (arrowsAndDiverts == null)
                return null;

            diverts = new List<Parsed.Object> ();

            EndTagIfNecessary(diverts);

            // Possible patterns:
            //  ->                   -- explicit gather
            //  ->->                 -- tunnel onwards
            //  -> div               -- normal divert
            //  ->-> div             -- tunnel onwards, followed by override divert
            //  -> div ->            -- normal tunnel
            //  -> div ->->          -- tunnel then tunnel continue
            //  -> div -> div        -- tunnel then divert
            //  -> div -> div ->     -- tunnel then tunnel
            //  -> div -> div ->->
            //  -> div -> div ->-> div    (etc)

            // Look at the arrows and diverts
            for (int i = 0; i < arrowsAndDiverts.Count; ++i) {
                bool isArrow = (i % 2) == 0;

                // Arrow string
                if (isArrow) {

                    // Tunnel onwards
                    if ((string)arrowsAndDiverts [i] == "->->") {

                        bool tunnelOnwardsPlacementValid = (i == 0 || i == arrowsAndDiverts.Count - 1 || i == arrowsAndDiverts.Count - 2);
                        if (!tunnelOnwardsPlacementValid)
                            Error ("Tunnel onwards '->->' must only come at the begining or the start of a divert");

                        var tunnelOnwards = new TunnelOnwards ();
                        if (i < arrowsAndDiverts.Count - 1) {
                            var tunnelOnwardDivert = arrowsAndDiverts [i+1] as Parsed.Divert;
                            tunnelOnwards.divertAfter = tunnelOnwardDivert;
                        }

                        diverts.Add (tunnelOnwards);

                        // Not allowed to do anything after a tunnel onwards.
                        // If we had anything left it would be caused in the above Error for
                        // the positioning of a ->->
                        break;
                    }
                }

                // Divert
                else {

                    var divert = arrowsAndDiverts [i] as Divert;

                    // More to come? (further arrows) Must be tunnelling.
                    if (i < arrowsAndDiverts.Count - 1) {
                        divert.isTunnel = true;
                    }

                    diverts.Add (divert);
                }
            }

            // Single -> (used for default choices)
            if (diverts.Count == 0 && arrowsAndDiverts.Count == 1) {
                var gatherDivert = new Divert ((Parsed.Object)null);
                gatherDivert.isEmpty = true;
                diverts.Add (gatherDivert);

                if (!_parsingChoice)
                    Error ("Empty diverts (->) are only valid on choices");
            }

            return diverts;
        }

        protected Divert StartThread()
        {
            Whitespace ();

            if (ParseThreadArrow() == null)
                return null;

            Whitespace ();

            var divert = Expect(DivertIdentifierWithArguments, "target for new thread", () => new Divert(null)) as Divert;
            divert.isThread = true;

            return divert;
        }

        protected Divert DivertIdentifierWithArguments()
        {
            Whitespace ();

            List<Identifier> targetComponents = Parse (DotSeparatedDivertPathComponents);
            if (targetComponents == null)
                return null;

            Whitespace ();

            var optionalArguments = Parse(ExpressionFunctionCallArguments);

            Whitespace ();

            var targetPath = new Path (targetComponents);
            return new Divert (targetPath, optionalArguments);
        }

        protected Divert SingleDivert()
        {
            var diverts = Parse (MultiDivert);
            if (diverts == null)
                return null;

            // Ideally we'd report errors if we get the
            // wrong kind of divert, but unfortunately we
            // have to hack around the fact that sequences use
            // a very similar syntax.
            // i.e. if you have a multi-divert at the start
            // of a sequence, it initially tries to parse it
            // as a divert target (part of an expression of
            // a conditional) and gives errors. So instead
            // we just have to blindly reject it as a single
            // divert, and give a slightly less nice error
            // when you DO use a multi divert as a divert taret.

            if (diverts.Count != 1) {
                return null;
            }

            var singleDivert = diverts [0];
            if (singleDivert is TunnelOnwards) {
                return null;
            }

            var divert = diverts [0] as Divert;
            if (divert.isTunnel) {
                return null;
            }

            return divert;
        }

        List<Identifier> DotSeparatedDivertPathComponents()
        {
            return Interleave<Identifier> (Spaced (IdentifierWithMetadata), Exclude (String (".")));
        }

        protected string ParseDivertArrowOrTunnelOnwards()
        {
            int numArrows = 0;
            while (ParseString ("->") != null)
                numArrows++;

            if (numArrows == 0)
                return null;

            else if (numArrows == 1)
                return "->";

            else if (numArrows == 2)
                return "->->";

            else {
                Error ("Unexpected number of arrows in divert. Should only have '->' or '->->'");
                return "->->";
            }
        }

        protected string ParseDivertArrow()
        {
            return ParseString ("->");
        }

        protected string ParseThreadArrow()
        {
            return ParseString ("<-");
        }
    }
}



--- Путь к файлу: .\Assets\Ink\InkLibs\InkCompiler\InkParser\InkParser_Expressions.cs ---

﻿using System;
using Ink.Parsed;
using System.Collections.Generic;

namespace Ink
{
	public partial class InkParser
	{
		protected class InfixOperator
		{
			public string type;
			public int precedence;
            public bool requireWhitespace;

            public InfixOperator(string type, int precedence, bool requireWhitespace) {
				this.type = type;
				this.precedence = precedence;
                this.requireWhitespace = requireWhitespace;
			}

			public override string ToString ()
			{
				return type;
			}
		}

        protected Parsed.Object TempDeclarationOrAssignment()
        {
            Whitespace ();

            bool isNewDeclaration = ParseTempKeyword();

            Whitespace ();

            Identifier varIdentifier = null;
            if (isNewDeclaration) {
                varIdentifier = (Identifier)Expect (IdentifierWithMetadata, "variable name");
            } else {
                varIdentifier = Parse(IdentifierWithMetadata);
            }

            if (varIdentifier == null) {
                return null;
            }

            Whitespace();

            // += -=
            bool isIncrement = ParseString ("+") != null;
            bool isDecrement = ParseString ("-") != null;
            if (isIncrement && isDecrement) Error ("Unexpected sequence '+-'");

            if (ParseString ("=") == null) {
                // Definitely in an assignment expression?
                if (isNewDeclaration) Error ("Expected '='");
                return null;
            }

            Expression assignedExpression = (Expression)Expect (Expression, "value expression to be assigned");

            if (isIncrement || isDecrement) {
                var result = new IncDecExpression (varIdentifier, assignedExpression, isIncrement);
                return result;
            } else {
                var result = new VariableAssignment (varIdentifier, assignedExpression);
                result.isNewTemporaryDeclaration = isNewDeclaration;
                return result;
            }
        }

        protected void DisallowIncrement (Parsed.Object expr)
        {
        	if (expr is Parsed.IncDecExpression)
        		Error ("Can't use increment/decrement here. It can only be used on a ~ line");
        }

        protected bool ParseTempKeyword()
        {
            var ruleId = BeginRule ();

            if (Parse (Identifier) == "temp") {
                SucceedRule (ruleId);
                return true;
            } else {
                FailRule (ruleId);
                return false;
            }
        }

        protected Parsed.Return ReturnStatement()
        {
            Whitespace ();

            var returnOrDone = Parse(Identifier);
            if (returnOrDone != "return") {
                return null;
            }

            Whitespace ();

            var expr = Parse(Expression);

            var returnObj = new Return (expr);
            return returnObj;
        }

		protected Expression Expression() {
			return Expression(minimumPrecedence:0);
		}

		// Pratt Parser
		// aka "Top down operator precedence parser"
		// http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/
		// Algorithm overview:
		// The two types of precedence are handled in two different ways:
		//   ((((a . b) . c) . d) . e)			#1
		//   (a . (b . (c . (d . e))))			#2
		// Where #1 is automatically handled by successive loops within the main 'while' in this function,
		// so long as continuing operators have lower (or equal) precedence (e.g. imagine some series of "*"s then "+" above.
		// ...and #2 is handled by recursion of the right hand term in the binary expression parser.
		// (see link for advice on how to extend for postfix and mixfix operators)
		protected Expression Expression(int minimumPrecedence)
		{
			Whitespace ();

			// First parse a unary expression e.g. "-a" or parethensised "(1 + 2)"
			var expr = ExpressionUnary ();
			if (expr == null) {
                return null;
			}

			Whitespace ();

			// Attempt to parse (possibly multiple) continuing infix expressions (e.g. 1 + 2 + 3)
			while(true) {
				var ruleId = BeginRule ();

				// Operator
				var infixOp = ParseInfixOperator ();
				if (infixOp != null && infixOp.precedence > minimumPrecedence) {

					// Expect right hand side of operator
					var expectationMessage = string.Format("right side of '{0}' expression", infixOp.type);
					var multiaryExpr = Expect (() => ExpressionInfixRight (left: expr, op: infixOp), expectationMessage);
                    if (multiaryExpr == null) {

                        // Fail for operator and right-hand side of multiary expression
                        FailRule (ruleId);

                        return null;
                    }

                    expr = SucceedRule(ruleId, multiaryExpr) as Parsed.Expression;

					continue;
				}

                FailRule (ruleId);
				break;
			}

            Whitespace ();

            return expr;
		}

        protected Expression ExpressionUnary()
		{
            // Divert target is a special case - it can't have any other operators
            // applied to it, and we also want to check for it first so that we don't
            // confuse "->" for subtraction.
            var divertTarget = Parse (ExpressionDivertTarget);
            if (divertTarget != null) {
                return divertTarget;
            }

            var prefixOp = (string) OneOf (String ("-"), String ("!"));

            // Don't parse like the string rules above, in case its actually
            // a variable that simply starts with "not", e.g. "notable".
            // This rule uses the Identifier rule, which will scan as much text
            // as possible before returning.
            if (prefixOp == null) {
                prefixOp = Parse(ExpressionNot);
            }

			Whitespace ();

            // - Since we allow numbers at the start of variable names, variable names are checked before literals
            // - Function calls before variable names in case we see parentheses
            var expr = OneOf (ExpressionList, ExpressionParen, ExpressionFunctionCall, ExpressionVariableName, ExpressionLiteral) as Expression;

            // Only recurse immediately if we have one of the (usually optional) unary ops
            if (expr == null && prefixOp != null) {
                expr = ExpressionUnary ();
            }

			if (expr == null)
                return null;

            if (prefixOp != null) {
                expr = UnaryExpression.WithInner(expr, prefixOp);
			}

            Whitespace ();

            var postfixOp = (string) OneOf (String ("++"), String ("--"));
            if (postfixOp != null) {
                bool isInc = postfixOp == "++";

                if (!(expr is VariableReference)) {
                    Error ("can only increment and decrement variables, but saw '" + expr + "'");

                    // Drop down and succeed without the increment after reporting error
                } else {
                    // TODO: Language Server - (Identifier combined into one vs. list of Identifiers)
                    var varRef = (VariableReference)expr;
                    expr = new IncDecExpression(varRef.identifier, isInc);
                }

            }

            return expr;
		}

        protected string ExpressionNot()
        {
            var id = Identifier ();
            if (id == "not") {
                return id;
            }

            return null;
        }

		protected Expression ExpressionLiteral()
		{
            return (Expression) OneOf (ExpressionFloat, ExpressionInt, ExpressionBool, ExpressionString);
		}

        protected Expression ExpressionDivertTarget()
        {
            Whitespace ();

            var divert = Parse(SingleDivert);
            if (divert == null)
                return null;

            if (divert.isThread)
                return null;

            Whitespace ();

            return new DivertTarget (divert);
        }

        protected Number ExpressionInt()
        {
            int? intOrNull = ParseInt ();
            if (intOrNull == null) {
                return null;
            } else {
                return new Number (intOrNull.Value);
            }
        }

        protected Number ExpressionFloat()
        {
            float? floatOrNull = ParseFloat ();
            if (floatOrNull == null) {
                return null;
            } else {
                return new Number (floatOrNull.Value);
            }
        }

        protected StringExpression ExpressionString()
        {
            var openQuote = ParseString ("\"");
            if (openQuote == null)
                return null;

            // Set custom parser state flag so that within the text parser,
            // it knows to treat the quote character (") as an end character
            parsingStringExpression = true;

            List<Parsed.Object> textAndLogic = Parse (MixedTextAndLogic);

            Expect (String ("\""), "close quote for string expression");

            parsingStringExpression = false;

            if (textAndLogic == null) {
                textAndLogic = new List<Ink.Parsed.Object> ();
                textAndLogic.Add (new Parsed.Text (""));
            }

            else if (textAndLogic.Exists (c => c is Divert))
                Error ("String expressions cannot contain diverts (->)");

            return new StringExpression (textAndLogic);
        }

        protected Number ExpressionBool()
        {
            var id = Parse(Identifier);
            if (id == "true") {
                return new Number (true);
            } else if (id == "false") {
                return new Number (false);
            }

            return null;
        }

        protected Expression ExpressionFunctionCall()
        {
            var iden = Parse(IdentifierWithMetadata);
            if (iden == null)
                return null;

            Whitespace ();

            var arguments = Parse(ExpressionFunctionCallArguments);
            if (arguments == null) {
                return null;
            }

            return new FunctionCall(iden, arguments);
        }

        protected List<Expression> ExpressionFunctionCallArguments()
        {
            if (ParseString ("(") == null)
                return null;

            // "Exclude" requires the rule to succeed, but causes actual comma string to be excluded from the list of results
            ParseRule commas = Exclude (String (","));
            var arguments = Interleave<Expression>(Expression, commas);
            if (arguments == null) {
                arguments = new List<Expression> ();
            }

            Whitespace ();

            Expect (String (")"), "closing ')' for function call");

            return arguments;
        }

        protected Expression ExpressionVariableName()
        {
            List<Identifier> path = Interleave<Identifier> (IdentifierWithMetadata, Exclude (Spaced (String ("."))));

            if (path == null || Story.IsReservedKeyword (path[0].name) )
                return null;

            return new VariableReference (path);
        }

		protected Expression ExpressionParen()
		{
			if (ParseString ("(") == null)
                return null;

            var innerExpr = Parse(Expression);
			if (innerExpr == null)
                return null;

			Whitespace ();

            Expect (String(")"), "closing parenthesis ')' for expression");

            return innerExpr;
		}

		protected Expression ExpressionInfixRight(Parsed.Expression left, InfixOperator op)
		{
			Whitespace ();

            var right = Parse(() => Expression (op.precedence));
			if (right) {

				// We assume that the character we use for the operator's type is the same
				// as that used internally by e.g. Runtime.Expression.Add, Runtime.Expression.Multiply etc
				var expr = new BinaryExpression (left, right, op.type);
                return expr;
			}

            return null;

		}

		private InfixOperator ParseInfixOperator()
		{
            foreach (var op in _binaryOperators) {

                int ruleId = BeginRule ();

                if (ParseString (op.type) != null) {

                    if (op.requireWhitespace) {
                        if (Whitespace () == null) {
                            FailRule (ruleId);
                            continue;
                        }
                    }

                    return (InfixOperator) SucceedRule(ruleId, op);
                }

                FailRule (ruleId);
            }

            return null;
		}

        protected Parsed.List ExpressionList ()
        {
            Whitespace ();

            if (ParseString ("(") == null)
                return null;

            Whitespace ();

            // When list has:
            //  - 0 elements (null list) - this is okay, it's an empty list: "()"
            //  - 1 element - it could be confused for a single non-list related
            //    identifier expression in brackets, but this is a useless thing
            //    to do, so we reserve that syntax for a list with one item.
            //  - 2 or more elements - normal!
            List<Identifier> memberNames = SeparatedList (ListMember, Spaced (String (",")));

            Whitespace ();

            // May have failed to parse the inner list - the parentheses may
            // be for a normal expression
            if (ParseString (")") == null)
                return null;

            return new List (memberNames);
        }

        protected Identifier ListMember ()
        {
            Whitespace ();

            Identifier identifier = Parse (IdentifierWithMetadata);
            if (identifier == null)
                return null;

            var dot = ParseString (".");
            if (dot != null) {
                Identifier identifier2 = Expect (IdentifierWithMetadata, "element name within the set " + identifier) as Identifier;
                identifier.name = identifier.name + "." + identifier2?.name;
            }

            Whitespace ();

            return identifier;
        }

		void RegisterExpressionOperators()
		{
            _maxBinaryOpLength = 0;
			_binaryOperators = new List<InfixOperator> ();

            // These will be tried in order, so we need "<=" before "<"
            // for correctness

            RegisterBinaryOperator ("&&", precedence:1);
            RegisterBinaryOperator ("||", precedence:1);
            RegisterBinaryOperator ("and", precedence:1, requireWhitespace: true);
            RegisterBinaryOperator ("or", precedence:1, requireWhitespace: true);

            RegisterBinaryOperator ("==", precedence:2);
            RegisterBinaryOperator (">=", precedence:2);
            RegisterBinaryOperator ("<=", precedence:2);
            RegisterBinaryOperator ("<", precedence:2);
            RegisterBinaryOperator (">", precedence:2);
            RegisterBinaryOperator ("!=", precedence:2);

            // (apples, oranges) + cabbages has (oranges, cabbages) == true
            RegisterBinaryOperator ("?", precedence: 3);
            RegisterBinaryOperator ("has", precedence: 3, requireWhitespace:true);
            RegisterBinaryOperator ("!?", precedence: 3);
            RegisterBinaryOperator ("hasnt", precedence: 3, requireWhitespace: true);
            RegisterBinaryOperator ("^", precedence: 3);

			RegisterBinaryOperator ("+", precedence:4);
			RegisterBinaryOperator ("-", precedence:5);
			RegisterBinaryOperator ("*", precedence:6);
			RegisterBinaryOperator ("/", precedence:7);

            RegisterBinaryOperator ("%", precedence:8);
            RegisterBinaryOperator ("mod", precedence:8, requireWhitespace:true);


		}

        void RegisterBinaryOperator(string op, int precedence, bool requireWhitespace = false)
		{
            _binaryOperators.Add(new InfixOperator (op, precedence, requireWhitespace));
            _maxBinaryOpLength = Math.Max (_maxBinaryOpLength, op.Length);
		}

        List<InfixOperator> _binaryOperators;
        int _maxBinaryOpLength;
	}
}

